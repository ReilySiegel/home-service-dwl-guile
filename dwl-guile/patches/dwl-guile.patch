diff --git a/.gitignore b/.gitignore
index 0dde90e..b261fc3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,3 +4,7 @@ dwl
 *-protocol.h
 .ccls-cache
 config.h
+config.scm
+dwl.log
+*.patch
+patches
diff --git a/Makefile b/Makefile
index a0d1cc3..691ec14 100644
--- a/Makefile
+++ b/Makefile
@@ -1,12 +1,12 @@
 include config.mk
 
-CFLAGS += -I. -DWLR_USE_UNSTABLE -std=c99
+CFLAGS += -I. -DWLR_USE_UNSTABLE -std=c99 -Wno-declaration-after-statement
 
 WAYLAND_PROTOCOLS=$(shell pkg-config --variable=pkgdatadir wayland-protocols)
 WAYLAND_SCANNER=$(shell pkg-config --variable=wayland_scanner wayland-scanner)
 
-PKGS = wlroots wayland-server xcb xkbcommon libinput
-CFLAGS += $(foreach p,$(PKGS),$(shell pkg-config --cflags $(p)))
+PKGS = wlroots wayland-server xcb xkbcommon libinput guile-3.0
+CFLAGS += $(foreach p,$(PKGS),$(shell pkg-config --cflags $(p))) -DWLR_USE_UNSTABLE
 LDLIBS += $(foreach p,$(PKGS),$(shell pkg-config --libs $(p)))
 
 all: dwl
@@ -44,10 +44,7 @@ idle-protocol.c:
 
 idle-protocol.o: idle-protocol.h
 
-config.h: | config.def.h
-	cp config.def.h $@
-
-dwl.o: config.h client.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h idle-protocol.h
+dwl.o: dscm-utils.h dscm-bindings.h dscm-config.h client.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h idle-protocol.h
 
 dwl: xdg-shell-protocol.o wlr-layer-shell-unstable-v1-protocol.o idle-protocol.o
 
diff --git a/README.md b/README.md
index 22dfa07..43346d1 100644
--- a/README.md
+++ b/README.md
@@ -1,77 +1,4 @@
-# dwl - dwm for Wayland
-
-Join us on our [Discord server](https://discord.gg/jJxZnrGPWN)!
-
-dwl is a compact, hackable compositor for Wayland based on [wlroots](https://github.com/swaywm/wlroots). It is intended to fill the same space in the Wayland world that dwm does in X11, primarily in terms of philosophy, and secondarily in terms of functionality. Like dwm, dwl is:
-
-- Easy to understand, hack on, and extend with patches
-- One C source file (or a very small number) configurable via `config.h`
-- Limited to 2000 SLOC to promote hackability
-- Tied to as few external dependencies as possible
-
-dwl is not meant to provide every feature under the sun. Instead, like dwm, it sticks to features which are necessary, simple, and straightforward to implement given the base on which it is built. Implemented default features are:
-
-- Any features provided by dwm/Xlib: simple window borders, tags, keybindings, client rules, mouse move/resize. Providing a built-in status bar is an exception to this goal, to avoid dependencies on font rendering and/or drawing libraries when an external bar could work well.
-- Configurable multi-monitor layout support, including position and rotation
-- Configurable HiDPI/multi-DPI support
-- Various Wayland protocols
-- XWayland support as provided by wlroots
-- Zero flickering - Wayland users naturally expect that "every frame is perfect"
-
-Features under consideration (possibly as patches) are:
-
-- Protocols made trivial by wlroots
-- Provide information to external status bars via stdout or another file descriptor
-- Implement the input-inhibitor protocol to support screen lockers
-- Implement the idle-inhibit protocol which lets applications such as mpv disable idle monitoring
-- Layer shell popups (used by Waybar)
-- Basic yes/no damage tracking to avoid needless redraws
-- More in-depth damage region tracking ([which may improve power usage](https://mozillagfx.wordpress.com/2019/10/22/dramatically-reduced-power-usage-in-firefox-70-on-macos-with-core-animation/))
-- Implement the text-input and input-method protocols to support IME once ibus implements input-method v2 (see https://github.com/ibus/ibus/pull/2256 and https://github.com/djpohly/dwl/pull/12)
-- Implement urgent/attention/focus-request once it's part of the xdg-shell protocol (https://gitlab.freedesktop.org/wayland/wayland-protocols/-/merge_requests/9)
-
-Feature *non-goals* include:
-
-- Client-side decoration (any more than is necessary to tell the clients not to)
-- Client-initiated window management, such as move, resize, and close, which can be done through the compositor
-
-## Building dwl
-
-dwl has only two dependencies: wlroots 0.13 and wayland-protocols. Simply install these and run `make`.  If you wish to build against a Git version of wlroots, check out the [wlroots-next branch](https://github.com/djpohly/dwl/tree/wlroots-next).
-
-To enable XWayland, you should also install xorg-xwayland and uncomment its flag in `config.mk`.
-
-## Configuration
-
-All configuration is done by editing `config.h` and recompiling, in the same manner as dwm. There is no way to separately restart the window manager in Wayland without restarting the entire display server, so any changes will take effect the next time dwl is executed.
-
-As in the dwm community, we encourage users to share patches they have created.  Check out the [patches page on our wiki](https://github.com/djpohly/dwl/wiki/Patches)!
-
-## Running dwl
-
-dwl can be run as-is, with no arguments. In an existing Wayland or X11 session, this will open a window to act as a virtual display. When run from a TTY, the Wayland server will take over the entire virtual terminal. Clients started by dwl will have `WAYLAND_DISPLAY` set in their environment, and other clients can be started from outside the session by setting this variable accordingly.
-
-You can also specify a startup program using the `-s` option. The argument to this option will be run at startup as a shell command (using `sh -c`) and can serve a similar function to `.xinitrc`: starting a service manager or other startup applications. Unlike `.xinitrc`, the display server will not shut down when this process terminates. Instead, as dwl is shutting down, it will send this process a SIGTERM and wait for it to terminate (if it hasn't already). This makes it ideal not only for initialization but also for execing into a user-level service manager like s6 or `systemd --user`.
-
-Note: Wayland requires a valid `XDG_RUNTIME_DIR`, which is usually set up by a session manager such as `elogind` or `systemd-logind`.  If your system doesn't do this automatically, you will need to configure it prior to launching `dwl`, e.g.:
-
-    export XDG_RUNTIME_DIR=/tmp/xdg-runtime-$(id -u)
-    mkdir -p $XDG_RUNTIME_DIR
-
-## Replacements for X applications
-
-You can find a [list of Wayland applications on the sway wiki](https://github.com/swaywm/sway/wiki/i3-Migration-Guide).
-
-## IRC channel
-
-dwl's IRC channel is #dwl on irc.freenode.net.
-
-## Acknowledgements
-
-dwl began by extending the TinyWL example provided (CC0) by the sway/wlroots developers. This was made possible in many cases by looking at how sway accomplished something, then trying to do the same in as suckless a way as possible.
-
-Many thanks to suckless.org and the dwm developers and community for the inspiration, and to the various contributors to the project, including:
-
-- Alexander Courtis for the XWayland implementation
-- Guido Cella for the layer-shell protocol implementation, patch maintenance, and for helping to keep the project running
-- Stivvo for output management and fullscreen support, and patch maintenance
+# dwl-guile
+dwl-guile is a patch to dwl that adds dynamic configuration using Guile. It
+integrates with GNU Guix as a home service (see
+[home-service-dwl-guile](https://github.com/engstrand-config/home-service-dwl-guile)).
diff --git a/config.def.h b/config.def.h
deleted file mode 100644
index 089aa37..0000000
--- a/config.def.h
+++ /dev/null
@@ -1,116 +0,0 @@
-/* appearance */
-static const int sloppyfocus        = 1;  /* focus follows mouse */
-static const unsigned int borderpx  = 1;  /* border pixel of windows */
-static const float rootcolor[]      = {0.3, 0.3, 0.3, 1.0};
-static const float bordercolor[]    = {0.5, 0.5, 0.5, 1.0};
-static const float focuscolor[]     = {1.0, 0.0, 0.0, 1.0};
-
-/* tagging */
-static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
-
-static const Rule rules[] = {
-	/* app_id     title       tags mask     isfloating   monitor */
-	/* examples:
-	{ "Gimp",     NULL,       0,            1,           -1 },
-	{ "firefox",  NULL,       1 << 8,       0,           -1 },
-	*/
-};
-
-/* layout(s) */
-static const Layout layouts[] = {
-	/* symbol     arrange function */
-	{ "[]=",      tile },
-	{ "><>",      NULL },    /* no layout function means floating behavior */
-	{ "[M]",      monocle },
-};
-
-/* monitors
- * The order in which monitors are defined determines their position.
- * Non-configured monitors are always added to the left. */
-static const MonitorRule monrules[] = {
-	/* name       mfact nmaster scale layout       rotate/reflect x y */
-	/* example of a HiDPI laptop monitor:
-	{ "eDP-1",    0.5,  1,      2,    &layouts[0], WL_OUTPUT_TRANSFORM_NORMAL, 0, 0 },
-	*/
-	/* defaults */
-	{ NULL,       0.55, 1,      1,    &layouts[0], WL_OUTPUT_TRANSFORM_NORMAL, 0, 0 },
-};
-
-/* keyboard */
-static const struct xkb_rule_names xkb_rules = {
-	/* can specify fields: rules, model, layout, variant, options */
-	/* example:
-	.options = "ctrl:nocaps",
-	*/
-};
-
-static const int repeat_rate = 25;
-static const int repeat_delay = 600;
-
-/* Trackpad */
-static const int tap_to_click = 1;
-static const int natural_scrolling = 0;
-
-#define MODKEY WLR_MODIFIER_ALT
-#define TAGKEYS(KEY,SKEY,TAG) \
-	{ MODKEY,                    KEY,            view,            {.ui = 1 << TAG} }, \
-	{ MODKEY|WLR_MODIFIER_CTRL,  KEY,            toggleview,      {.ui = 1 << TAG} }, \
-	{ MODKEY|WLR_MODIFIER_SHIFT, SKEY,           tag,             {.ui = 1 << TAG} }, \
-	{ MODKEY|WLR_MODIFIER_CTRL|WLR_MODIFIER_SHIFT,SKEY,toggletag, {.ui = 1 << TAG} }
-
-/* helper for spawning shell commands in the pre dwm-5.0 fashion */
-#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
-
-/* commands */
-static const char *termcmd[] = { "alacritty", NULL };
-static const char *menucmd[] = { "bemenu-run", NULL };
-
-static const Key keys[] = {
-	/* Note that Shift changes certain key codes: c -> C, 2 -> at, etc. */
-	/* modifier                  key                 function        argument */
-	{ MODKEY,                    XKB_KEY_p,          spawn,          {.v = menucmd} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Return,     spawn,          {.v = termcmd} },
-	{ MODKEY,                    XKB_KEY_j,          focusstack,     {.i = +1} },
-	{ MODKEY,                    XKB_KEY_k,          focusstack,     {.i = -1} },
-	{ MODKEY,                    XKB_KEY_i,          incnmaster,     {.i = +1} },
-	{ MODKEY,                    XKB_KEY_d,          incnmaster,     {.i = -1} },
-	{ MODKEY,                    XKB_KEY_h,          setmfact,       {.f = -0.05} },
-	{ MODKEY,                    XKB_KEY_l,          setmfact,       {.f = +0.05} },
-	{ MODKEY,                    XKB_KEY_Return,     zoom,           {0} },
-	{ MODKEY,                    XKB_KEY_Tab,        view,           {0} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_C,          killclient,     {0} },
-	{ MODKEY,                    XKB_KEY_t,          setlayout,      {.v = &layouts[0]} },
-	{ MODKEY,                    XKB_KEY_f,          setlayout,      {.v = &layouts[1]} },
-	{ MODKEY,                    XKB_KEY_m,          setlayout,      {.v = &layouts[2]} },
-	{ MODKEY,                    XKB_KEY_space,      setlayout,      {0} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_space,      togglefloating, {0} },
-	{ MODKEY, 					 XKB_KEY_e,    		togglefullscreen, {0} },
-	{ MODKEY,                    XKB_KEY_0,          view,           {.ui = ~0} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_parenright, tag,            {.ui = ~0} },
-	{ MODKEY,                    XKB_KEY_comma,      focusmon,       {.i = WLR_DIRECTION_LEFT} },
-	{ MODKEY,                    XKB_KEY_period,     focusmon,       {.i = WLR_DIRECTION_RIGHT} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_less,       tagmon,         {.i = WLR_DIRECTION_LEFT} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_greater,    tagmon,         {.i = WLR_DIRECTION_RIGHT} },
-	TAGKEYS(          XKB_KEY_1, XKB_KEY_exclam,                     0),
-	TAGKEYS(          XKB_KEY_2, XKB_KEY_at,                         1),
-	TAGKEYS(          XKB_KEY_3, XKB_KEY_numbersign,                 2),
-	TAGKEYS(          XKB_KEY_4, XKB_KEY_dollar,                     3),
-	TAGKEYS(          XKB_KEY_5, XKB_KEY_percent,                    4),
-	TAGKEYS(          XKB_KEY_6, XKB_KEY_caret,                      5),
-	TAGKEYS(          XKB_KEY_7, XKB_KEY_ampersand,                  6),
-	TAGKEYS(          XKB_KEY_8, XKB_KEY_asterisk,                   7),
-	TAGKEYS(          XKB_KEY_9, XKB_KEY_parenleft,                  8),
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Q,          quit,           {0} },
-
-	/* Ctrl-Alt-Backspace and Ctrl-Alt-Fx used to be handled by X server */
-	{ WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_Terminate_Server, quit, {0} },
-#define CHVT(n) { WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_XF86Switch_VT_##n, chvt, {.ui = (n)} }
-	CHVT(1), CHVT(2), CHVT(3), CHVT(4), CHVT(5), CHVT(6),
-	CHVT(7), CHVT(8), CHVT(9), CHVT(10), CHVT(11), CHVT(12),
-};
-
-static const Button buttons[] = {
-	{ MODKEY, BTN_LEFT,   moveresize,     {.ui = CurMove} },
-	{ MODKEY, BTN_MIDDLE, togglefloating, {0} },
-	{ MODKEY, BTN_RIGHT,  moveresize,     {.ui = CurResize} },
-};
diff --git a/dscm-bindings.h b/dscm-bindings.h
new file mode 100644
index 0000000..9d104f5
--- /dev/null
+++ b/dscm-bindings.h
@@ -0,0 +1,268 @@
+static inline SCM
+dscm_binding_monocle(SCM monitor)
+{
+        Monitor *m = (Monitor*)scm_to_pointer(monitor);
+        monocle(m);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_tile(SCM monitor)
+{
+        Monitor *m = (Monitor*)scm_to_pointer(monitor);
+        tile(m);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_spawn(SCM args)
+{
+        if (scm_is_null(args))
+                return SCM_BOOL_F;
+        unsigned int i = 0, length = dscm_get_list_length(args);
+        char *cmd_args[length + 1];
+        for (; i < length; i++) {
+                SCM arg_exp = dscm_get_list_item(args, i);
+                char *arg = scm_to_locale_string(arg_exp);
+                cmd_args[i] = arg;
+        }
+        cmd_args[i] = NULL;
+        Arg a = {.v = cmd_args};
+        spawn(&a);
+        for (char **iter = cmd_args; *iter != NULL; iter++)
+                free(*iter);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_shcmd(SCM args)
+{
+        SCM extended = scm_list_3(scm_from_utf8_string("/bin/sh"),
+                scm_from_utf8_string("-c"), args);
+        return dscm_binding_spawn(extended);
+}
+
+static inline SCM
+dscm_binding_spawn_menu()
+{
+        Arg a = {.v = menucmd};
+        spawn(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_spawn_terminal()
+{
+        Arg a = {.v = termcmd};
+        spawn(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_focusstack(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        focusstack(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_setmfact(SCM value)
+{
+        Arg a = {.f = scm_to_double(value)};
+        setmfact(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_togglefloating()
+{
+        togglefloating(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_zoom()
+{
+        zoom(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_setlayout(SCM value)
+{
+        char *id = scm_to_locale_string(value);
+        Layout *layout = NULL;
+        for (int i = 0; i < numlayouts; i++) {
+                if (strcmp(layouts[i].id, id) == 0)
+                        layout = &layouts[i];
+        }
+        if (layout == NULL)
+                return SCM_BOOL_F;
+        Arg a = {.v = layout};
+        setlayout(&a);
+        free(id);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_togglefullscreen()
+{
+        togglefullscreen(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_focusmon(SCM value)
+{
+        SCM eval = scm_primitive_eval(value);
+        Arg a = {.i = scm_to_int(eval)};
+        focusmon(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_tagmon(SCM value)
+{
+        SCM eval = scm_primitive_eval(value);
+        Arg a = {.i = scm_to_int(eval)};
+        tagmon(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_chvt(SCM tty)
+{
+        if (!scm_is_number(tty))
+                return SCM_BOOL_F;
+        int target_tty = scm_to_int(tty);
+        if (target_tty <= 0 || target_tty > 12)
+                return SCM_BOOL_F;
+        Arg a = {.ui = (unsigned int)target_tty};
+        chvt(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_view(SCM value)
+{
+        Arg a = {.ui = dscm_get_tag(value, numtags)};
+        view(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_toggleview(SCM value)
+{
+        Arg a = {.ui = dscm_get_tag(value, numtags)};
+        toggleview(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_tag(SCM value)
+{
+        Arg a = {.ui = dscm_get_tag(value, numtags)};
+        tag(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incnmaster(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incnmaster(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_toggletag(SCM value)
+{
+        Arg a = {.ui = dscm_get_tag(value, numtags)};
+        toggletag(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_moveresize(SCM cursor)
+{
+        Arg a = {.ui = scm_to_unsigned_integer(cursor, 0, CurResize)};
+        moveresize(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_killclient()
+{
+        killclient(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_quit()
+{
+        quit(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline void
+dscm_register()
+{
+        scm_c_define("SHIFT", scm_from_int(WLR_MODIFIER_SHIFT));
+        scm_c_define("CAPS", scm_from_int(WLR_MODIFIER_CAPS));
+        scm_c_define("CTRL", scm_from_int(WLR_MODIFIER_CTRL));
+        scm_c_define("ALT", scm_from_int(WLR_MODIFIER_ALT));
+        scm_c_define("MOD2", scm_from_int(WLR_MODIFIER_MOD2));
+        scm_c_define("MOD3", scm_from_int(WLR_MODIFIER_MOD3));
+        scm_c_define("SUPER", scm_from_int(WLR_MODIFIER_LOGO));
+        scm_c_define("MOD5", scm_from_int(WLR_MODIFIER_MOD5));
+        /* TODO: add bindings for other mouse buttons */
+        scm_c_define("DIRECTION-LEFT", scm_from_int(WLR_DIRECTION_LEFT));
+        scm_c_define("DIRECTION-RIGHT", scm_from_int(WLR_DIRECTION_RIGHT));
+        scm_c_define("MOUSE-LEFT", scm_from_int(BTN_LEFT));
+        scm_c_define("MOUSE-MIDDLE", scm_from_int(BTN_MIDDLE));
+        scm_c_define("MOUSE-RIGHT", scm_from_int(BTN_RIGHT));
+        scm_c_define("CURSOR-NORMAL", scm_from_int(CurNormal));
+        scm_c_define("CURSOR-MOVE", scm_from_int(CurMove));
+        scm_c_define("CURSOR-RESIZE", scm_from_int(CurResize));
+        scm_c_define("TRANSFORM-NORMAL",
+                scm_from_int(WL_OUTPUT_TRANSFORM_NORMAL));
+        scm_c_define("TRANSFORM-ROTATE-90",
+                scm_from_int(WL_OUTPUT_TRANSFORM_90));
+        scm_c_define("TRANSFORM-ROTATE-180",
+                scm_from_int(WL_OUTPUT_TRANSFORM_180));
+        scm_c_define("TRANSFORM-ROTATE-270",
+                scm_from_int(WL_OUTPUT_TRANSFORM_270));
+        scm_c_define("TRANSFORM-FLIPPED",
+                scm_from_int(WL_OUTPUT_TRANSFORM_FLIPPED));
+        scm_c_define("TRANSFORM-FLIPPED-90",
+                scm_from_int(WL_OUTPUT_TRANSFORM_FLIPPED_90));
+        scm_c_define("TRANSFORM-FLIPPED-180",
+                scm_from_int(WL_OUTPUT_TRANSFORM_FLIPPED_180));
+        scm_c_define("TRANSFORM-FLIPPED-270",
+                scm_from_int(WL_OUTPUT_TRANSFORM_FLIPPED_270));
+
+        scm_c_define_gsubr("dwl:chvt", 1, 0, 0, &dscm_binding_chvt);
+        scm_c_define_gsubr("dwl:quit", 0, 0, 0, &dscm_binding_quit);
+        scm_c_define_gsubr("dwl:killclient", 0, 0, 0, &dscm_binding_killclient);
+        scm_c_define_gsubr("dwl:tile", 1, 0, 0, &dscm_binding_tile);
+        scm_c_define_gsubr("dwl:monocle", 1, 0, 0, &dscm_binding_monocle);
+        scm_c_define_gsubr("dwl:spawn", 0, 0, 1, &dscm_binding_spawn);
+        scm_c_define_gsubr("dwl:view", 1, 0, 0, &dscm_binding_view);
+        scm_c_define_gsubr("dwl:toggle-view", 1, 0, 0, &dscm_binding_toggleview);
+        scm_c_define_gsubr("dwl:tag", 1, 0, 0, &dscm_binding_tag);
+        scm_c_define_gsubr("dwl:toggle-tag", 1, 0, 0, &dscm_binding_toggletag);
+        scm_c_define_gsubr("dwl:focus-stack", 1, 0, 0, &dscm_binding_focusstack);
+        scm_c_define_gsubr("dwl:set-master-factor", 1, 0, 0, &dscm_binding_setmfact);
+        scm_c_define_gsubr("dwl:zoom", 0, 0, 0, &dscm_binding_zoom);
+        scm_c_define_gsubr("dwl:set-layout", 1, 0, 0, &dscm_binding_setlayout);
+        scm_c_define_gsubr("dwl:toggle-fullscreen", 0, 0, 0, &dscm_binding_togglefullscreen);
+        scm_c_define_gsubr("dwl:toggle-floating", 0, 0, 0, &dscm_binding_togglefloating);
+        scm_c_define_gsubr("dwl:focus-monitor", 1, 0, 0, &dscm_binding_focusmon);
+        scm_c_define_gsubr("dwl:tag-monitor", 1, 0, 0, &dscm_binding_tagmon);
+        scm_c_define_gsubr("dwl:move-resize", 1, 0, 0, &dscm_binding_moveresize);
+        scm_c_define_gsubr("dwl:set-masters", 1, 0, 0, &dscm_binding_incnmaster);
+        scm_c_define_gsubr("dwl:shcmd", 1, 0, 0, &dscm_binding_shcmd);
+        scm_c_define_gsubr("dwl:spawn-menu", 0, 0, 0, &dscm_binding_spawn_menu);
+        scm_c_define_gsubr("dwl:spawn-terminal", 0, 0, 0, &dscm_binding_spawn_terminal);
+}
diff --git a/dscm-config.h b/dscm-config.h
new file mode 100644
index 0000000..058f82b
--- /dev/null
+++ b/dscm-config.h
@@ -0,0 +1,196 @@
+#pragma once
+
+SCM config;
+
+/* Config variable definitions. */
+/* These will be automatically set from the guile config. */
+static int repeat_rate          = 25;
+static int repeat_delay         = 600;
+static int sloppyfocus          = 1;
+static int tap_to_click         = 1;
+static int natural_scrolling    = 1;
+static unsigned int borderpx    = 1;
+static float *rootcolor         = NULL;
+static float *bordercolor       = NULL;
+static float *focuscolor        = NULL;
+static char **tags              = NULL;
+static char **termcmd           = NULL;
+static char **menucmd           = NULL;
+static Layout *layouts          = NULL;
+static MonitorRule *monrules    = NULL;
+static Rule *rules              = NULL;
+static Key *keys                = NULL;
+static Button *buttons          = NULL;
+static struct xkb_rule_names *xkb_rules = NULL;
+
+static unsigned int numtags     = 0;
+static unsigned int numkeys     = 0;
+static unsigned int numrules    = 0;
+static unsigned int numlayouts  = 0;
+static unsigned int nummonrules = 0;
+static unsigned int numbuttons  = 0;
+static unsigned int TAGMASK     = 0;
+
+static inline void
+dscm_parse_color(unsigned int index, SCM value, void *data)
+{
+        ((float*)data)[index] = (float)scm_to_double(value);
+}
+
+static inline void
+dscm_parse_string(unsigned int index, SCM str, void *data)
+{
+        ((char**)data)[index] = scm_to_locale_string(str);
+}
+
+static inline void
+dscm_parse_layout(unsigned int index, SCM layout, void *data)
+{
+        ((Layout*)data)[index] = (Layout){
+                .id = dscm_alist_get_string(layout, "id"),
+                .symbol = dscm_alist_get_string(layout, "symbol"),
+                .arrange = dscm_alist_get_proc_pointer(layout, "arrange")
+        };
+}
+
+static inline void
+dscm_parse_monitor_rule(unsigned int index, SCM rule, void *data)
+{
+        SCM transform = dscm_alist_get(rule, "transform");
+        SCM eval = scm_primitive_eval(transform);
+        ((MonitorRule*)data)[index] = (MonitorRule){
+                .name = dscm_alist_get_string(rule, "name"),
+                .mfact = dscm_alist_get_float(rule, "master-factor"),
+                .nmaster = dscm_alist_get_int(rule, "masters"),
+                .scale = dscm_alist_get_float(rule, "scale"),
+                .lt = &layouts[dscm_alist_get_int(rule, "layout")],
+                .rr = (enum wl_output_transform)scm_to_int(eval),
+                .x = dscm_alist_get_int(rule, "x"),
+                .y = dscm_alist_get_int(rule, "y"),
+        };
+}
+
+static inline void
+dscm_parse_rule(unsigned int index, SCM rule, void *data)
+{
+         ((Rule*)data)[index] = (Rule){
+                .id = dscm_alist_get_string(rule, "id"),
+                .title = dscm_alist_get_string(rule, "title"),
+                .tags = dscm_alist_get_unsigned_int(rule, "tag", -1),
+                .isfloating = dscm_alist_get_int(rule, "floating"),
+                .monitor = dscm_alist_get_int(rule, "monitor")
+         };
+}
+
+static inline void
+dscm_parse_key(unsigned int index, SCM key, void *data)
+{
+        xkb_keycode_t keycode = dscm_alist_get_unsigned_int(key, "key", -1);
+        /* Should we use `xkb_keycode_is_legal_x11`? */
+        if (!xkb_keycode_is_legal_x11(keycode)
+                || !xkb_keycode_is_legal_ext(keycode))
+                BARF("dscm: keycode '%d' is not a legal keycode\n", keycode);
+        ((Key*)data)[index] = (Key){
+                .mod = dscm_alist_get_modifiers(key, "modifiers"),
+                .keycode = keycode,
+                .func = dscm_alist_get_proc_pointer(key, "action")
+        };
+}
+
+static inline void
+dscm_parse_button(unsigned int index, SCM button, void *data)
+{
+        SCM symbol = dscm_alist_get(button, "button");
+        SCM eval = scm_primitive_eval(symbol);
+        ((Button*)data)[index] = (Button){
+                .mod = (unsigned int)dscm_alist_get_modifiers(button, "modifiers"),
+                .button = scm_to_unsigned_integer(eval, 0, -1),
+                .func = dscm_alist_get_proc_pointer(button, "action")
+        };
+}
+
+static inline struct xkb_rule_names *
+dscm_parse_xkb_rules(SCM config)
+{
+        SCM xkb = dscm_alist_get(config, "xkb-rules");
+        struct xkb_rule_names *dest = calloc(1, sizeof(struct xkb_rule_names));
+        *dest = (struct xkb_rule_names){
+                .rules = dscm_alist_get_string(xkb, "rules"),
+                .model = dscm_alist_get_string(xkb, "model"),
+                .layout = dscm_alist_get_string(xkb, "layouts"),
+                .variant = dscm_alist_get_string(xkb, "variants"),
+                .options = dscm_alist_get_string(xkb, "options"),
+        };
+        return dest;
+}
+
+static inline void
+dscm_config_parse(char *config_file)
+{
+        scm_c_primitive_load(config_file);
+        config = dscm_get_variable("config");
+
+        sloppyfocus = dscm_alist_get_int(config, "sloppy-focus");
+        tap_to_click = dscm_alist_get_int(config, "tap-to-click");
+        natural_scrolling = dscm_alist_get_int(config, "natural-scrolling");
+        borderpx = dscm_alist_get_unsigned_int(config, "border-px", 25);
+        repeat_rate = dscm_alist_get_unsigned_int(config, "repeat-rate", 5000);
+        repeat_delay = dscm_alist_get_unsigned_int(config, "repeat-delay", 5000);
+
+        SCM colors = dscm_alist_get(config, "colors");
+        rootcolor = dscm_iterate_list(dscm_alist_get(colors, "root"),
+                sizeof(float), 0, &dscm_parse_color, NULL);
+        bordercolor = dscm_iterate_list(dscm_alist_get(colors, "border"),
+                sizeof(float), 0, &dscm_parse_color, NULL);
+        focuscolor = dscm_iterate_list(dscm_alist_get(colors, "focus"),
+                sizeof(float), 0, &dscm_parse_color, NULL);
+        tags = dscm_iterate_list(dscm_alist_get(config, "tags"),
+                sizeof(char*), 0, &dscm_parse_string, &numtags);
+        termcmd = dscm_iterate_list(dscm_alist_get(config, "terminal"),
+                sizeof(char*), 1, &dscm_parse_string, NULL);
+        menucmd = dscm_iterate_list(dscm_alist_get(config, "menu"),
+                sizeof(char*), 1, &dscm_parse_string, NULL);
+        layouts = dscm_iterate_list(dscm_alist_get(config, "layouts"),
+                sizeof(Layout), 0, &dscm_parse_layout, &numlayouts);
+        rules = dscm_iterate_list(dscm_alist_get(config, "rules"),
+                sizeof(Rule), 0, &dscm_parse_rule, &numrules);
+        monrules = dscm_iterate_list(dscm_alist_get(config, "monitor-rules"),
+                sizeof(MonitorRule), 0, &dscm_parse_monitor_rule, &nummonrules);
+        keys = dscm_iterate_list(dscm_alist_get(config, "keys"),
+                sizeof(Key), 0, &dscm_parse_key, &numkeys);
+        buttons = dscm_iterate_list(dscm_alist_get(config, "buttons"),
+                sizeof(Button), 0, &dscm_parse_button, &numbuttons);
+        xkb_rules = dscm_parse_xkb_rules(config);
+        TAGMASK = ((1 << numtags) - 1);
+}
+
+static inline void
+dscm_config_cleanup()
+{
+        fprintf(stdout, "dscm: starting cleanup\n");
+        int i;
+        char **str;
+        for (i = 0; i < numtags; i++) free(tags[i]);
+        for (str = termcmd; *str != NULL; str++) free(*str);
+        for (str = menucmd; *str != NULL; str++) free(*str);
+        for (i = 0; i < numlayouts; i++) free(layouts[i].symbol);
+        for (i = 0; i < nummonrules; i++) free(monrules[i].name);
+        for (i = 0; i < numrules; i++) {
+                Rule r = rules[i];
+                free(r.id);
+                free(r.title);
+        }
+        free(layouts);
+        free(monrules);
+        free(keys);
+        free(buttons);
+        free(rootcolor);
+        free(bordercolor);
+        free(focuscolor);
+        free((char*)xkb_rules->rules);
+        free((char*)xkb_rules->model);
+        free((char*)xkb_rules->layout);
+        free((char*)xkb_rules->variant);
+        free((char*)xkb_rules->options);
+        free(xkb_rules);
+}
diff --git a/dscm-utils.h b/dscm-utils.h
new file mode 100644
index 0000000..57800d6
--- /dev/null
+++ b/dscm-utils.h
@@ -0,0 +1,162 @@
+#pragma once
+
+enum { DSCM_CALL_ARRANGE, DSCM_CALL_ACTION };
+typedef struct {
+        SCM proc;
+        void *args;
+} dscm_call_data_t;
+
+static inline SCM
+dscm_alist_get(SCM alist, const char* key)
+{
+        return scm_assoc_ref(alist, scm_from_utf8_string(key));
+}
+
+static inline char*
+dscm_alist_get_string(SCM alist, const char* key)
+{
+        SCM value = dscm_alist_get(alist, key);
+        if (scm_is_string(value))
+                return scm_to_locale_string(value);
+        return NULL;
+}
+
+static inline int
+dscm_alist_get_int(SCM alist, const char* key)
+{
+        SCM value = dscm_alist_get(alist, key);
+        if (scm_is_bool(value))
+                return scm_is_true(value) ? 1 : 0;
+        return scm_to_int(value);
+}
+
+static inline unsigned int
+dscm_alist_get_unsigned_int(SCM alist, const char* key, int max)
+{
+        return scm_to_unsigned_integer(dscm_alist_get(alist, key), 0, max);
+}
+
+static inline double
+dscm_alist_get_double(SCM alist, const char* key)
+{
+        SCM value = dscm_alist_get(alist, key);
+        if (scm_is_bool(value))
+                return scm_is_true(value) ? 1 : 0;
+        return scm_to_double(value);
+}
+
+static inline float
+dscm_alist_get_float(SCM alist, const char* key)
+{
+        return (float)dscm_alist_get_double(alist, key);
+}
+
+static inline scm_t_bits *
+dscm_alist_get_proc_pointer(SCM alist, const char *key)
+{
+        scm_t_bits *proc = NULL;
+        SCM value = dscm_alist_get(alist, key);
+        if (scm_is_false(value))
+                return proc;
+        SCM eval = scm_primitive_eval(value);
+        /* SCM_UNPACK_POINTER is only allowed on expressions where SCM_IMP is 0 */
+        if (SCM_IMP(eval) == 1)
+                BARF("dscm: invalid callback procedure. SCM_IMP(proc) = 1");
+        if (scm_procedure_p(eval) == SCM_BOOL_T) {
+                proc = SCM_UNPACK_POINTER(eval);
+                scm_gc_protect_object(eval);
+        }
+        return proc;
+}
+
+static inline SCM
+dscm_get_variable(const char *name)
+{
+        return scm_variable_ref(scm_c_lookup(name));
+}
+
+static inline unsigned int
+dscm_get_list_length(SCM list)
+{
+        return scm_to_unsigned_integer(scm_length(list), 0, -1);
+}
+
+static inline SCM
+dscm_get_list_item(SCM list, unsigned int index)
+{
+        return scm_list_ref(list, scm_from_unsigned_integer(index));
+}
+
+static inline uint32_t
+dscm_alist_get_modifiers(SCM alist, const char *key)
+{
+        SCM modifiers = dscm_alist_get(alist, key);
+        uint32_t mod = 0;
+        unsigned int i = 0, length = dscm_get_list_length(modifiers);
+        for (; i < length; i++) {
+                SCM item = dscm_get_list_item(modifiers, i);
+                SCM eval = scm_primitive_eval(item);
+                mod |= scm_to_uint32(eval);
+        }
+        return mod;
+}
+
+static inline unsigned int
+dscm_get_tag(SCM tag, unsigned int tags)
+{
+        unsigned int target_tag = scm_to_unsigned_integer(tag, 1, tags) - 1;
+        return (1 << (target_tag));
+}
+
+static inline void *
+dscm_iterate_list(SCM list, size_t elem_size, int append_null,
+        void (*iterator)(unsigned int, SCM, void*), unsigned int *length_var)
+{
+        unsigned int i = 0, length = 0;
+        length = dscm_get_list_length(list);
+        void *allocated = calloc(append_null ? length + 1 : length, elem_size);
+        for (; i < length; i++) {
+                SCM item = dscm_get_list_item(list, i);
+                (*iterator)(i, item, allocated);
+        }
+        if (append_null)
+                ((void**)allocated)[i] = NULL;
+        if (length_var)
+                *length_var = length;
+        return allocated;
+}
+
+static inline void*
+dscm_call_action(void *data)
+{
+        return scm_call_0(((dscm_call_data_t*)data)->proc);
+}
+
+static inline void*
+dscm_call_arrange(void *data)
+{
+        dscm_call_data_t *proc_data = (dscm_call_data_t*)data;
+        SCM mon = scm_from_pointer(proc_data->args, NULL);
+        return scm_call_1(proc_data->proc, mon);
+}
+
+static inline void
+dscm_safe_call(unsigned int type, scm_t_bits *proc_ptr, void *data)
+{
+        if (proc_ptr == NULL) {
+                fprintf(stderr, "dscm: could not call proc that is NULL");
+                return;
+        }
+        SCM proc = SCM_PACK_POINTER(proc_ptr);
+        dscm_call_data_t proc_data = {.proc = proc, .args = data};
+        void *(*func)(void*) = NULL;
+        switch (type) {
+            case DSCM_CALL_ARRANGE:
+                func = &dscm_call_arrange;
+                break;
+            case DSCM_CALL_ACTION:
+            default:
+                func = &dscm_call_action;
+        }
+        scm_c_with_continuation_barrier(func, &proc_data);
+}
diff --git a/dwl.c b/dwl.c
index 0deae84..5d65b02 100644
--- a/dwl.c
+++ b/dwl.c
@@ -42,6 +42,7 @@
 #include <wlr/backend/libinput.h>
 #include <wlr/util/log.h>
 #include <xkbcommon/xkbcommon.h>
+#include <libguile.h>
 #ifdef XWAYLAND
 #include <X11/Xlib.h>
 #include <wlr/xwayland.h>
@@ -55,8 +56,6 @@
 #define CLEANMASK(mask)         (mask & ~WLR_MODIFIER_CAPS)
 #define VISIBLEON(C, M)         ((C)->mon == (M) && ((C)->tags & (M)->tagset[(M)->seltags]))
 #define LENGTH(X)               (sizeof X / sizeof X[0])
-#define END(A)                  ((A) + LENGTH(A))
-#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
 #define ROUND(X)                ((int)((X)+0.5))
 #define LISTEN(E, L, H)         wl_signal_add((E), ((L)->notify = (H), (L)))
 
@@ -72,14 +71,13 @@ typedef union {
 	int i;
 	unsigned int ui;
 	float f;
-	const void *v;
+	void *v;
 } Arg;
 
 typedef struct {
 	unsigned int mod;
 	unsigned int button;
-	void (*func)(const Arg *);
-	const Arg arg;
+        scm_t_bits *func;
 } Button;
 
 typedef struct Monitor Monitor;
@@ -121,9 +119,8 @@ typedef struct {
 
 typedef struct {
 	uint32_t mod;
-	xkb_keysym_t keysym;
-	void (*func)(const Arg *);
-	const Arg arg;
+	xkb_keycode_t keycode;
+        scm_t_bits *func;
 } Key;
 
 typedef struct {
@@ -157,8 +154,9 @@ typedef struct {
 } Edge;
 
 typedef struct {
-	const char *symbol;
-	void (*arrange)(Monitor *);
+	char *symbol;
+        scm_t_bits *arrange;
+        char *id;
 } Layout;
 
 struct Monitor {
@@ -178,7 +176,7 @@ struct Monitor {
 };
 
 typedef struct {
-	const char *name;
+	char *name;
 	float mfact;
 	int nmaster;
 	float scale;
@@ -189,8 +187,8 @@ typedef struct {
 } MonitorRule;
 
 typedef struct {
-	const char *id;
-	const char *title;
+	char *id;
+	char *title;
 	unsigned int tags;
 	int isfloating;
 	int monitor;
@@ -242,7 +240,7 @@ static Client *focustop(Monitor *m);
 static void getxdecomode(struct wl_listener *listener, void *data);
 static void incnmaster(const Arg *arg);
 static void inputdevice(struct wl_listener *listener, void *data);
-static int keybinding(uint32_t mods, xkb_keysym_t sym);
+static int keybinding(uint32_t mods, xkb_keycode_t keycode);
 static void keypress(struct wl_listener *listener, void *data);
 static void keypressmod(struct wl_listener *listener, void *data);
 static void killclient(const Arg *arg);
@@ -276,7 +274,7 @@ static void setfullscreen(Client *c, int fullscreen);
 static void setlayout(const Arg *arg);
 static void setmfact(const Arg *arg);
 static void setmon(Client *c, Monitor *m, unsigned int newtags);
-static void setup(void);
+static void setup(char* config_file);
 static void sigchld(int unused);
 static void spawn(const Arg *arg);
 static void tag(const Arg *arg);
@@ -298,6 +296,9 @@ static struct wlr_surface *xytolayersurface(struct wl_list *layer_surfaces,
 static Monitor *xytomon(double x, double y);
 static void zoom(const Arg *arg);
 
+/* signal actions */
+static int reloadconfig(int signal, void *data);
+
 /* variables */
 static const char broken[] = "broken";
 static struct wl_display *dpy;
@@ -367,12 +368,14 @@ static struct wlr_xwayland *xwayland;
 static Atom netatom[NetLast];
 #endif
 
-/* configuration, allows nested code to access above variables */
-#include "config.h"
-
 /* attempt to encapsulate suck into one file */
 #include "client.h"
 
+/* include guile config and bindings */
+#include "dscm-utils.h"
+#include "dscm-config.h"
+#include "dscm-bindings.h"
+
 /* compile-time check if all tags fit into an unsigned int bit array. */
 struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
 
@@ -454,8 +457,8 @@ applyrules(Client *c)
 {
 	/* rule matching */
 	const char *appid, *title;
-	unsigned int i, newtags = 0;
-	const Rule *r;
+	unsigned int j, newtags = 0;
+	Rule r;
 	Monitor *mon = selmon, *m;
 
 	c->isfloating = client_is_float_type(c);
@@ -464,32 +467,34 @@ applyrules(Client *c)
 	if (!(title = client_get_title(c)))
 		title = broken;
 
-	for (r = rules; r < END(rules); r++) {
-		if ((!r->title || strstr(title, r->title))
-				&& (!r->id || strstr(appid, r->id))) {
-			c->isfloating = r->isfloating;
-			newtags |= r->tags;
-			i = 0;
+        for (int i = 0; i < numrules; i++) {
+                r = rules[i];
+		if ((!r.title || strstr(title, r.title))
+				&& (!r.id || strstr(appid, r.id))) {
+			c->isfloating = r.isfloating;
+			newtags |= r.tags;
+			j = 0;
 			wl_list_for_each(m, &mons, link)
-				if (r->monitor == i++)
+				if (r.monitor == j++)
 					mon = m;
 		}
 	}
+	wl_list_insert(c->isfloating ? &stack : stack.prev, &c->slink);
 	setmon(c, mon, newtags);
 }
 
 void
 arrange(Monitor *m)
 {
-	if (m->lt[m->sellt]->arrange)
-		m->lt[m->sellt]->arrange(m);
+        if (m->lt[m->sellt]->arrange)
+                dscm_safe_call(DSCM_CALL_ARRANGE, m->lt[m->sellt]->arrange, m);
 	/* TODO recheck pointer focus here... or in resize()? */
 }
 
 void
 arrangelayer(Monitor *m, struct wl_list *list, struct wlr_box *usable_area, int exclusive)
 {
-	LayerSurface *layersurface;
+        LayerSurface *layersurface;
 	struct wlr_box full_area = m->m;
 
 	wl_list_for_each(layersurface, list, link) {
@@ -635,7 +640,7 @@ buttonpress(struct wl_listener *listener, void *data)
 	struct wlr_keyboard *keyboard;
 	uint32_t mods;
 	Client *c;
-	const Button *b;
+	Button b;
 
 	wlr_idle_notify_activity(idle, seat);
 
@@ -647,10 +652,11 @@ buttonpress(struct wl_listener *listener, void *data)
 
 		keyboard = wlr_seat_get_keyboard(seat);
 		mods = wlr_keyboard_get_modifiers(keyboard);
-		for (b = buttons; b < END(buttons); b++) {
-			if (CLEANMASK(mods) == CLEANMASK(b->mod) &&
-					event->button == b->button && b->func) {
-				b->func(&b->arg);
+                for (int i = 0; i < numbuttons; i++) {
+                        b = buttons[i];
+			if (CLEANMASK(mods) == CLEANMASK(b.mod) &&
+					event->button == b.button && b.func) {
+                                dscm_safe_call(DSCM_CALL_ACTION, b.func, NULL);
 				return;
 			}
 		}
@@ -788,7 +794,7 @@ createkeyboard(struct wlr_input_device *device)
 
 	/* Prepare an XKB keymap and assign it to the keyboard. */
 	context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
-	keymap = xkb_map_new_from_names(context, &xkb_rules,
+	keymap = xkb_map_new_from_names(context, xkb_rules,
 		XKB_KEYMAP_COMPILE_NO_FLAGS);
 
 	wlr_keyboard_set_keymap(device->keyboard, keymap);
@@ -813,7 +819,7 @@ createmon(struct wl_listener *listener, void *data)
 	/* This event is raised by the backend when a new output (aka a display or
 	 * monitor) becomes available. */
 	struct wlr_output *wlr_output = data;
-	const MonitorRule *r;
+	MonitorRule r;
 	Monitor *m = wlr_output->data = calloc(1, sizeof(*m));
 	m->wlr_output = wlr_output;
 
@@ -821,14 +827,15 @@ createmon(struct wl_listener *listener, void *data)
 	for (size_t i = 0; i < LENGTH(m->layers); i++)
 		wl_list_init(&m->layers[i]);
 	m->tagset[0] = m->tagset[1] = 1;
-	for (r = monrules; r < END(monrules); r++) {
-		if (!r->name || strstr(wlr_output->name, r->name)) {
-			m->mfact = r->mfact;
-			m->nmaster = r->nmaster;
-			wlr_output_set_scale(wlr_output, r->scale);
-			wlr_xcursor_manager_load(cursor_mgr, r->scale);
-			m->lt[0] = m->lt[1] = r->lt;
-			wlr_output_set_transform(wlr_output, r->rr);
+        for (int i = 0; i < nummonrules; i++) {
+                r = monrules[i];
+		if (!r.name || strstr(wlr_output->name, r.name)) {
+			m->mfact = r.mfact;
+			m->nmaster = r.nmaster;
+			wlr_output_set_scale(wlr_output, r.scale);
+			wlr_xcursor_manager_load(cursor_mgr, r.scale);
+			m->lt[0] = m->lt[1] = r.lt;
+			wlr_output_set_transform(wlr_output, r.rr);
 			break;
 		}
 	}
@@ -855,7 +862,7 @@ createmon(struct wl_listener *listener, void *data)
 	 * display, which Wayland clients can see to find out information about the
 	 * output (such as DPI, scale factor, manufacturer, etc).
 	 */
-	wlr_output_layout_add(output_layout, wlr_output, r->x, r->y);
+	wlr_output_layout_add(output_layout, wlr_output, r.x, r.y);
 	sgeom = *wlr_output_layout_get_box(output_layout, NULL);
 
 	/* When adding monitors, the geometries of all monitors must be updated */
@@ -879,8 +886,19 @@ createnotify(struct wl_listener *listener, void *data)
 	struct wlr_xdg_surface *xdg_surface = data;
 	Client *c;
 
-	if (xdg_surface->role != WLR_XDG_SURFACE_ROLE_TOPLEVEL)
+	if (xdg_surface->role != WLR_XDG_SURFACE_ROLE_TOPLEVEL) {
+                c = selclient();
+                if (c) {
+                        struct wlr_box constraint = {
+                                .x = 0,
+                                .y = 0,
+                                .width = c->geom.width,
+                                .height = c->geom.height,
+                        };
+                        wlr_xdg_popup_unconstrain_from_box(xdg_surface->popup, &constraint);
+                }
 		return;
+        }
 
 	/* Allocate a Client for this surface */
 	c = xdg_surface->data = calloc(1, sizeof(*c));
@@ -1052,10 +1070,17 @@ setfullscreen(Client *c, int fullscreen)
 		c->prevheight = c->geom.height;
 		c->prevwidth = c->geom.width;
 		resize(c, c->mon->m.x, c->mon->m.y, c->mon->m.width, c->mon->m.height, 0);
+		wl_list_remove(&c->slink);
+		wl_list_insert(&stack, &c->slink);
+		motionnotify(0);
 	} else {
 		/* restore previous size instead of arrange for floating windows since
 		 * client positions are set by the user and cannot be recalculated */
 		resize(c, c->prevx, c->prevy, c->prevwidth, c->prevheight, 0);
+		if (!c->isfloating) {
+			wl_list_remove(&c->slink);
+			wl_list_insert(stack.prev, &c->slink);
+		}
 		arrange(c->mon);
 	}
 }
@@ -1088,7 +1113,7 @@ focusclient(Client *c, int lift)
 	struct wlr_keyboard *kb;
 
 	/* Raise client in stacking order if requested */
-	if (c && lift) {
+        if (c && lift && (c->isfloating || c->isfullscreen)) {
 		wl_list_remove(&c->slink);
 		wl_list_insert(&stack, &c->slink);
 	}
@@ -1231,7 +1256,7 @@ inputdevice(struct wl_listener *listener, void *data)
 }
 
 int
-keybinding(uint32_t mods, xkb_keysym_t sym)
+keybinding(uint32_t mods, xkb_keycode_t keycode)
 {
 	/*
 	 * Here we handle compositor keybindings. This is when the compositor is
@@ -1239,32 +1264,27 @@ keybinding(uint32_t mods, xkb_keysym_t sym)
 	 * processing.
 	 */
 	int handled = 0;
-	const Key *k;
-	for (k = keys; k < END(keys); k++) {
-		if (CLEANMASK(mods) == CLEANMASK(k->mod) &&
-				sym == k->keysym && k->func) {
-			k->func(&k->arg);
+	Key k;
+        for (int i = 0; i < numkeys; i++) {
+                k = keys[i];
+		if (CLEANMASK(mods) == CLEANMASK(k.mod) &&
+                                keycode == k.keycode && k.func) {
+			dscm_safe_call(DSCM_CALL_ACTION, k.func, NULL);
 			handled = 1;
 		}
-	}
+        }
 	return handled;
 }
 
 void
 keypress(struct wl_listener *listener, void *data)
 {
-	int i;
 	/* This event is raised when a key is pressed or released. */
 	Keyboard *kb = wl_container_of(listener, kb, key);
 	struct wlr_event_keyboard_key *event = data;
 
 	/* Translate libinput keycode -> xkbcommon */
 	uint32_t keycode = event->keycode + 8;
-	/* Get a list of keysyms based on the keymap for this keyboard */
-	const xkb_keysym_t *syms;
-	int nsyms = xkb_state_key_get_syms(
-			kb->device->keyboard->xkb_state, keycode, &syms);
-
 	int handled = 0;
 	uint32_t mods = wlr_keyboard_get_modifiers(kb->device->keyboard);
 
@@ -1272,8 +1292,7 @@ keypress(struct wl_listener *listener, void *data)
 
 	/* On _press_, attempt to process a compositor keybinding. */
 	if (event->state == WL_KEYBOARD_KEY_STATE_PRESSED)
-		for (i = 0; i < nsyms; i++)
-			handled = keybinding(mods, syms[i]) || handled;
+                handled = keybinding(mods, keycode) || handled;
 
 	if (!handled) {
 		/* Pass unhandled keycodes along to the client. */
@@ -1333,7 +1352,6 @@ mapnotify(struct wl_listener *listener, void *data)
 	/* Insert this client into client lists. */
 	wl_list_insert(&clients, &c->link);
 	wl_list_insert(&fstack, &c->flink);
-	wl_list_insert(&stack, &c->slink);
 
 	client_get_geometry(c, &c->geom);
 	c->geom.width += 2 * c->bw;
@@ -1353,6 +1371,13 @@ monocle(Monitor *m)
 			continue;
 		resize(c, m->w.x, m->w.y, m->w.width, m->w.height, 0);
 	}
+
+        /* Lift selected client */
+        c = selclient();
+        if (c) {
+                wl_list_remove(&c->slink);
+                wl_list_insert(&stack, &c->slink);
+        }
 }
 
 void
@@ -1809,6 +1834,16 @@ resize(Client *c, int x, int y, int w, int h, int interact)
 			c->geom.height - 2 * c->bw);
 }
 
+void
+setupsignals() {
+        /* Block real-time signals so that they can be
+         * used as custom user signals. */
+        struct sigaction sa;
+        sa.sa_handler = SIG_IGN;
+        for (int i = SIGRTMIN; i <= SIGRTMAX; i++)
+                sigaction(i, &sa, NULL);
+}
+
 void
 run(char *startup_cmd)
 {
@@ -1818,6 +1853,27 @@ run(char *startup_cmd)
 	const char *socket = wl_display_add_socket_auto(dpy);
 	if (!socket)
 		BARF("startup: display_add_socket_auto");
+        setenv("WAYLAND_DISPLAY", socket, 1);
+
+	if (startup_cmd) {
+		int piperw[2];
+		pipe(piperw);
+		startup_pid = fork();
+		if (startup_pid < 0)
+			EBARF("startup: fork");
+		if (startup_pid == 0) {
+			dup2(piperw[0], STDIN_FILENO);
+			close(piperw[1]);
+			execl("/bin/sh", "/bin/sh", "-c", startup_cmd, NULL);
+			EBARF("startup: execl");
+		}
+		dup2(piperw[1], STDOUT_FILENO);
+		close(piperw[0]);
+	}
+
+	/* If nobody is reading the status output, don't terminate */
+	signal(SIGPIPE, SIG_IGN);
+	printstatus();
 
 	/* Start the backend. This will enumerate outputs and inputs, become the DRM
 	 * master, etc */
@@ -1835,21 +1891,6 @@ run(char *startup_cmd)
 	wlr_cursor_warp_closest(cursor, NULL, cursor->x, cursor->y);
 	wlr_xcursor_manager_set_cursor_image(cursor_mgr, "left_ptr", cursor);
 
-	/* Set the WAYLAND_DISPLAY environment variable to our socket and run the
-	 * startup command if requested. */
-	setenv("WAYLAND_DISPLAY", socket, 1);
-
-	if (startup_cmd) {
-		startup_pid = fork();
-		if (startup_pid < 0)
-			EBARF("startup: fork");
-		if (startup_pid == 0) {
-			dup2(STDERR_FILENO, STDOUT_FILENO);
-			execl("/bin/sh", "/bin/sh", "-c", startup_cmd, NULL);
-			EBARF("startup: execl");
-		}
-	}
-
 	/* Run the Wayland event loop. This does not return until you exit the
 	 * compositor. Starting the backend rigged up all of the necessary event
 	 * loop configuration to listen to libinput events, DRM events, generate
@@ -1902,6 +1943,10 @@ setcursor(struct wl_listener *listener, void *data)
 void
 setfloating(Client *c, int floating)
 {
+	if (c->isfloating != floating) {
+		wl_list_remove(&c->slink);
+		wl_list_insert(floating ? &stack : stack.prev, &c->slink);
+	}
 	c->isfloating = floating;
 	arrange(c->mon);
 }
@@ -1979,16 +2024,41 @@ setsel(struct wl_listener *listener, void *data)
 	wlr_seat_set_selection(seat, event->source, event->serial);
 }
 
+int
+reloadconfig(int signal, void *data) {
+        Client *c;
+        Monitor *m;
+        char *config_file = (char*)data;
+
+        dscm_config_parse(config_file);
+
+        /* Redraw clients */
+        wl_list_for_each(c, &clients, link) {
+                if (c->bw > 0)
+                        c->bw = borderpx;
+                resize(c, c->geom.x, c->geom.y, c->geom.width, c->geom.height, 0);
+        }
+
+        /* Rearrange clients on all monitors */
+        wl_list_for_each(m, &mons, link)
+                arrange(m);
+
+        return 0;
+}
+
 void
-setup(void)
+setup(char *config_file)
 {
 	/* The Wayland display is managed by libwayland. It handles accepting
 	 * clients from the Unix socket, manging Wayland globals, and so on. */
 	dpy = wl_display_create();
 
-	/* clean up child processes immediately */
+	/* Clean up child processes immediately */
 	sigchld(0);
 
+        /* Block user signals so that they can be handled */
+        setupsignals();
+
 	/* The backend is a wlroots feature which abstracts the underlying input and
 	 * output hardware. The autocreate option will choose the most suitable
 	 * backend based on the current environment, such as opening an X11 window
@@ -2109,6 +2179,12 @@ setup(void)
 	wl_signal_add(&output_mgr->events.apply, &output_mgr_apply);
 	wl_signal_add(&output_mgr->events.test, &output_mgr_test);
 
+        struct wl_event_loop *loop = wl_display_get_event_loop(dpy);
+
+        /* Add handlers for user signals */
+        /* TODO: Add config option for adding custom handlers to signal. */
+        wl_event_loop_add_signal(loop, SIGRTMIN, &reloadconfig, config_file);
+
 #ifdef XWAYLAND
 	/*
 	 * Initialise the XWayland X server.
@@ -2561,11 +2637,14 @@ int
 main(int argc, char *argv[])
 {
 	char *startup_cmd = NULL;
+	char *config_file = NULL;
 	int c;
 
-	while ((c = getopt(argc, argv, "s:h")) != -1) {
+	while ((c = getopt(argc, argv, "s:c:h")) != -1) {
 		if (c == 's')
 			startup_cmd = optarg;
+                else if (c == 'c')
+                        config_file = optarg;
 		else
 			goto usage;
 	}
@@ -2576,11 +2655,16 @@ main(int argc, char *argv[])
 	// socket
 	if (!getenv("XDG_RUNTIME_DIR"))
 		BARF("XDG_RUNTIME_DIR must be set");
-	setup();
+        if (!config_file)
+                BARF("error: config path must be set using '-c'");
+        scm_init_guile();
+        dscm_register();
+        dscm_config_parse(config_file);
+	setup(config_file);
 	run(startup_cmd);
+        dscm_config_cleanup();
 	cleanup();
 	return EXIT_SUCCESS;
-
 usage:
-	BARF("Usage: %s [-s startup command]", argv[0]);
+	BARF("Usage: %s [-c path to config.scm] [-s startup command]", argv[0]);
 }
diff --git a/guix.scm b/guix.scm
new file mode 100644
index 0000000..63cb2e7
--- /dev/null
+++ b/guix.scm
@@ -0,0 +1,38 @@
+(use-modules (dwl-guile packages)
+             (guix gexp)
+             (guix utils)
+             (guix packages)
+             (guix git-download)
+             (gnu packages wm)
+             (gnu packages guile))
+
+(define this-directory
+  (dirname (current-filename)))
+
+(define source
+  (local-file this-directory
+              #:recursive? #t
+              #:select? (git-predicate this-directory)))
+
+(package
+  (inherit dwl)
+  (source source)
+  (name "dwl-guile-devel")
+  (inputs
+    `(("guile-3.0" ,guile-3.0)
+      ("wlroots-0.13.0" ,wlroots-0.13.0)))
+  (arguments
+    (substitute-keyword-arguments
+      (package-arguments dwl)
+      ((#:phases phases)
+       `(modify-phases
+          ,phases
+            (replace
+              'install
+              (lambda*
+                (#:key inputs outputs #:allow-other-keys)
+                (let ((bin (string-append (assoc-ref outputs "out") "/bin")))
+                  (install-file "dwl" bin)
+                  (rename-file (string-append bin "/dwl")
+                               (string-append bin "/dwl-guile-devel"))
+                  #t))))))))
diff --git a/scripts/create-patches.sh b/scripts/create-patches.sh
new file mode 100755
index 0000000..12426c8
--- /dev/null
+++ b/scripts/create-patches.sh
@@ -0,0 +1,25 @@
+#!/bin/sh
+# $1 = dwl-guile patch tag to diff patches to
+
+git fetch --all
+rm -rf patches
+mkdir -p patches
+
+# Make sure we always have a branch/tag to diff against,
+# otherwise, the patch output will be inverted.
+DIFF_ORIGIN=$1
+[ -z $DIFF_ORIGIN ] && DIFF_ORIGIN="main"
+
+for patch in xwayland alpha smartborders attachabove \
+    vanitygaps monitor-config focusmonpointer
+do
+    git fetch origin patch/$patch
+    git diff $DIFF_ORIGIN patch/$patch \
+        ':(exclude)README.md' \
+        ':(exclude)patches' \
+        ':(exclude)scripts/create-patches.sh' \
+        ':(exclude).gitignore' > patches/$patch.patch
+done
+
+# Create dwl-guile patch based on dwl v0.2.1
+git diff v0.2.1 > patches/dwl-guile.patch
