diff --git a/.gitignore b/.gitignore
index 0dde90e..b261fc3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,3 +4,7 @@ dwl
 *-protocol.h
 .ccls-cache
 config.h
+config.scm
+dwl.log
+*.patch
+patches
diff --git a/Makefile b/Makefile
index a0d1cc3..99d36a0 100644
--- a/Makefile
+++ b/Makefile
@@ -1,16 +1,27 @@
 include config.mk
 
-CFLAGS += -I. -DWLR_USE_UNSTABLE -std=c99
+CFLAGS += -I. -DWLR_USE_UNSTABLE -std=c99 -Wno-declaration-after-statement
 
 WAYLAND_PROTOCOLS=$(shell pkg-config --variable=pkgdatadir wayland-protocols)
 WAYLAND_SCANNER=$(shell pkg-config --variable=wayland_scanner wayland-scanner)
 
-PKGS = wlroots wayland-server xcb xkbcommon libinput
-CFLAGS += $(foreach p,$(PKGS),$(shell pkg-config --cflags $(p)))
+PKGS = wlroots wayland-server xcb xkbcommon libinput guile-3.0 pixman-1
+CFLAGS += $(foreach p,$(PKGS),$(shell pkg-config --cflags $(p))) -DWLR_USE_UNSTABLE -Wno-error=implicit-function-declaration
 LDLIBS += $(foreach p,$(PKGS),$(shell pkg-config --libs $(p)))
 
 all: dwl
 
+clean:
+	rm -f dwl *.o *-protocol.h *-protocol.c
+
+install: dwl
+	install -D dwl $(PREFIX)/bin/dwl
+
+uninstall:
+	rm -f $(PREFIX)/bin/dwl
+
+.PHONY: all clean install uninstall
+
 # wayland-scanner is a tool which generates C headers and rigging for Wayland
 # protocols, which are specified in XML. wlroots requires you to rig these up
 # to your build system yourself and provide them in the include path.
@@ -44,18 +55,16 @@ idle-protocol.c:
 
 idle-protocol.o: idle-protocol.h
 
-config.h: | config.def.h
-	cp config.def.h $@
+dscm-unstable-v1-protocol.h:
+	$(WAYLAND_SCANNER) server-header \
+		protocols/dscm-unstable-v1.xml $@
 
-dwl.o: config.h client.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h idle-protocol.h
+dscm-unstable-v1-protocol.c:
+	$(WAYLAND_SCANNER) private-code \
+		protocols/dscm-unstable-v1.xml $@
 
-dwl: xdg-shell-protocol.o wlr-layer-shell-unstable-v1-protocol.o idle-protocol.o
+dscm-unstable-v1-protocol.o: dscm-unstable-v1-protocol.h
 
-clean:
-	rm -f dwl *.o *-protocol.h *-protocol.c
-
-install: dwl
-	install -D dwl $(PREFIX)/bin/dwl
+dwl.o: dscm-utils.h dscm-bindings.h dscm-config.h client.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h idle-protocol.h dscm-unstable-v1-protocol.h
 
-.DEFAULT_GOAL=dwl
-.PHONY: clean
+dwl: xdg-shell-protocol.o wlr-layer-shell-unstable-v1-protocol.o idle-protocol.o dscm-unstable-v1-protocol.o
diff --git a/README.md b/README.md
index 22dfa07..43346d1 100644
--- a/README.md
+++ b/README.md
@@ -1,77 +1,4 @@
-# dwl - dwm for Wayland
-
-Join us on our [Discord server](https://discord.gg/jJxZnrGPWN)!
-
-dwl is a compact, hackable compositor for Wayland based on [wlroots](https://github.com/swaywm/wlroots). It is intended to fill the same space in the Wayland world that dwm does in X11, primarily in terms of philosophy, and secondarily in terms of functionality. Like dwm, dwl is:
-
-- Easy to understand, hack on, and extend with patches
-- One C source file (or a very small number) configurable via `config.h`
-- Limited to 2000 SLOC to promote hackability
-- Tied to as few external dependencies as possible
-
-dwl is not meant to provide every feature under the sun. Instead, like dwm, it sticks to features which are necessary, simple, and straightforward to implement given the base on which it is built. Implemented default features are:
-
-- Any features provided by dwm/Xlib: simple window borders, tags, keybindings, client rules, mouse move/resize. Providing a built-in status bar is an exception to this goal, to avoid dependencies on font rendering and/or drawing libraries when an external bar could work well.
-- Configurable multi-monitor layout support, including position and rotation
-- Configurable HiDPI/multi-DPI support
-- Various Wayland protocols
-- XWayland support as provided by wlroots
-- Zero flickering - Wayland users naturally expect that "every frame is perfect"
-
-Features under consideration (possibly as patches) are:
-
-- Protocols made trivial by wlroots
-- Provide information to external status bars via stdout or another file descriptor
-- Implement the input-inhibitor protocol to support screen lockers
-- Implement the idle-inhibit protocol which lets applications such as mpv disable idle monitoring
-- Layer shell popups (used by Waybar)
-- Basic yes/no damage tracking to avoid needless redraws
-- More in-depth damage region tracking ([which may improve power usage](https://mozillagfx.wordpress.com/2019/10/22/dramatically-reduced-power-usage-in-firefox-70-on-macos-with-core-animation/))
-- Implement the text-input and input-method protocols to support IME once ibus implements input-method v2 (see https://github.com/ibus/ibus/pull/2256 and https://github.com/djpohly/dwl/pull/12)
-- Implement urgent/attention/focus-request once it's part of the xdg-shell protocol (https://gitlab.freedesktop.org/wayland/wayland-protocols/-/merge_requests/9)
-
-Feature *non-goals* include:
-
-- Client-side decoration (any more than is necessary to tell the clients not to)
-- Client-initiated window management, such as move, resize, and close, which can be done through the compositor
-
-## Building dwl
-
-dwl has only two dependencies: wlroots 0.13 and wayland-protocols. Simply install these and run `make`.  If you wish to build against a Git version of wlroots, check out the [wlroots-next branch](https://github.com/djpohly/dwl/tree/wlroots-next).
-
-To enable XWayland, you should also install xorg-xwayland and uncomment its flag in `config.mk`.
-
-## Configuration
-
-All configuration is done by editing `config.h` and recompiling, in the same manner as dwm. There is no way to separately restart the window manager in Wayland without restarting the entire display server, so any changes will take effect the next time dwl is executed.
-
-As in the dwm community, we encourage users to share patches they have created.  Check out the [patches page on our wiki](https://github.com/djpohly/dwl/wiki/Patches)!
-
-## Running dwl
-
-dwl can be run as-is, with no arguments. In an existing Wayland or X11 session, this will open a window to act as a virtual display. When run from a TTY, the Wayland server will take over the entire virtual terminal. Clients started by dwl will have `WAYLAND_DISPLAY` set in their environment, and other clients can be started from outside the session by setting this variable accordingly.
-
-You can also specify a startup program using the `-s` option. The argument to this option will be run at startup as a shell command (using `sh -c`) and can serve a similar function to `.xinitrc`: starting a service manager or other startup applications. Unlike `.xinitrc`, the display server will not shut down when this process terminates. Instead, as dwl is shutting down, it will send this process a SIGTERM and wait for it to terminate (if it hasn't already). This makes it ideal not only for initialization but also for execing into a user-level service manager like s6 or `systemd --user`.
-
-Note: Wayland requires a valid `XDG_RUNTIME_DIR`, which is usually set up by a session manager such as `elogind` or `systemd-logind`.  If your system doesn't do this automatically, you will need to configure it prior to launching `dwl`, e.g.:
-
-    export XDG_RUNTIME_DIR=/tmp/xdg-runtime-$(id -u)
-    mkdir -p $XDG_RUNTIME_DIR
-
-## Replacements for X applications
-
-You can find a [list of Wayland applications on the sway wiki](https://github.com/swaywm/sway/wiki/i3-Migration-Guide).
-
-## IRC channel
-
-dwl's IRC channel is #dwl on irc.freenode.net.
-
-## Acknowledgements
-
-dwl began by extending the TinyWL example provided (CC0) by the sway/wlroots developers. This was made possible in many cases by looking at how sway accomplished something, then trying to do the same in as suckless a way as possible.
-
-Many thanks to suckless.org and the dwm developers and community for the inspiration, and to the various contributors to the project, including:
-
-- Alexander Courtis for the XWayland implementation
-- Guido Cella for the layer-shell protocol implementation, patch maintenance, and for helping to keep the project running
-- Stivvo for output management and fullscreen support, and patch maintenance
+# dwl-guile
+dwl-guile is a patch to dwl that adds dynamic configuration using Guile. It
+integrates with GNU Guix as a home service (see
+[home-service-dwl-guile](https://github.com/engstrand-config/home-service-dwl-guile)).
diff --git a/client.h b/client.h
index f4735c2..56e3089 100644
--- a/client.h
+++ b/client.h
@@ -141,6 +141,17 @@ client_set_size(Client *c, uint32_t width, uint32_t height)
 	return wlr_xdg_toplevel_set_size(c->surface.xdg, width, height);
 }
 
+static inline void
+client_set_tiled(Client *c, uint32_t edges)
+{
+#ifdef XWAYLAND
+	if (client_is_x11(c))
+		return;
+#endif
+	wlr_xdg_toplevel_set_tiled(c->surface.xdg, WLR_EDGE_TOP |
+			WLR_EDGE_BOTTOM | WLR_EDGE_LEFT | WLR_EDGE_RIGHT);
+}
+
 static inline struct wlr_surface *
 client_surface(Client *c)
 {
diff --git a/config.def.h b/config.def.h
deleted file mode 100644
index 089aa37..0000000
--- a/config.def.h
+++ /dev/null
@@ -1,116 +0,0 @@
-/* appearance */
-static const int sloppyfocus        = 1;  /* focus follows mouse */
-static const unsigned int borderpx  = 1;  /* border pixel of windows */
-static const float rootcolor[]      = {0.3, 0.3, 0.3, 1.0};
-static const float bordercolor[]    = {0.5, 0.5, 0.5, 1.0};
-static const float focuscolor[]     = {1.0, 0.0, 0.0, 1.0};
-
-/* tagging */
-static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
-
-static const Rule rules[] = {
-	/* app_id     title       tags mask     isfloating   monitor */
-	/* examples:
-	{ "Gimp",     NULL,       0,            1,           -1 },
-	{ "firefox",  NULL,       1 << 8,       0,           -1 },
-	*/
-};
-
-/* layout(s) */
-static const Layout layouts[] = {
-	/* symbol     arrange function */
-	{ "[]=",      tile },
-	{ "><>",      NULL },    /* no layout function means floating behavior */
-	{ "[M]",      monocle },
-};
-
-/* monitors
- * The order in which monitors are defined determines their position.
- * Non-configured monitors are always added to the left. */
-static const MonitorRule monrules[] = {
-	/* name       mfact nmaster scale layout       rotate/reflect x y */
-	/* example of a HiDPI laptop monitor:
-	{ "eDP-1",    0.5,  1,      2,    &layouts[0], WL_OUTPUT_TRANSFORM_NORMAL, 0, 0 },
-	*/
-	/* defaults */
-	{ NULL,       0.55, 1,      1,    &layouts[0], WL_OUTPUT_TRANSFORM_NORMAL, 0, 0 },
-};
-
-/* keyboard */
-static const struct xkb_rule_names xkb_rules = {
-	/* can specify fields: rules, model, layout, variant, options */
-	/* example:
-	.options = "ctrl:nocaps",
-	*/
-};
-
-static const int repeat_rate = 25;
-static const int repeat_delay = 600;
-
-/* Trackpad */
-static const int tap_to_click = 1;
-static const int natural_scrolling = 0;
-
-#define MODKEY WLR_MODIFIER_ALT
-#define TAGKEYS(KEY,SKEY,TAG) \
-	{ MODKEY,                    KEY,            view,            {.ui = 1 << TAG} }, \
-	{ MODKEY|WLR_MODIFIER_CTRL,  KEY,            toggleview,      {.ui = 1 << TAG} }, \
-	{ MODKEY|WLR_MODIFIER_SHIFT, SKEY,           tag,             {.ui = 1 << TAG} }, \
-	{ MODKEY|WLR_MODIFIER_CTRL|WLR_MODIFIER_SHIFT,SKEY,toggletag, {.ui = 1 << TAG} }
-
-/* helper for spawning shell commands in the pre dwm-5.0 fashion */
-#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
-
-/* commands */
-static const char *termcmd[] = { "alacritty", NULL };
-static const char *menucmd[] = { "bemenu-run", NULL };
-
-static const Key keys[] = {
-	/* Note that Shift changes certain key codes: c -> C, 2 -> at, etc. */
-	/* modifier                  key                 function        argument */
-	{ MODKEY,                    XKB_KEY_p,          spawn,          {.v = menucmd} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Return,     spawn,          {.v = termcmd} },
-	{ MODKEY,                    XKB_KEY_j,          focusstack,     {.i = +1} },
-	{ MODKEY,                    XKB_KEY_k,          focusstack,     {.i = -1} },
-	{ MODKEY,                    XKB_KEY_i,          incnmaster,     {.i = +1} },
-	{ MODKEY,                    XKB_KEY_d,          incnmaster,     {.i = -1} },
-	{ MODKEY,                    XKB_KEY_h,          setmfact,       {.f = -0.05} },
-	{ MODKEY,                    XKB_KEY_l,          setmfact,       {.f = +0.05} },
-	{ MODKEY,                    XKB_KEY_Return,     zoom,           {0} },
-	{ MODKEY,                    XKB_KEY_Tab,        view,           {0} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_C,          killclient,     {0} },
-	{ MODKEY,                    XKB_KEY_t,          setlayout,      {.v = &layouts[0]} },
-	{ MODKEY,                    XKB_KEY_f,          setlayout,      {.v = &layouts[1]} },
-	{ MODKEY,                    XKB_KEY_m,          setlayout,      {.v = &layouts[2]} },
-	{ MODKEY,                    XKB_KEY_space,      setlayout,      {0} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_space,      togglefloating, {0} },
-	{ MODKEY, 					 XKB_KEY_e,    		togglefullscreen, {0} },
-	{ MODKEY,                    XKB_KEY_0,          view,           {.ui = ~0} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_parenright, tag,            {.ui = ~0} },
-	{ MODKEY,                    XKB_KEY_comma,      focusmon,       {.i = WLR_DIRECTION_LEFT} },
-	{ MODKEY,                    XKB_KEY_period,     focusmon,       {.i = WLR_DIRECTION_RIGHT} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_less,       tagmon,         {.i = WLR_DIRECTION_LEFT} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_greater,    tagmon,         {.i = WLR_DIRECTION_RIGHT} },
-	TAGKEYS(          XKB_KEY_1, XKB_KEY_exclam,                     0),
-	TAGKEYS(          XKB_KEY_2, XKB_KEY_at,                         1),
-	TAGKEYS(          XKB_KEY_3, XKB_KEY_numbersign,                 2),
-	TAGKEYS(          XKB_KEY_4, XKB_KEY_dollar,                     3),
-	TAGKEYS(          XKB_KEY_5, XKB_KEY_percent,                    4),
-	TAGKEYS(          XKB_KEY_6, XKB_KEY_caret,                      5),
-	TAGKEYS(          XKB_KEY_7, XKB_KEY_ampersand,                  6),
-	TAGKEYS(          XKB_KEY_8, XKB_KEY_asterisk,                   7),
-	TAGKEYS(          XKB_KEY_9, XKB_KEY_parenleft,                  8),
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Q,          quit,           {0} },
-
-	/* Ctrl-Alt-Backspace and Ctrl-Alt-Fx used to be handled by X server */
-	{ WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_Terminate_Server, quit, {0} },
-#define CHVT(n) { WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_XF86Switch_VT_##n, chvt, {.ui = (n)} }
-	CHVT(1), CHVT(2), CHVT(3), CHVT(4), CHVT(5), CHVT(6),
-	CHVT(7), CHVT(8), CHVT(9), CHVT(10), CHVT(11), CHVT(12),
-};
-
-static const Button buttons[] = {
-	{ MODKEY, BTN_LEFT,   moveresize,     {.ui = CurMove} },
-	{ MODKEY, BTN_MIDDLE, togglefloating, {0} },
-	{ MODKEY, BTN_RIGHT,  moveresize,     {.ui = CurResize} },
-};
diff --git a/dscm-bindings.h b/dscm-bindings.h
new file mode 100644
index 0000000..3bc0379
--- /dev/null
+++ b/dscm-bindings.h
@@ -0,0 +1,374 @@
+static inline SCM
+dscm_binding_monocle(SCM monitor)
+{
+        Monitor *m = (Monitor*)scm_to_pointer(monitor);
+        monocle(m);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_tile(SCM monitor)
+{
+        Monitor *m = (Monitor*)scm_to_pointer(monitor);
+        tile(m);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_spawn(SCM args)
+{
+        if (scm_is_null(args))
+                return SCM_BOOL_F;
+        unsigned int i = 0, length = dscm_get_list_length(args);
+        char *cmd_args[length + 1];
+        for (; i < length; i++) {
+                SCM arg_exp = dscm_get_list_item(args, i);
+                char *arg = scm_to_locale_string(arg_exp);
+                cmd_args[i] = arg;
+        }
+        cmd_args[i] = NULL;
+        Arg a = {.v = cmd_args};
+        spawn(&a);
+        for (char **iter = cmd_args; *iter != NULL; iter++)
+                free(*iter);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_shcmd(SCM args)
+{
+        SCM extended = scm_list_3(scm_from_utf8_string("/bin/sh"),
+                scm_from_utf8_string("-c"), args);
+        return dscm_binding_spawn(extended);
+}
+
+static inline SCM
+dscm_binding_spawn_menu()
+{
+        Arg a = {.v = menucmd};
+        spawn(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_spawn_terminal()
+{
+        Arg a = {.v = termcmd};
+        spawn(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_focusstack(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        focusstack(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_setmfact(SCM value)
+{
+        Arg a = {.f = scm_to_double(value)};
+        setmfact(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_togglefloating()
+{
+        togglefloating(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_zoom()
+{
+        zoom(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_setlayout(SCM value)
+{
+        char *id = scm_to_locale_string(value);
+        Layout *layout = NULL;
+        for (int i = 0; i < numlayouts; i++) {
+                if (strcmp(layouts[i].id, id) == 0)
+                        layout = &layouts[i];
+        }
+        if (layout == NULL)
+                return SCM_BOOL_F;
+        Arg a = {.v = layout};
+        setlayout(&a);
+        free(id);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_togglefullscreen()
+{
+        togglefullscreen(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_focusmon(SCM value)
+{
+        SCM eval = scm_primitive_eval(value);
+        Arg a = {.i = scm_to_int(eval)};
+        focusmon(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_tagmon(SCM value)
+{
+        SCM eval = scm_primitive_eval(value);
+        Arg a = {.i = scm_to_int(eval)};
+        tagmon(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_chvt(SCM tty)
+{
+        if (!scm_is_number(tty))
+                return SCM_BOOL_F;
+        int target_tty = scm_to_int(tty);
+        if (target_tty <= 0 || target_tty > 12)
+                return SCM_BOOL_F;
+        Arg a = {.ui = (unsigned int)target_tty};
+        chvt(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_changealpha(SCM value)
+{
+        Arg a = {.f = scm_to_double(value)};
+        changealpha(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_view(SCM value)
+{
+        Arg a = {.ui = dscm_get_tag(value, numtags)};
+        view(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_viewprev(SCM value)
+{
+        viewprev(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_toggleview(SCM value)
+{
+        Arg a = {.ui = dscm_get_tag(value, numtags)};
+        toggleview(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_tag(SCM value)
+{
+        Arg a = {.ui = dscm_get_tag(value, numtags)};
+        tag(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_cyclelayout(SCM direction)
+{
+        Arg a = {.i = 1};
+        if (scm_is_number(direction))
+                a.i = scm_to_int(direction);
+        cyclelayout(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incnmaster(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incnmaster(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_toggletag(SCM value)
+{
+        Arg a = {.ui = dscm_get_tag(value, numtags)};
+        toggletag(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_moveresize(SCM cursor)
+{
+        Arg a = {.ui = scm_to_unsigned_integer(cursor, 0, CurResize)};
+        moveresize(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_killclient()
+{
+        killclient(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_quit()
+{
+        quit(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incrgaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrgaps(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incrigaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrigaps(&a);
+        return SCM_BOOL_T;
+}
+static inline SCM
+dscm_binding_incrogaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrogaps(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incrohgaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrohgaps(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incrovgaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrovgaps(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incrihgaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrihgaps(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incrivgaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrivgaps(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_togglegaps()
+{
+        togglegaps(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_defaultgaps()
+{
+        defaultgaps(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline void
+dscm_register()
+{
+        scm_c_define("SHIFT", scm_from_int(WLR_MODIFIER_SHIFT));
+        scm_c_define("CAPS", scm_from_int(WLR_MODIFIER_CAPS));
+        scm_c_define("CTRL", scm_from_int(WLR_MODIFIER_CTRL));
+        scm_c_define("ALT", scm_from_int(WLR_MODIFIER_ALT));
+        scm_c_define("MOD2", scm_from_int(WLR_MODIFIER_MOD2));
+        scm_c_define("MOD3", scm_from_int(WLR_MODIFIER_MOD3));
+        scm_c_define("SUPER", scm_from_int(WLR_MODIFIER_LOGO));
+        scm_c_define("MOD5", scm_from_int(WLR_MODIFIER_MOD5));
+        /* TODO: add bindings for other mouse buttons */
+        scm_c_define("DIRECTION-LEFT", scm_from_int(WLR_DIRECTION_LEFT));
+        scm_c_define("DIRECTION-RIGHT", scm_from_int(WLR_DIRECTION_RIGHT));
+        scm_c_define("MOUSE-LEFT", scm_from_int(BTN_LEFT));
+        scm_c_define("MOUSE-MIDDLE", scm_from_int(BTN_MIDDLE));
+        scm_c_define("MOUSE-RIGHT", scm_from_int(BTN_RIGHT));
+        scm_c_define("CURSOR-NORMAL", scm_from_int(CurNormal));
+        scm_c_define("CURSOR-MOVE", scm_from_int(CurMove));
+        scm_c_define("CURSOR-RESIZE", scm_from_int(CurResize));
+        scm_c_define("TRANSFORM-NORMAL",
+                scm_from_int(WL_OUTPUT_TRANSFORM_NORMAL));
+        scm_c_define("TRANSFORM-ROTATE-90",
+                scm_from_int(WL_OUTPUT_TRANSFORM_90));
+        scm_c_define("TRANSFORM-ROTATE-180",
+                scm_from_int(WL_OUTPUT_TRANSFORM_180));
+        scm_c_define("TRANSFORM-ROTATE-270",
+                scm_from_int(WL_OUTPUT_TRANSFORM_270));
+        scm_c_define("TRANSFORM-FLIPPED",
+                scm_from_int(WL_OUTPUT_TRANSFORM_FLIPPED));
+        scm_c_define("TRANSFORM-FLIPPED-90",
+                scm_from_int(WL_OUTPUT_TRANSFORM_FLIPPED_90));
+        scm_c_define("TRANSFORM-FLIPPED-180",
+                scm_from_int(WL_OUTPUT_TRANSFORM_FLIPPED_180));
+        scm_c_define("TRANSFORM-FLIPPED-270",
+                scm_from_int(WL_OUTPUT_TRANSFORM_FLIPPED_270));
+
+        scm_c_define_gsubr("dwl:chvt", 1, 0, 0, &dscm_binding_chvt);
+        scm_c_define_gsubr("dwl:quit", 0, 0, 0, &dscm_binding_quit);
+        scm_c_define_gsubr("dwl:killclient", 0, 0, 0, &dscm_binding_killclient);
+        scm_c_define_gsubr("dwl:tile", 1, 0, 0, &dscm_binding_tile);
+        scm_c_define_gsubr("dwl:monocle", 1, 0, 0, &dscm_binding_monocle);
+        scm_c_define_gsubr("dwl:spawn", 0, 0, 1, &dscm_binding_spawn);
+        scm_c_define_gsubr("dwl:view", 1, 0, 0, &dscm_binding_view);
+        scm_c_define_gsubr("dwl:view-previous", 0, 0, 0, &dscm_binding_viewprev);
+        scm_c_define_gsubr("dwl:toggle-view", 1, 0, 0, &dscm_binding_toggleview);
+        scm_c_define_gsubr("dwl:tag", 1, 0, 0, &dscm_binding_tag);
+        scm_c_define_gsubr("dwl:cycle-layout", 0, 1, 0, &dscm_binding_cyclelayout);
+        scm_c_define_gsubr("dwl:toggle-tag", 1, 0, 0, &dscm_binding_toggletag);
+        scm_c_define_gsubr("dwl:focus-stack", 1, 0, 0, &dscm_binding_focusstack);
+        scm_c_define_gsubr("dwl:set-master-factor", 1, 0, 0, &dscm_binding_setmfact);
+        scm_c_define_gsubr("dwl:zoom", 0, 0, 0, &dscm_binding_zoom);
+        scm_c_define_gsubr("dwl:set-layout", 1, 0, 0, &dscm_binding_setlayout);
+        scm_c_define_gsubr("dwl:toggle-fullscreen", 0, 0, 0, &dscm_binding_togglefullscreen);
+        scm_c_define_gsubr("dwl:toggle-floating", 0, 0, 0, &dscm_binding_togglefloating);
+        scm_c_define_gsubr("dwl:focus-monitor", 1, 0, 0, &dscm_binding_focusmon);
+        scm_c_define_gsubr("dwl:tag-monitor", 1, 0, 0, &dscm_binding_tagmon);
+        scm_c_define_gsubr("dwl:move-resize", 1, 0, 0, &dscm_binding_moveresize);
+        scm_c_define_gsubr("dwl:set-masters", 1, 0, 0, &dscm_binding_incnmaster);
+        scm_c_define_gsubr("dwl:shcmd", 1, 0, 0, &dscm_binding_shcmd);
+        scm_c_define_gsubr("dwl:change-alpha", 1, 0, 0, &dscm_binding_changealpha);
+        scm_c_define_gsubr("dwl:spawn-menu", 0, 0, 0, &dscm_binding_spawn_menu);
+        scm_c_define_gsubr("dwl:spawn-terminal", 0, 0, 0, &dscm_binding_spawn_terminal);
+        scm_c_define_gsubr("dwl:toggle-gaps", 0, 0, 0, &dscm_binding_togglegaps);
+        scm_c_define_gsubr("dwl:default-gaps", 0, 0, 0, &dscm_binding_defaultgaps);
+        scm_c_define_gsubr("dwl:gaps", 1, 0, 0, &dscm_binding_incrgaps);
+        scm_c_define_gsubr("dwl:gaps-inner", 1, 0, 0, &dscm_binding_incrigaps);
+        scm_c_define_gsubr("dwl:gaps-outer", 1, 0, 0, &dscm_binding_incrogaps);
+        scm_c_define_gsubr("dwl:gaps-inner-horizontal", 1, 0, 0, &dscm_binding_incrihgaps);
+        scm_c_define_gsubr("dwl:gaps-inner-vertical", 1, 0, 0, &dscm_binding_incrivgaps);
+        scm_c_define_gsubr("dwl:gaps-outer-horizontal", 1, 0, 0, &dscm_binding_incrohgaps);
+        scm_c_define_gsubr("dwl:gaps-outer-vertical", 1, 0, 0, &dscm_binding_incrovgaps);
+}
diff --git a/dscm-config.h b/dscm-config.h
new file mode 100644
index 0000000..e71ea55
--- /dev/null
+++ b/dscm-config.h
@@ -0,0 +1,215 @@
+#pragma once
+
+SCM config;
+
+/* Config variable definitions. */
+/* These will be automatically set from the guile config. */
+static int repeat_rate          = 25;
+static int repeat_delay         = 600;
+static int sloppyfocus          = 1;
+static int tap_to_click         = 1;
+static int natural_scrolling    = 1;
+static unsigned int borderpx    = 1;
+static double default_alpha     = 1.0;
+static unsigned int gappih      = 0;
+static unsigned int gappiv      = 0;
+static unsigned int gappoh      = 0;
+static unsigned int gappov      = 0;
+static int smartgaps            = 0;
+static int smartborders         = 0;
+static float *rootcolor         = NULL;
+static float *bordercolor       = NULL;
+static float *focuscolor        = NULL;
+static float *textcolor         = NULL;
+static char **tags              = NULL;
+static char **termcmd           = NULL;
+static char **menucmd           = NULL;
+static Layout *layouts          = NULL;
+static MonitorRule *monrules    = NULL;
+static Rule *rules              = NULL;
+static Key *keys                = NULL;
+static Button *buttons          = NULL;
+static struct xkb_rule_names *xkb_rules = NULL;
+
+static unsigned int numtags     = 0;
+static unsigned int numkeys     = 0;
+static unsigned int numrules    = 0;
+static unsigned int numlayouts  = 0;
+static unsigned int nummonrules = 0;
+static unsigned int numbuttons  = 0;
+static unsigned int TAGMASK     = 0;
+
+static inline void
+dscm_parse_color(unsigned int index, SCM value, void *data)
+{
+        ((float*)data)[index] = (float)scm_to_double(value);
+}
+
+static inline void
+dscm_parse_string(unsigned int index, SCM str, void *data)
+{
+        ((char**)data)[index] = scm_to_locale_string(str);
+}
+
+static inline void
+dscm_parse_layout(unsigned int index, SCM layout, void *data)
+{
+        ((Layout*)data)[index] = (Layout){
+                .id = dscm_alist_get_string(layout, "id"),
+                .symbol = dscm_alist_get_string(layout, "symbol"),
+                .arrange = dscm_alist_get_proc_pointer(layout, "arrange")
+        };
+}
+
+static inline void
+dscm_parse_monitor_rule(unsigned int index, SCM rule, void *data)
+{
+        SCM transform = dscm_alist_get(rule, "transform");
+        SCM eval = scm_primitive_eval(transform);
+        ((MonitorRule*)data)[index] = (MonitorRule){
+                .name = dscm_alist_get_string(rule, "name"),
+                .mfact = dscm_alist_get_float(rule, "master-factor"),
+                .nmaster = dscm_alist_get_int(rule, "masters"),
+                .scale = dscm_alist_get_float(rule, "scale"),
+                .lt = &layouts[dscm_alist_get_int(rule, "layout")],
+                .rr = (enum wl_output_transform)scm_to_int(eval),
+                .x = dscm_alist_get_int(rule, "x"),
+                .y = dscm_alist_get_int(rule, "y"),
+        };
+}
+
+static inline void
+dscm_parse_rule(unsigned int index, SCM rule, void *data)
+{
+         ((Rule*)data)[index] = (Rule){
+                .id = dscm_alist_get_string(rule, "id"),
+                .title = dscm_alist_get_string(rule, "title"),
+                .tags = dscm_alist_get_unsigned_int(rule, "tag", -1),
+                .isfloating = dscm_alist_get_int(rule, "floating"),
+                .monitor = dscm_alist_get_int(rule, "monitor"),
+                .alpha = dscm_alist_get_double(rule, "alpha")
+         };
+}
+
+static inline void
+dscm_parse_key(unsigned int index, SCM key, void *data)
+{
+        xkb_keycode_t keycode = dscm_alist_get_unsigned_int(key, "key", -1);
+        /* Should we use `xkb_keycode_is_legal_x11`? */
+        if (!xkb_keycode_is_legal_x11(keycode)
+                || !xkb_keycode_is_legal_ext(keycode))
+                BARF("dscm: keycode '%d' is not a legal keycode\n", keycode);
+        ((Key*)data)[index] = (Key){
+                .mod = dscm_alist_get_modifiers(key, "modifiers"),
+                .keycode = keycode,
+                .func = dscm_alist_get_proc_pointer(key, "action")
+        };
+}
+
+static inline void
+dscm_parse_button(unsigned int index, SCM button, void *data)
+{
+        SCM symbol = dscm_alist_get(button, "button");
+        SCM eval = scm_primitive_eval(symbol);
+        ((Button*)data)[index] = (Button){
+                .mod = (unsigned int)dscm_alist_get_modifiers(button, "modifiers"),
+                .button = scm_to_unsigned_integer(eval, 0, -1),
+                .func = dscm_alist_get_proc_pointer(button, "action")
+        };
+}
+
+static inline struct xkb_rule_names *
+dscm_parse_xkb_rules(SCM config)
+{
+        SCM xkb = dscm_alist_get(config, "xkb-rules");
+        struct xkb_rule_names *dest = calloc(1, sizeof(struct xkb_rule_names));
+        *dest = (struct xkb_rule_names){
+                .rules = dscm_alist_get_string(xkb, "rules"),
+                .model = dscm_alist_get_string(xkb, "model"),
+                .layout = dscm_alist_get_string(xkb, "layouts"),
+                .variant = dscm_alist_get_string(xkb, "variants"),
+                .options = dscm_alist_get_string(xkb, "options"),
+        };
+        return dest;
+}
+
+static inline void
+dscm_config_parse(char *config_file)
+{
+        scm_c_primitive_load(config_file);
+        config = dscm_get_variable("config");
+
+        sloppyfocus = dscm_alist_get_int(config, "sloppy-focus");
+        tap_to_click = dscm_alist_get_int(config, "tap-to-click");
+        natural_scrolling = dscm_alist_get_int(config, "natural-scrolling");
+        borderpx = dscm_alist_get_unsigned_int(config, "border-px", 25);
+        repeat_rate = dscm_alist_get_unsigned_int(config, "repeat-rate", 5000);
+        repeat_delay = dscm_alist_get_unsigned_int(config, "repeat-delay", 5000);
+        default_alpha = dscm_alist_get_double(config, "default-alpha");
+        gappih = dscm_alist_get_unsigned_int(config, "gaps-horizontal-inner", -1);
+        gappiv = dscm_alist_get_unsigned_int(config, "gaps-vertical-inner", -1);
+        gappoh = dscm_alist_get_unsigned_int(config, "gaps-horizontal-outer", -1);
+        gappov = dscm_alist_get_unsigned_int(config, "gaps-vertical-outer", -1);
+        smartgaps = dscm_alist_get_int(config, "smart-gaps");
+        smartborders = dscm_alist_get_int(config, "smart-borders");
+
+        SCM colors = dscm_alist_get(config, "colors");
+        rootcolor = dscm_iterate_list(dscm_alist_get(colors, "root"),
+                sizeof(float), 0, &dscm_parse_color, NULL);
+        bordercolor = dscm_iterate_list(dscm_alist_get(colors, "border"),
+                sizeof(float), 0, &dscm_parse_color, NULL);
+        focuscolor = dscm_iterate_list(dscm_alist_get(colors, "focus"),
+                sizeof(float), 0, &dscm_parse_color, NULL);
+        textcolor = dscm_iterate_list(dscm_alist_get(colors, "text"),
+                sizeof(float), 0, &dscm_parse_color, NULL);
+        tags = dscm_iterate_list(dscm_alist_get(config, "tags"),
+                sizeof(char*), 0, &dscm_parse_string, &numtags);
+        termcmd = dscm_iterate_list(dscm_alist_get(config, "terminal"),
+                sizeof(char*), 1, &dscm_parse_string, NULL);
+        menucmd = dscm_iterate_list(dscm_alist_get(config, "menu"),
+                sizeof(char*), 1, &dscm_parse_string, NULL);
+        layouts = dscm_iterate_list(dscm_alist_get(config, "layouts"),
+                sizeof(Layout), 0, &dscm_parse_layout, &numlayouts);
+        rules = dscm_iterate_list(dscm_alist_get(config, "rules"),
+                sizeof(Rule), 0, &dscm_parse_rule, &numrules);
+        monrules = dscm_iterate_list(dscm_alist_get(config, "monitor-rules"),
+                sizeof(MonitorRule), 0, &dscm_parse_monitor_rule, &nummonrules);
+        keys = dscm_iterate_list(dscm_alist_get(config, "keys"),
+                sizeof(Key), 0, &dscm_parse_key, &numkeys);
+        buttons = dscm_iterate_list(dscm_alist_get(config, "buttons"),
+                sizeof(Button), 0, &dscm_parse_button, &numbuttons);
+        xkb_rules = dscm_parse_xkb_rules(config);
+        TAGMASK = ((1 << numtags) - 1);
+}
+
+static inline void
+dscm_config_cleanup()
+{
+        fprintf(stdout, "dscm: starting cleanup\n");
+        int i;
+        char **str;
+        for (i = 0; i < numtags; i++) free(tags[i]);
+        for (str = termcmd; *str != NULL; str++) free(*str);
+        for (str = menucmd; *str != NULL; str++) free(*str);
+        for (i = 0; i < numlayouts; i++) free(layouts[i].symbol);
+        for (i = 0; i < nummonrules; i++) free(monrules[i].name);
+        for (i = 0; i < numrules; i++) {
+                Rule r = rules[i];
+                free(r.id);
+                free(r.title);
+        }
+        free(layouts);
+        free(monrules);
+        free(keys);
+        free(buttons);
+        free(rootcolor);
+        free(bordercolor);
+        free(focuscolor);
+        free(textcolor);
+        free((char*)xkb_rules->rules);
+        free((char*)xkb_rules->model);
+        free((char*)xkb_rules->layout);
+        free((char*)xkb_rules->variant);
+        free((char*)xkb_rules->options);
+        free(xkb_rules);
+}
diff --git a/dscm-utils.h b/dscm-utils.h
new file mode 100644
index 0000000..6c246ae
--- /dev/null
+++ b/dscm-utils.h
@@ -0,0 +1,174 @@
+#pragma once
+
+enum { DSCM_CALL_ARRANGE, DSCM_CALL_ACTION };
+typedef struct {
+        SCM proc;
+        void *args;
+} dscm_call_data_t;
+
+static inline SCM
+dscm_alist_get(SCM alist, const char* key)
+{
+        return scm_assoc_ref(alist, scm_from_utf8_string(key));
+}
+
+static inline char*
+dscm_alist_get_string(SCM alist, const char* key)
+{
+        SCM value = dscm_alist_get(alist, key);
+        if (scm_is_string(value))
+                return scm_to_locale_string(value);
+        return NULL;
+}
+
+static inline int
+dscm_alist_get_int(SCM alist, const char* key)
+{
+        SCM value = dscm_alist_get(alist, key);
+        if (scm_is_bool(value))
+                return scm_is_true(value) ? 1 : 0;
+        return scm_to_int(value);
+}
+
+static inline unsigned int
+dscm_alist_get_unsigned_int(SCM alist, const char* key, int max)
+{
+        return scm_to_unsigned_integer(dscm_alist_get(alist, key), 0, max);
+}
+
+static inline double
+dscm_alist_get_double(SCM alist, const char* key)
+{
+        SCM value = dscm_alist_get(alist, key);
+        if (scm_is_bool(value))
+                return scm_is_true(value) ? 1 : 0;
+        return scm_to_double(value);
+}
+
+static inline float
+dscm_alist_get_float(SCM alist, const char* key)
+{
+        return (float)dscm_alist_get_double(alist, key);
+}
+
+static inline scm_t_bits *
+dscm_alist_get_proc_pointer(SCM alist, const char *key)
+{
+        scm_t_bits *proc = NULL;
+        SCM value = dscm_alist_get(alist, key);
+        if (scm_is_false(value))
+                return proc;
+        SCM eval = scm_primitive_eval(value);
+        /* SCM_UNPACK_POINTER is only allowed on expressions where SCM_IMP is 0 */
+        if (SCM_IMP(eval) == 1)
+                BARF("dscm: invalid callback procedure. SCM_IMP(proc) = 1");
+        if (scm_procedure_p(eval) == SCM_BOOL_T) {
+                proc = SCM_UNPACK_POINTER(eval);
+                scm_gc_protect_object(eval);
+        }
+        return proc;
+}
+
+static inline SCM
+dscm_get_variable(const char *name)
+{
+        return scm_variable_ref(scm_c_lookup(name));
+}
+
+static inline unsigned int
+dscm_get_list_length(SCM list)
+{
+        return scm_to_unsigned_integer(scm_length(list), 0, -1);
+}
+
+static inline SCM
+dscm_get_list_item(SCM list, unsigned int index)
+{
+        return scm_list_ref(list, scm_from_unsigned_integer(index));
+}
+
+static inline uint32_t
+dscm_alist_get_modifiers(SCM alist, const char *key)
+{
+        SCM modifiers = dscm_alist_get(alist, key);
+        uint32_t mod = 0;
+        unsigned int i = 0, length = dscm_get_list_length(modifiers);
+        for (; i < length; i++) {
+                SCM item = dscm_get_list_item(modifiers, i);
+                SCM eval = scm_primitive_eval(item);
+                mod |= scm_to_uint32(eval);
+        }
+        return mod;
+}
+
+static inline unsigned int
+dscm_get_tag(SCM tag, unsigned int tags)
+{
+        unsigned int target_tag = scm_to_unsigned_integer(tag, 1, tags) - 1;
+        return (1 << (target_tag));
+}
+
+static inline void *
+dscm_iterate_list(SCM list, size_t elem_size, int append_null,
+        void (*iterator)(unsigned int, SCM, void*), unsigned int *length_var)
+{
+        SCM item;
+        unsigned int i = 0, length = 0;
+        length = dscm_get_list_length(list);
+        void *allocated = calloc(append_null ? length + 1 : length, elem_size);
+        for (; i < length; i++) {
+                item = dscm_get_list_item(list, i);
+                (*iterator)(i, item, allocated);
+        }
+        if (append_null)
+                ((void**)allocated)[i] = NULL;
+        if (length_var)
+                *length_var = length;
+        return allocated;
+}
+
+static inline void
+dscm_modify_list(SCM list, void *target, void (*iterator)(unsigned int, SCM, void*))
+{
+        SCM item;
+        unsigned int length = dscm_get_list_length(list);
+        for (unsigned int i = 0; i < length; i++) {
+                item = dscm_get_list_item(list, i);
+                (*iterator)(i, item, target);
+        }
+}
+
+static inline void*
+dscm_call_action(void *data)
+{
+        return scm_call_0(((dscm_call_data_t*)data)->proc);
+}
+
+static inline void*
+dscm_call_arrange(void *data)
+{
+        dscm_call_data_t *proc_data = (dscm_call_data_t*)data;
+        SCM mon = scm_from_pointer(proc_data->args, NULL);
+        return scm_call_1(proc_data->proc, mon);
+}
+
+static inline void
+dscm_safe_call(unsigned int type, scm_t_bits *proc_ptr, void *data)
+{
+        if (proc_ptr == NULL) {
+                fprintf(stderr, "dscm: could not call proc that is NULL");
+                return;
+        }
+        SCM proc = SCM_PACK_POINTER(proc_ptr);
+        dscm_call_data_t proc_data = {.proc = proc, .args = data};
+        void *(*func)(void*) = NULL;
+        switch (type) {
+            case DSCM_CALL_ARRANGE:
+                func = &dscm_call_arrange;
+                break;
+            case DSCM_CALL_ACTION:
+            default:
+                func = &dscm_call_action;
+        }
+        scm_c_with_continuation_barrier(func, &proc_data);
+}
diff --git a/dwl.c b/dwl.c
index 0deae84..2e56ed2 100644
--- a/dwl.c
+++ b/dwl.c
@@ -21,27 +21,35 @@
 #include <wlr/types/wlr_export_dmabuf_v1.h>
 #include <wlr/types/wlr_gamma_control_v1.h>
 #include <wlr/types/wlr_input_device.h>
+#include <wlr/types/wlr_input_inhibitor.h>
 #include <wlr/types/wlr_idle.h>
 #include <wlr/types/wlr_layer_shell_v1.h>
+#include <wlr/types/wlr_idle_inhibit_v1.h>
 #include <wlr/types/wlr_keyboard.h>
 #include <wlr/types/wlr_matrix.h>
 #include <wlr/types/wlr_output.h>
+#include <wlr/types/wlr_output_damage.h>
 #include <wlr/types/wlr_output_layout.h>
 #include <wlr/types/wlr_output_management_v1.h>
 #include <wlr/types/wlr_pointer.h>
+#include <wlr/types/wlr_presentation_time.h>
 #include <wlr/types/wlr_primary_selection.h>
 #include <wlr/types/wlr_primary_selection_v1.h>
 #include <wlr/types/wlr_screencopy_v1.h>
+#include <wlr/types/wlr_server_decoration.h>
 #include <wlr/types/wlr_seat.h>
 #include <wlr/types/wlr_viewporter.h>
 #include <wlr/types/wlr_virtual_keyboard_v1.h>
 #include <wlr/types/wlr_xcursor_manager.h>
+#include <wlr/types/wlr_xdg_activation_v1.h>
 #include <wlr/types/wlr_xdg_decoration_v1.h>
 #include <wlr/types/wlr_xdg_output_v1.h>
 #include <wlr/types/wlr_xdg_shell.h>
 #include <wlr/backend/libinput.h>
 #include <wlr/util/log.h>
 #include <xkbcommon/xkbcommon.h>
+#include <libguile.h>
+#include "dscm-unstable-v1-protocol.h"
 #ifdef XWAYLAND
 #include <X11/Xlib.h>
 #include <wlr/xwayland.h>
@@ -55,167 +63,225 @@
 #define CLEANMASK(mask)         (mask & ~WLR_MODIFIER_CAPS)
 #define VISIBLEON(C, M)         ((C)->mon == (M) && ((C)->tags & (M)->tagset[(M)->seltags]))
 #define LENGTH(X)               (sizeof X / sizeof X[0])
-#define END(A)                  ((A) + LENGTH(A))
-#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
 #define ROUND(X)                ((int)((X)+0.5))
 #define LISTEN(E, L, H)         wl_signal_add((E), ((L)->notify = (H), (L)))
 
+/* constants */
+#define HEXLENGTH                9
+
 /* enums */
 enum { CurNormal, CurMove, CurResize }; /* cursor */
 #ifdef XWAYLAND
 enum { NetWMWindowTypeDialog, NetWMWindowTypeSplash, NetWMWindowTypeToolbar,
-	NetWMWindowTypeUtility, NetLast }; /* EWMH atoms */
+        NetWMWindowTypeUtility, NetLast }; /* EWMH atoms */
 enum { XDGShell, X11Managed, X11Unmanaged }; /* client types */
 #endif
 
 typedef union {
-	int i;
-	unsigned int ui;
-	float f;
-	const void *v;
+        int i;
+        unsigned int ui;
+        float f;
+        void *v;
 } Arg;
 
 typedef struct {
-	unsigned int mod;
-	unsigned int button;
-	void (*func)(const Arg *);
-	const Arg arg;
+        unsigned int mod;
+        unsigned int button;
+        scm_t_bits *func;
 } Button;
 
 typedef struct Monitor Monitor;
 typedef struct {
-	struct wl_list link;
-	struct wl_list flink;
-	struct wl_list slink;
-	union {
-		struct wlr_xdg_surface *xdg;
-		struct wlr_xwayland_surface *xwayland;
-	} surface;
-	struct wl_listener commit;
-	struct wl_listener map;
-	struct wl_listener unmap;
-	struct wl_listener destroy;
-	struct wl_listener fullscreen;
-	struct wlr_box geom;  /* layout-relative, includes border */
-	Monitor *mon;
+        struct wl_list link;
+        struct wl_list flink;
+        struct wl_list slink;
+        union {
+                struct wlr_xdg_surface *xdg;
+                struct wlr_xwayland_surface *xwayland;
+        } surface;
+        struct wl_listener commit;
+        struct wl_listener new_sub;
+        struct wl_listener map;
+        struct wl_listener unmap;
+        struct wl_listener destroy;
+        struct wl_listener set_title;
+        struct wl_listener fullscreen;
+        struct wlr_box geom;  /* layout-relative, includes border */
+        Monitor *mon;
 #ifdef XWAYLAND
-	unsigned int type;
-	struct wl_listener activate;
-	struct wl_listener configure;
+        unsigned int type;
+        struct wl_listener activate;
+        struct wl_listener configure;
 #endif
-	int bw;
-	unsigned int tags;
-	int isfloating;
-	uint32_t resize; /* configure serial of a pending resize */
-	int prevx;
-	int prevy;
-	int prevwidth;
-	int prevheight;
-	int isfullscreen;
+        int bw;
+        unsigned int tags;
+        int isfloating, isurgent;
+        double alpha;
+        double prevalpha;
+        uint32_t resize; /* configure serial of a pending resize */
+        int prevx;
+        int prevy;
+        int prevwidth;
+        int prevheight;
+        int isfullscreen;
 } Client;
 
 typedef struct {
-	struct wl_listener request_mode;
-	struct wl_listener destroy;
+        struct wl_list link;
+        struct wl_listener commit;
+        struct wl_listener map;
+        struct wl_listener unmap;
+        struct wl_listener destroy;
+        struct wlr_subsurface *subsurface;
+        Client *c;
+} Subsurface;
+
+typedef struct {
+        struct wl_listener request_mode;
+        struct wl_listener destroy;
 } Decoration;
 
 typedef struct {
-	uint32_t mod;
-	xkb_keysym_t keysym;
-	void (*func)(const Arg *);
-	const Arg arg;
+        uint32_t mod;
+        xkb_keycode_t keycode;
+        scm_t_bits *func;
 } Key;
 
 typedef struct {
-	struct wl_list link;
-	struct wlr_input_device *device;
+        struct wl_list link;
+        struct wlr_input_device *device;
 
-	struct wl_listener modifiers;
-	struct wl_listener key;
-	struct wl_listener destroy;
+        struct wl_listener modifiers;
+        struct wl_listener key;
+        struct wl_listener destroy;
 } Keyboard;
 
 typedef struct {
-	struct wlr_layer_surface_v1 *layer_surface;
-	struct wl_list link;
+        struct wlr_layer_surface_v1 *layer_surface;
+        struct wl_list link;
 
-	struct wl_listener destroy;
-	struct wl_listener map;
-	struct wl_listener unmap;
-	struct wl_listener surface_commit;
+        struct wl_listener destroy;
+        struct wl_listener map;
+        struct wl_listener unmap;
+        struct wl_listener surface_commit;
 
-	struct wlr_box geo;
-	enum zwlr_layer_shell_v1_layer layer;
+        struct wlr_box geo;
+        enum zwlr_layer_shell_v1_layer layer;
+        Monitor *mon;
 } LayerSurface;
 
 typedef struct {
-	uint32_t singular_anchor;
-	uint32_t anchor_triplet;
-	int *positive_axis;
-	int *negative_axis;
-	int margin;
+        uint32_t singular_anchor;
+        uint32_t anchor_triplet;
+        int *positive_axis;
+        int *negative_axis;
+        int margin;
 } Edge;
 
 typedef struct {
-	const char *symbol;
-	void (*arrange)(Monitor *);
+        char *symbol;
+        scm_t_bits *arrange;
+        char *id;
 } Layout;
 
+typedef struct {
+        struct wl_list link;
+        struct wl_resource *resource;
+} DscmClient;
+
+typedef struct {
+        struct wl_list link;
+        struct wl_resource *resource;
+        struct Monitor *monitor;
+} DscmMonitor;
+
 struct Monitor {
-	struct wl_list link;
-	struct wlr_output *wlr_output;
-	struct wl_listener frame;
-	struct wl_listener destroy;
-	struct wlr_box m;      /* monitor area, layout-relative */
-	struct wlr_box w;      /* window area, layout-relative */
-	struct wl_list layers[4]; // LayerSurface::link
-	const Layout *lt[2];
-	unsigned int seltags;
-	unsigned int sellt;
-	unsigned int tagset[2];
-	double mfact;
-	int nmaster;
+        struct wl_list link;
+        struct wlr_output *wlr_output;
+        struct wl_listener frame;
+        struct wl_listener destroy;
+        struct wlr_box m;      /* monitor area, layout-relative */
+        struct wlr_box w;      /* window area, layout-relative */
+        struct wl_list layers[4]; // LayerSurface::link
+        struct wl_list dscm;
+        const Layout *lt[2];
+        int gappih;           /* horizontal gap between windows */
+        int gappiv;           /* vertical gap between windows */
+        int gappoh;           /* horizontal outer gaps */
+        int gappov;           /* vertical outer gaps */
+        unsigned int seltags;
+        unsigned int sellt;
+        unsigned int tagset[2];
+        unsigned int prevtagset;
+        double mfact;
+        int nmaster;
+        struct wlr_output_damage *damage;
 };
 
 typedef struct {
-	const char *name;
-	float mfact;
-	int nmaster;
-	float scale;
-	const Layout *lt;
-	enum wl_output_transform rr;
-	int x;
-	int y;
+        char *name;
+        float mfact;
+        int nmaster;
+        float scale;
+        const Layout *lt;
+        enum wl_output_transform rr;
+        int x;
+        int y;
 } MonitorRule;
 
 typedef struct {
-	const char *id;
-	const char *title;
-	unsigned int tags;
-	int isfloating;
-	int monitor;
+        char *id;
+        char *title;
+        unsigned int tags;
+        int isfloating;
+        double alpha;
+        int monitor;
 } Rule;
 
 /* Used to move all of the data necessary to render a surface from the top-level
  * frame handler to the per-surface render function. */
 struct render_data {
-	struct wlr_output *output;
-	struct timespec *when;
-	int x, y; /* layout-relative */
+        struct wlr_output *output;
+        struct timespec *when;
+        int x, y; /* layout-relative */
+        double alpha;
 };
 
+/* dscm protocol */
+static void dscm_sendevents(void);
+static void dscm_sendeventsclient(DscmClient *c);
+static void dscm_rgbatostr(char *buf, float *color);
+static void dscm_closemon(struct wl_client *client, struct wl_resource *resource);
+static void dscm_destroymon(struct wl_resource *resource);
+static void dscm_printstatusmon(Monitor *m, const DscmMonitor *mon);
+static void dscm_printstatus(Monitor *m);
+static void dscm_settags(struct wl_client *client, struct wl_resource *resource,
+                         uint32_t t, uint32_t toggle_tagset);
+static void dscm_setlayout(struct wl_client *client, struct wl_resource *resource,
+                           uint32_t layout);
+static void dscm_setclient(struct wl_client *client, struct wl_resource *resource,
+                           uint32_t and, uint32_t xor);
+static void dscm_release(struct wl_client *client, struct wl_resource *resource);
+static void dscm_getmon(struct wl_client *client, struct wl_resource *resource,
+                        uint32_t id, struct wl_resource *output);
+static void dscm_destroy(struct wl_resource *resource);
+static void dscm_bind(struct wl_client *client, void *data, uint32_t version,
+                      uint32_t id);
+
 /* function declarations */
 static void applybounds(Client *c, struct wlr_box *bbox);
 static void applyexclusive(struct wlr_box *usable_area, uint32_t anchor,
-		int32_t exclusive, int32_t margin_top, int32_t margin_right,
-		int32_t margin_bottom, int32_t margin_left);
+                           int32_t exclusive, int32_t margin_top,
+                           int32_t margin_right, int32_t margin_bottom,
+                           int32_t margin_left);
 static void applyrules(Client *c);
 static void arrange(Monitor *m);
 static void arrangelayer(Monitor *m, struct wl_list *list,
-		struct wlr_box *usable_area, int exclusive);
+                         struct wlr_box *usable_area, int exclusive);
 static void arrangelayers(Monitor *m);
 static void axisnotify(struct wl_listener *listener, void *data);
 static void buttonpress(struct wl_listener *listener, void *data);
+static void changealpha(const Arg *arg);
 static void chvt(const Arg *arg);
 static void cleanup(void);
 static void cleanupkeyboard(struct wl_listener *listener, void *data);
@@ -223,48 +289,58 @@ static void cleanupmon(struct wl_listener *listener, void *data);
 static void closemon(Monitor *m);
 static void commitlayersurfacenotify(struct wl_listener *listener, void *data);
 static void commitnotify(struct wl_listener *listener, void *data);
+static void commitnotify_sub(struct wl_listener *listener, void *data);
+static void createidleinhibitor(struct wl_listener *listener, void *data);
 static void createkeyboard(struct wlr_input_device *device);
 static void createmon(struct wl_listener *listener, void *data);
 static void createnotify(struct wl_listener *listener, void *data);
 static void createlayersurface(struct wl_listener *listener, void *data);
 static void createpointer(struct wlr_input_device *device);
-static void createxdeco(struct wl_listener *listener, void *data);
 static void cursorframe(struct wl_listener *listener, void *data);
+static void cyclelayout(const Arg *arg);
+static void destroyidleinhibitor(struct wl_listener *listener, void *data);
 static void destroylayersurfacenotify(struct wl_listener *listener, void *data);
 static void destroynotify(struct wl_listener *listener, void *data);
-static void destroyxdeco(struct wl_listener *listener, void *data);
+static void destroynotify_sub(struct wl_listener *listener, void *data);
 static Monitor *dirtomon(enum wlr_direction dir);
+static void dragdestroy(struct wl_listener *listener, void *data);
 static void focusclient(Client *c, int lift);
 static void focusmon(const Arg *arg);
 static void focusstack(const Arg *arg);
 static void fullscreennotify(struct wl_listener *listener, void *data);
 static Client *focustop(Monitor *m);
-static void getxdecomode(struct wl_listener *listener, void *data);
 static void incnmaster(const Arg *arg);
 static void inputdevice(struct wl_listener *listener, void *data);
-static int keybinding(uint32_t mods, xkb_keysym_t sym);
+static int keybinding(uint32_t mods, xkb_keycode_t keycode);
 static void keypress(struct wl_listener *listener, void *data);
 static void keypressmod(struct wl_listener *listener, void *data);
 static void killclient(const Arg *arg);
 static void maplayersurfacenotify(struct wl_listener *listener, void *data);
 static void mapnotify(struct wl_listener *listener, void *data);
+static void mapnotify_sub(struct wl_listener *listener, void *data);
 static void monocle(Monitor *m);
 static void motionabsolute(struct wl_listener *listener, void *data);
 static void motionnotify(uint32_t time);
 static void motionrelative(struct wl_listener *listener, void *data);
 static void moveresize(const Arg *arg);
+static void new_subnotify(struct wl_listener *listener, void *data);
 static void outputmgrapply(struct wl_listener *listener, void *data);
-static void outputmgrapplyortest(struct wlr_output_configuration_v1 *config, int test);
+static void outputmgrapplyortest(struct wlr_output_configuration_v1 *config,
+                                 int test);
 static void outputmgrtest(struct wl_listener *listener, void *data);
 static void pointerfocus(Client *c, struct wlr_surface *surface,
-		double sx, double sy, uint32_t time);
+                         double sx, double sy, uint32_t time);
 static void printstatus(void);
 static void quit(const Arg *arg);
+static void quitsignal(int signo);
 static void render(struct wlr_surface *surface, int sx, int sy, void *data);
 static void renderclients(Monitor *m, struct timespec *now);
+static void renderdragicon(Monitor *m, struct timespec *now);
 static void renderlayer(struct wl_list *layer_surfaces, struct timespec *now);
 static void rendermon(struct wl_listener *listener, void *data);
-static void resize(Client *c, int x, int y, int w, int h, int interact);
+static void requeststartdrag(struct wl_listener *listener, void *data);
+static void resize(Client *c, int x, int y, int w, int h, int interact,
+                   int draw_borders);
 static void run(char *startup_cmd);
 static void scalebox(struct wlr_box *box, float scale);
 static Client *selclient(void);
@@ -276,9 +352,10 @@ static void setfullscreen(Client *c, int fullscreen);
 static void setlayout(const Arg *arg);
 static void setmfact(const Arg *arg);
 static void setmon(Client *c, Monitor *m, unsigned int newtags);
-static void setup(void);
+static void setup(char* config_file);
 static void sigchld(int unused);
 static void spawn(const Arg *arg);
+static void startdrag(struct wl_listener *listener, void *data);
 static void tag(const Arg *arg);
 static void tagmon(const Arg *arg);
 static void tile(Monitor *m);
@@ -289,14 +366,33 @@ static void toggleview(const Arg *arg);
 static void unmaplayersurface(LayerSurface *layersurface);
 static void unmaplayersurfacenotify(struct wl_listener *listener, void *data);
 static void unmapnotify(struct wl_listener *listener, void *data);
+static void unmapnotify_sub(struct wl_listener *listener, void *data);
 static void updatemons(struct wl_listener *listener, void *data);
+static void updatetitle(struct wl_listener *listener, void *data);
+static void urgent(struct wl_listener *listener, void *data);
 static void view(const Arg *arg);
+static void viewprev(const Arg *arg);
 static void virtualkeyboard(struct wl_listener *listener, void *data);
+static void writepid(const char *runtimedir);
 static Client *xytoclient(double x, double y);
 static struct wlr_surface *xytolayersurface(struct wl_list *layer_surfaces,
-		double x, double y, double *sx, double *sy);
+                                            double x, double y,
+                                            double *sx, double *sy);
 static Monitor *xytomon(double x, double y);
 static void zoom(const Arg *arg);
+static void setgaps(int oh, int ov, int ih, int iv);
+static void incrgaps(const Arg *arg);
+static void incrigaps(const Arg *arg);
+static void incrogaps(const Arg *arg);
+static void incrohgaps(const Arg *arg);
+static void incrovgaps(const Arg *arg);
+static void incrihgaps(const Arg *arg);
+static void incrivgaps(const Arg *arg);
+static void togglegaps(const Arg *arg);
+static void defaultgaps(const Arg *arg);
+
+/* signal actions */
+static int reloadconfig(int signal, void *data);
 
 /* variables */
 static const char broken[] = "broken";
@@ -306,58 +402,81 @@ static struct wlr_renderer *drw;
 static struct wlr_compositor *compositor;
 
 static struct wlr_xdg_shell *xdg_shell;
+static struct wlr_xdg_activation_v1 *activation;
 static struct wl_list clients; /* tiling order */
 static struct wl_list fstack;  /* focus order */
 static struct wl_list stack;   /* stacking z-order */
 static struct wl_list independents;
+static struct wl_list subsurfaces;
+static struct wl_list dscm_clients;
 static struct wlr_idle *idle;
+static struct wlr_idle_inhibit_manager_v1 *idle_inhibit_mgr;
+static struct wlr_input_inhibit_manager *input_inhibit_mgr;
 static struct wlr_layer_shell_v1 *layer_shell;
-static struct wlr_xdg_decoration_manager_v1 *xdeco_mgr;
 static struct wlr_output_manager_v1 *output_mgr;
+static struct wlr_presentation *presentation;
 static struct wlr_virtual_keyboard_manager_v1 *virtual_keyboard_mgr;
 
 static struct wlr_cursor *cursor;
 static struct wlr_xcursor_manager *cursor_mgr;
-#ifdef XWAYLAND
-static struct wlr_xcursor *xcursor;
-static struct wlr_xcursor_manager *xcursor_mgr;
-#endif
 
 static struct wlr_seat *seat;
 static struct wl_list keyboards;
 static unsigned int cursor_mode;
 static Client *grabc;
 static int grabcx, grabcy; /* client-relative */
+static struct wlr_drag_icon* drag_icon;
 
 static struct wlr_output_layout *output_layout;
 static struct wlr_box sgeom;
 static struct wl_list mons;
 static Monitor *selmon;
 
+static int enablegaps = 1;   /* enables gaps, used by togglegaps */
+
 /* global event handlers */
 static struct wl_listener cursor_axis = {.notify = axisnotify};
 static struct wl_listener cursor_button = {.notify = buttonpress};
 static struct wl_listener cursor_frame = {.notify = cursorframe};
 static struct wl_listener cursor_motion = {.notify = motionrelative};
 static struct wl_listener cursor_motion_absolute = {.notify = motionabsolute};
+static struct wl_listener destroy_idle_inhibitor = {.notify = destroyidleinhibitor};
 static struct wl_listener layout_change = {.notify = updatemons};
+static struct wl_listener new_idle_inhibitor = {.notify = createidleinhibitor};
 static struct wl_listener new_input = {.notify = inputdevice};
 static struct wl_listener new_virtual_keyboard = {.notify = virtualkeyboard};
 static struct wl_listener new_output = {.notify = createmon};
-static struct wl_listener new_xdeco = {.notify = createxdeco};
 static struct wl_listener new_xdg_surface = {.notify = createnotify};
 static struct wl_listener new_layer_shell_surface = {.notify = createlayersurface};
 static struct wl_listener output_mgr_apply = {.notify = outputmgrapply};
 static struct wl_listener output_mgr_test = {.notify = outputmgrtest};
+static struct wl_listener request_activate = {.notify = urgent};
 static struct wl_listener request_cursor = {.notify = setcursor};
 static struct wl_listener request_set_psel = {.notify = setpsel};
 static struct wl_listener request_set_sel = {.notify = setsel};
+static struct wl_listener request_start_drag = {.notify = requeststartdrag};
+static struct wl_listener start_drag = {.notify = startdrag};
+static struct wl_listener drag_destroy = {.notify = dragdestroy};
+
+/* dscm event handlers */
+static struct dscm_monitor_v1_interface dscm_monitor_implementation = {
+        .release = dscm_closemon,
+        .set_tags = dscm_settags,
+        .set_layout = dscm_setlayout,
+        .set_client_tags = dscm_setclient,
+};
+static struct dscm_v1_interface dscm_implementation = {
+        .release = dscm_release,
+        .get_monitor = dscm_getmon,
+};
 
 #ifdef XWAYLAND
 static void activatex11(struct wl_listener *listener, void *data);
 static void configurex11(struct wl_listener *listener, void *data);
 static void createnotifyx11(struct wl_listener *listener, void *data);
+void commitnotifyx11(struct wl_listener *listener, void *data);
 static Atom getatom(xcb_connection_t *xc, const char *name);
+static void mapnotify_unmanaged(struct wl_listener *listener, void *data);
 static void renderindependents(struct wlr_output *output, struct timespec *now);
 static void xwaylandready(struct wl_listener *listener, void *data);
 static Client *xytoindependent(double x, double y);
@@ -367,2220 +486,2976 @@ static struct wlr_xwayland *xwayland;
 static Atom netatom[NetLast];
 #endif
 
-/* configuration, allows nested code to access above variables */
-#include "config.h"
-
 /* attempt to encapsulate suck into one file */
 #include "client.h"
 
-/* compile-time check if all tags fit into an unsigned int bit array. */
-struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
+/* include guile config and bindings */
+#include "dscm-utils.h"
+#include "dscm-config.h"
+#include "dscm-bindings.h"
 
 /* function implementations */
 void
 applybounds(Client *c, struct wlr_box *bbox)
 {
-	/* set minimum possible */
-	c->geom.width = MAX(1, c->geom.width);
-	c->geom.height = MAX(1, c->geom.height);
+        /* set minimum possible */
+        c->geom.width = MAX(1, c->geom.width);
+        c->geom.height = MAX(1, c->geom.height);
 
-	if (c->geom.x >= bbox->x + bbox->width)
-		c->geom.x = bbox->x + bbox->width - c->geom.width;
-	if (c->geom.y >= bbox->y + bbox->height)
-		c->geom.y = bbox->y + bbox->height - c->geom.height;
-	if (c->geom.x + c->geom.width + 2 * c->bw <= bbox->x)
-		c->geom.x = bbox->x;
-	if (c->geom.y + c->geom.height + 2 * c->bw <= bbox->y)
-		c->geom.y = bbox->y;
+        if (c->geom.x >= bbox->x + bbox->width)
+                c->geom.x = bbox->x + bbox->width - c->geom.width;
+        if (c->geom.y >= bbox->y + bbox->height)
+                c->geom.y = bbox->y + bbox->height - c->geom.height;
+        if (c->geom.x + c->geom.width + 2 * c->bw <= bbox->x)
+                c->geom.x = bbox->x;
+        if (c->geom.y + c->geom.height + 2 * c->bw <= bbox->y)
+                c->geom.y = bbox->y;
 }
 
 void
 applyexclusive(struct wlr_box *usable_area,
-		uint32_t anchor, int32_t exclusive,
-		int32_t margin_top, int32_t margin_right,
-		int32_t margin_bottom, int32_t margin_left) {
-	Edge edges[] = {
-		{ // Top
-			.singular_anchor = ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP,
-			.anchor_triplet = ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT |
-				ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT |
-				ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP,
-			.positive_axis = &usable_area->y,
-			.negative_axis = &usable_area->height,
-			.margin = margin_top,
-		},
-		{ // Bottom
-			.singular_anchor = ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM,
-			.anchor_triplet = ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT |
-				ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT |
-				ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM,
-			.positive_axis = NULL,
-			.negative_axis = &usable_area->height,
-			.margin = margin_bottom,
-		},
-		{ // Left
-			.singular_anchor = ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT,
-			.anchor_triplet = ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT |
-				ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP |
-				ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM,
-			.positive_axis = &usable_area->x,
-			.negative_axis = &usable_area->width,
-			.margin = margin_left,
-		},
-		{ // Right
-			.singular_anchor = ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT,
-			.anchor_triplet = ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT |
-				ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP |
-				ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM,
-			.positive_axis = NULL,
-			.negative_axis = &usable_area->width,
-			.margin = margin_right,
-		}
-	};
-	for (size_t i = 0; i < LENGTH(edges); i++) {
-		if ((anchor == edges[i].singular_anchor || anchor == edges[i].anchor_triplet)
-				&& exclusive + edges[i].margin > 0) {
-			if (edges[i].positive_axis)
-				*edges[i].positive_axis += exclusive + edges[i].margin;
-			if (edges[i].negative_axis)
-				*edges[i].negative_axis -= exclusive + edges[i].margin;
-			break;
-		}
-	}
+               uint32_t anchor, int32_t exclusive,
+               int32_t margin_top, int32_t margin_right,
+               int32_t margin_bottom, int32_t margin_left)
+{
+        Edge edges[] = {
+                { // Top
+                        .singular_anchor = ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP,
+                        .anchor_triplet = ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT |
+                        ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT |
+                        ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP,
+                        .positive_axis = &usable_area->y,
+                        .negative_axis = &usable_area->height,
+                        .margin = margin_top,
+                },
+                { // Bottom
+                        .singular_anchor = ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM,
+                        .anchor_triplet = ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT |
+                        ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT |
+                        ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM,
+                        .positive_axis = NULL,
+                        .negative_axis = &usable_area->height,
+                        .margin = margin_bottom,
+                },
+                { // Left
+                        .singular_anchor = ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT,
+                        .anchor_triplet = ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT |
+                        ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP |
+                        ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM,
+                        .positive_axis = &usable_area->x,
+                        .negative_axis = &usable_area->width,
+                        .margin = margin_left,
+                },
+                { // Right
+                        .singular_anchor = ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT,
+                        .anchor_triplet = ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT |
+                        ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP |
+                        ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM,
+                        .positive_axis = NULL,
+                        .negative_axis = &usable_area->width,
+                        .margin = margin_right,
+                }
+        };
+        for (size_t i = 0; i < LENGTH(edges); i++) {
+                if ((anchor == edges[i].singular_anchor ||
+                     anchor == edges[i].anchor_triplet)
+                    && exclusive + edges[i].margin > 0) {
+                        if (edges[i].positive_axis)
+                                *edges[i].positive_axis +=
+                                        exclusive + edges[i].margin;
+                        if (edges[i].negative_axis)
+                                *edges[i].negative_axis -=
+                                        exclusive + edges[i].margin;
+                        break;
+                }
+        }
 }
 
 void
 applyrules(Client *c)
 {
-	/* rule matching */
-	const char *appid, *title;
-	unsigned int i, newtags = 0;
-	const Rule *r;
-	Monitor *mon = selmon, *m;
-
-	c->isfloating = client_is_float_type(c);
-	if (!(appid = client_get_appid(c)))
-		appid = broken;
-	if (!(title = client_get_title(c)))
-		title = broken;
-
-	for (r = rules; r < END(rules); r++) {
-		if ((!r->title || strstr(title, r->title))
-				&& (!r->id || strstr(appid, r->id))) {
-			c->isfloating = r->isfloating;
-			newtags |= r->tags;
-			i = 0;
-			wl_list_for_each(m, &mons, link)
-				if (r->monitor == i++)
-					mon = m;
-		}
-	}
-	setmon(c, mon, newtags);
+        /* rule matching */
+        const char *appid, *title;
+        unsigned int j, newtags = 0;
+        Rule r;
+        Monitor *mon = selmon, *m;
+
+        c->isfloating = client_is_float_type(c);
+        if (!(appid = client_get_appid(c)))
+                appid = broken;
+        if (!(title = client_get_title(c)))
+                title = broken;
+
+        for (int i = 0; i < numrules; i++) {
+                r = rules[i];
+                if ((!r.title || strstr(title, r.title))
+                    && (!r.id || strstr(appid, r.id))) {
+                        c->isfloating = r.isfloating;
+                        c->alpha = r.alpha;
+                        newtags |= r.tags;
+                        j = 0;
+                        wl_list_for_each(m, &mons, link)
+                                if (r.monitor == j++)
+                                        mon = m;
+                }
+        }
+        wl_list_insert(c->isfloating ? &stack : stack.prev, &c->slink);
+        setmon(c, mon, newtags);
 }
 
 void
 arrange(Monitor *m)
 {
-	if (m->lt[m->sellt]->arrange)
-		m->lt[m->sellt]->arrange(m);
-	/* TODO recheck pointer focus here... or in resize()? */
-}
-
-void
-arrangelayer(Monitor *m, struct wl_list *list, struct wlr_box *usable_area, int exclusive)
-{
-	LayerSurface *layersurface;
-	struct wlr_box full_area = m->m;
-
-	wl_list_for_each(layersurface, list, link) {
-		struct wlr_layer_surface_v1 *wlr_layer_surface = layersurface->layer_surface;
-		struct wlr_layer_surface_v1_state *state = &wlr_layer_surface->current;
-		struct wlr_box bounds;
-		struct wlr_box box = {
-			.width = state->desired_width,
-			.height = state->desired_height
-		};
-		const uint32_t both_horiz = ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT
-			| ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT;
-		const uint32_t both_vert = ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP
-			| ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM;
-
-		if (exclusive != (state->exclusive_zone > 0))
-			continue;
-
-		bounds = state->exclusive_zone == -1 ? full_area : *usable_area;
-
-		// Horizontal axis
-		if ((state->anchor & both_horiz) && box.width == 0) {
-			box.x = bounds.x;
-			box.width = bounds.width;
-		} else if ((state->anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT)) {
-			box.x = bounds.x;
-		} else if ((state->anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT)) {
-			box.x = bounds.x + (bounds.width - box.width);
-		} else {
-			box.x = bounds.x + ((bounds.width / 2) - (box.width / 2));
-		}
-		// Vertical axis
-		if ((state->anchor & both_vert) && box.height == 0) {
-			box.y = bounds.y;
-			box.height = bounds.height;
-		} else if ((state->anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP)) {
-			box.y = bounds.y;
-		} else if ((state->anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM)) {
-			box.y = bounds.y + (bounds.height - box.height);
-		} else {
-			box.y = bounds.y + ((bounds.height / 2) - (box.height / 2));
-		}
-		// Margin
-		if ((state->anchor & both_horiz) == both_horiz) {
-			box.x += state->margin.left;
-			box.width -= state->margin.left + state->margin.right;
-		} else if ((state->anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT)) {
-			box.x += state->margin.left;
-		} else if ((state->anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT)) {
-			box.x -= state->margin.right;
-		}
-		if ((state->anchor & both_vert) == both_vert) {
-			box.y += state->margin.top;
-			box.height -= state->margin.top + state->margin.bottom;
-		} else if ((state->anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP)) {
-			box.y += state->margin.top;
-		} else if ((state->anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM)) {
-			box.y -= state->margin.bottom;
-		}
-		if (box.width < 0 || box.height < 0) {
-			wlr_layer_surface_v1_close(wlr_layer_surface);
-			continue;
-		}
-		layersurface->geo = box;
-
-		if (state->exclusive_zone > 0)
-			applyexclusive(usable_area, state->anchor, state->exclusive_zone,
-					state->margin.top, state->margin.right,
-					state->margin.bottom, state->margin.left);
-		wlr_layer_surface_v1_configure(wlr_layer_surface, box.width, box.height);
-	}
+        if (m->lt[m->sellt]->arrange)
+                dscm_safe_call(DSCM_CALL_ARRANGE, m->lt[m->sellt]->arrange, m);
+        /* TODO recheck pointer focus here... or in resize()? */
+        wlr_output_damage_add_whole(m->damage);
+}
+
+void
+arrangelayer(Monitor *m, struct wl_list *list, struct wlr_box *usable_area,
+             int exclusive)
+{
+        LayerSurface *layersurface;
+        struct wlr_box full_area = m->m;
+
+        wl_list_for_each(layersurface, list, link) {
+                struct wlr_layer_surface_v1 *wlr_layer_surface = layersurface->layer_surface;
+                struct wlr_layer_surface_v1_state *state = &wlr_layer_surface->current;
+                struct wlr_box bounds;
+                struct wlr_box box = {
+                        .width = state->desired_width,
+                        .height = state->desired_height
+                };
+                const uint32_t both_horiz = ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT
+                        | ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT;
+                const uint32_t both_vert = ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP
+                        | ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM;
+
+                if (exclusive != (state->exclusive_zone > 0))
+                        continue;
+
+                bounds = state->exclusive_zone == -1 ? full_area : *usable_area;
+
+                // Horizontal axis
+                if ((state->anchor & both_horiz) && box.width == 0) {
+                        box.x = bounds.x;
+                        box.width = bounds.width;
+                } else if ((state->anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT)) {
+                        box.x = bounds.x;
+                } else if ((state->anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT)) {
+                        box.x = bounds.x + (bounds.width - box.width);
+                } else {
+                        box.x = bounds.x + ((bounds.width / 2) - (box.width / 2));
+                }
+                // Vertical axis
+                if ((state->anchor & both_vert) && box.height == 0) {
+                        box.y = bounds.y;
+                        box.height = bounds.height;
+                } else if ((state->anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP)) {
+                        box.y = bounds.y;
+                } else if ((state->anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM)) {
+                        box.y = bounds.y + (bounds.height - box.height);
+                } else {
+                        box.y = bounds.y + ((bounds.height / 2) - (box.height / 2));
+                }
+                // Margin
+                if ((state->anchor & both_horiz) == both_horiz) {
+                        box.x += state->margin.left;
+                        box.width -= state->margin.left + state->margin.right;
+                } else if ((state->anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT)) {
+                        box.x += state->margin.left;
+                } else if ((state->anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT)) {
+                        box.x -= state->margin.right;
+                }
+                if ((state->anchor & both_vert) == both_vert) {
+                        box.y += state->margin.top;
+                        box.height -= state->margin.top + state->margin.bottom;
+                } else if ((state->anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP)) {
+                        box.y += state->margin.top;
+                } else if ((state->anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM)) {
+                        box.y -= state->margin.bottom;
+                }
+                if (box.width < 0 || box.height < 0) {
+                        wlr_layer_surface_v1_close(wlr_layer_surface);
+                        continue;
+                }
+                layersurface->geo = box;
+
+                if (state->exclusive_zone > 0)
+                        applyexclusive(usable_area, state->anchor, state->exclusive_zone,
+                                       state->margin.top, state->margin.right,
+                                       state->margin.bottom, state->margin.left);
+                wlr_layer_surface_v1_configure(wlr_layer_surface, box.width, box.height);
+        }
 }
 
 void
 arrangelayers(Monitor *m)
 {
-	struct wlr_box usable_area = m->m;
-	uint32_t layers_above_shell[] = {
-		ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY,
-		ZWLR_LAYER_SHELL_V1_LAYER_TOP,
-	};
-	LayerSurface *layersurface;
-	struct wlr_keyboard *kb = wlr_seat_get_keyboard(seat);
-
-	// Arrange exclusive surfaces from top->bottom
-	arrangelayer(m, &m->layers[ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY],
-			&usable_area, 1);
-	arrangelayer(m, &m->layers[ZWLR_LAYER_SHELL_V1_LAYER_TOP],
-			&usable_area, 1);
-	arrangelayer(m, &m->layers[ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM],
-			&usable_area, 1);
-	arrangelayer(m, &m->layers[ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND],
-			&usable_area, 1);
-
-	if (memcmp(&usable_area, &m->w, sizeof(struct wlr_box))) {
-		m->w = usable_area;
-		arrange(m);
-	}
-
-	// Arrange non-exlusive surfaces from top->bottom
-	arrangelayer(m, &m->layers[ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY],
-			&usable_area, 0);
-	arrangelayer(m, &m->layers[ZWLR_LAYER_SHELL_V1_LAYER_TOP],
-			&usable_area, 0);
-	arrangelayer(m, &m->layers[ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM],
-			&usable_area, 0);
-	arrangelayer(m, &m->layers[ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND],
-			&usable_area, 0);
-
-	// Find topmost keyboard interactive layer, if such a layer exists
-	for (size_t i = 0; i < LENGTH(layers_above_shell); i++) {
-		wl_list_for_each_reverse(layersurface,
-				&m->layers[layers_above_shell[i]], link) {
-			if (layersurface->layer_surface->current.keyboard_interactive &&
-					layersurface->layer_surface->mapped) {
-				// Deactivate the focused client.
-				focusclient(NULL, 0);
-				wlr_seat_keyboard_notify_enter(seat, layersurface->layer_surface->surface,
-						kb->keycodes, kb->num_keycodes, &kb->modifiers);
-				return;
-			}
-		}
-	}
+        struct wlr_box usable_area = m->m;
+        uint32_t layers_above_shell[] = {
+                ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY,
+                ZWLR_LAYER_SHELL_V1_LAYER_TOP,
+        };
+        LayerSurface *layersurface;
+        struct wlr_keyboard *kb = wlr_seat_get_keyboard(seat);
+
+        // Arrange exclusive surfaces from top->bottom
+        arrangelayer(m, &m->layers[ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY],
+                     &usable_area, 1);
+        arrangelayer(m, &m->layers[ZWLR_LAYER_SHELL_V1_LAYER_TOP],
+                     &usable_area, 1);
+        arrangelayer(m, &m->layers[ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM],
+                     &usable_area, 1);
+        arrangelayer(m, &m->layers[ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND],
+                     &usable_area, 1);
+
+        if (memcmp(&usable_area, &m->w, sizeof(struct wlr_box))) {
+                m->w = usable_area;
+                arrange(m);
+        }
+
+        // Arrange non-exlusive surfaces from top->bottom
+        arrangelayer(m, &m->layers[ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY],
+                     &usable_area, 0);
+        arrangelayer(m, &m->layers[ZWLR_LAYER_SHELL_V1_LAYER_TOP],
+                     &usable_area, 0);
+        arrangelayer(m, &m->layers[ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM],
+                     &usable_area, 0);
+        arrangelayer(m, &m->layers[ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND],
+                     &usable_area, 0);
+
+        // Find topmost keyboard interactive layer, if such a layer exists
+        for (size_t i = 0; i < LENGTH(layers_above_shell); i++) {
+                wl_list_for_each_reverse(layersurface,
+                                         &m->layers[layers_above_shell[i]], link) {
+                        if (layersurface->layer_surface->current.keyboard_interactive &&
+                            layersurface->layer_surface->mapped) {
+                                // Deactivate the focused client.
+                                focusclient(NULL, 0);
+                                wlr_seat_keyboard_notify_enter(
+                                        seat, layersurface->layer_surface->surface,
+                                        kb->keycodes, kb->num_keycodes, &kb->modifiers);
+                                return;
+                        }
+                }
+        }
 }
 
 void
 axisnotify(struct wl_listener *listener, void *data)
 {
-	/* This event is forwarded by the cursor when a pointer emits an axis event,
-	 * for example when you move the scroll wheel. */
-	struct wlr_event_pointer_axis *event = data;
-	wlr_idle_notify_activity(idle, seat);
-	/* Notify the client with pointer focus of the axis event. */
-	wlr_seat_pointer_notify_axis(seat,
-			event->time_msec, event->orientation, event->delta,
-			event->delta_discrete, event->source);
+        /* This event is forwarded by the cursor when a pointer emits an axis event,
+         * for example when you move the scroll wheel. */
+        struct wlr_event_pointer_axis *event = data;
+        wlr_idle_notify_activity(idle, seat);
+        /* Notify the client with pointer focus of the axis event. */
+        wlr_seat_pointer_notify_axis(seat,
+                                     event->time_msec, event->orientation, event->delta,
+                                     event->delta_discrete, event->source);
 }
 
 void
 buttonpress(struct wl_listener *listener, void *data)
 {
-	struct wlr_event_pointer_button *event = data;
-	struct wlr_keyboard *keyboard;
-	uint32_t mods;
-	Client *c;
-	const Button *b;
-
-	wlr_idle_notify_activity(idle, seat);
-
-	switch (event->state) {
-	case WLR_BUTTON_PRESSED:;
-		/* Change focus if the button was _pressed_ over a client */
-		if ((c = xytoclient(cursor->x, cursor->y)))
-			focusclient(c, 1);
-
-		keyboard = wlr_seat_get_keyboard(seat);
-		mods = wlr_keyboard_get_modifiers(keyboard);
-		for (b = buttons; b < END(buttons); b++) {
-			if (CLEANMASK(mods) == CLEANMASK(b->mod) &&
-					event->button == b->button && b->func) {
-				b->func(&b->arg);
-				return;
-			}
-		}
-		break;
-	case WLR_BUTTON_RELEASED:
-		/* If you released any buttons, we exit interactive move/resize mode. */
-		/* TODO should reset to the pointer focus's current setcursor */
-		if (cursor_mode != CurNormal) {
-			wlr_xcursor_manager_set_cursor_image(cursor_mgr,
-					"left_ptr", cursor);
-			cursor_mode = CurNormal;
-			/* Drop the window off on its new monitor */
-			selmon = xytomon(cursor->x, cursor->y);
-			setmon(grabc, selmon, 0);
-			return;
-		}
-		break;
-	}
-	/* If the event wasn't handled by the compositor, notify the client with
-	 * pointer focus that a button press has occurred */
-	wlr_seat_pointer_notify_button(seat,
-			event->time_msec, event->button, event->state);
+        struct wlr_event_pointer_button *event = data;
+        struct wlr_keyboard *keyboard;
+        uint32_t mods;
+        Client *c;
+        Button b;
+
+        wlr_idle_notify_activity(idle, seat);
+
+        switch (event->state) {
+        case WLR_BUTTON_PRESSED:;
+                /* Change focus if the button was _pressed_ over a client */
+                if ((c = xytoclient(cursor->x, cursor->y)))
+                        focusclient(c, 1);
+
+                keyboard = wlr_seat_get_keyboard(seat);
+                mods = wlr_keyboard_get_modifiers(keyboard);
+                for (int i = 0; i < numbuttons; i++) {
+                        b = buttons[i];
+                        if (CLEANMASK(mods) == CLEANMASK(b.mod) &&
+                            event->button == b.button && b.func) {
+                                dscm_safe_call(DSCM_CALL_ACTION, b.func, NULL);
+                                return;
+                        }
+                }
+                break;
+        case WLR_BUTTON_RELEASED:
+                /* If you released any buttons, we exit interactive move/resize mode. */
+                /* TODO should reset to the pointer focus's current setcursor */
+                if (cursor_mode != CurNormal) {
+                        wlr_xcursor_manager_set_cursor_image(cursor_mgr,
+                                                             "left_ptr", cursor);
+                        cursor_mode = CurNormal;
+                        /* Drop the window off on its new monitor */
+                        selmon = xytomon(cursor->x, cursor->y);
+                        setmon(grabc, selmon, 0);
+                        return;
+                }
+                break;
+        }
+        /* If the event wasn't handled by the compositor, notify the client with
+         * pointer focus that a button press has occurred */
+        wlr_seat_pointer_notify_button(seat,
+                                       event->time_msec, event->button, event->state);
+}
+
+void
+changealpha(const Arg *arg)
+{
+        Client *sel = selclient();
+
+        if (sel) {
+                sel->alpha += arg->f;
+                if (sel->alpha > 1.0)
+                        sel->alpha = 1.0;
+
+                if (sel->alpha < 0.1)
+                        sel->alpha = 0.1;
+        }
 }
 
 void
 chvt(const Arg *arg)
 {
-	wlr_session_change_vt(wlr_backend_get_session(backend), arg->ui);
+        wlr_session_change_vt(wlr_backend_get_session(backend), arg->ui);
 }
 
 void
 cleanup(void)
 {
 #ifdef XWAYLAND
-	wlr_xwayland_destroy(xwayland);
+        wlr_xwayland_destroy(xwayland);
 #endif
-	wl_display_destroy_clients(dpy);
+        wl_display_destroy_clients(dpy);
 
-	wlr_backend_destroy(backend);
-	wlr_xcursor_manager_destroy(cursor_mgr);
-	wlr_cursor_destroy(cursor);
-	wlr_output_layout_destroy(output_layout);
-	wlr_seat_destroy(seat);
-	wl_display_destroy(dpy);
+        wlr_backend_destroy(backend);
+        wlr_xcursor_manager_destroy(cursor_mgr);
+        wlr_cursor_destroy(cursor);
+        wlr_output_layout_destroy(output_layout);
+        wlr_seat_destroy(seat);
+        wl_display_destroy(dpy);
 }
 
 void
 cleanupkeyboard(struct wl_listener *listener, void *data)
 {
-	struct wlr_input_device *device = data;
-	Keyboard *kb = device->data;
+        struct wlr_input_device *device = data;
+        Keyboard *kb = device->data;
 
-	wl_list_remove(&kb->link);
-	wl_list_remove(&kb->modifiers.link);
-	wl_list_remove(&kb->key.link);
-	wl_list_remove(&kb->destroy.link);
-	free(kb);
+        wl_list_remove(&kb->link);
+        wl_list_remove(&kb->modifiers.link);
+        wl_list_remove(&kb->key.link);
+        wl_list_remove(&kb->destroy.link);
+        free(kb);
 }
 
 void
 cleanupmon(struct wl_listener *listener, void *data)
 {
-	struct wlr_output *wlr_output = data;
-	Monitor *m = wlr_output->data;
-	int nmons, i = 0;
+        struct wlr_output *wlr_output = data;
+        DscmMonitor *mon, *montmp;
+        Monitor *m = wlr_output->data;
+        int nmons, i = 0;
+
+        wl_list_remove(&m->destroy.link);
+        wl_list_remove(&m->frame.link);
+        wl_list_remove(&m->link);
+        wlr_output_layout_remove(output_layout, m->wlr_output);
+        wl_list_for_each_safe(mon, montmp, &m->dscm, link) {
+                wl_resource_set_user_data(mon->resource, NULL);
+                free(mon);
+        }
 
-	wl_list_remove(&m->destroy.link);
-	wl_list_remove(&m->frame.link);
-	wl_list_remove(&m->link);
-	wlr_output_layout_remove(output_layout, m->wlr_output);
+        // Fix crash when disconnecting the last monitor
+        if ((nmons = wl_list_length(&mons))) {
+                do // don't switch to disabled mons
+                        selmon = wl_container_of(mons.prev, selmon, link);
+                while (!selmon->wlr_output->enabled && i++ < nmons);
+        }
 
-	nmons = wl_list_length(&mons);
-	do // don't switch to disabled mons
-		selmon = wl_container_of(mons.prev, selmon, link);
-	while (!selmon->wlr_output->enabled && i++ < nmons);
-	focusclient(focustop(selmon), 1);
-	closemon(m);
-	free(m);
+        focusclient(focustop(selmon), 1);
+        closemon(m);
+        free(m);
 }
 
 void
 closemon(Monitor *m)
 {
-	// move closed monitor's clients to the focused one
-	Client *c;
+        // move closed monitor's clients to the focused one
+        Client *c;
 
-	wl_list_for_each(c, &clients, link) {
-		if (c->isfloating && c->geom.x > m->m.width)
-			resize(c, c->geom.x - m->w.width, c->geom.y,
-				c->geom.width, c->geom.height, 0);
-		if (c->mon == m)
-			setmon(c, selmon, c->tags);
-	}
+        wl_list_for_each(c, &clients, link) {
+                if (c->isfloating && c->geom.x > m->m.width)
+                        resize(c, c->geom.x - m->w.width, c->geom.y,
+                               c->geom.width, c->geom.height, 0, 1);
+                if (c->mon == m)
+                        setmon(c, selmon, c->tags);
+        }
 }
 
 void
 commitlayersurfacenotify(struct wl_listener *listener, void *data)
 {
-	LayerSurface *layersurface = wl_container_of(listener, layersurface, surface_commit);
-	struct wlr_layer_surface_v1 *wlr_layer_surface = layersurface->layer_surface;
-	struct wlr_output *wlr_output = wlr_layer_surface->output;
-	Monitor *m;
+        LayerSurface *layersurface = wl_container_of(listener, layersurface,
+                                                     surface_commit);
+        struct wlr_layer_surface_v1 *wlr_layer_surface = layersurface->layer_surface;
+        struct wlr_output *wlr_output = wlr_layer_surface->output;
+        Monitor *m;
 
-	if (!wlr_output)
-		return;
+        if (!wlr_output)
+                return;
 
-	m = wlr_output->data;
-	arrangelayers(m);
+        m = wlr_output->data;
+        arrangelayers(m);
 
-	if (layersurface->layer != wlr_layer_surface->current.layer) {
-		wl_list_remove(&layersurface->link);
-		wl_list_insert(&m->layers[wlr_layer_surface->current.layer],
-			&layersurface->link);
-		layersurface->layer = wlr_layer_surface->current.layer;
-	}
+        if (layersurface->layer != wlr_layer_surface->current.layer) {
+                wl_list_remove(&layersurface->link);
+                wl_list_insert(&m->layers[wlr_layer_surface->current.layer],
+                               &layersurface->link);
+                layersurface->layer = wlr_layer_surface->current.layer;
+        }
+
+        // Damage the whole screen
+        wlr_output_damage_add_whole(m->damage);
 }
 
 void
 commitnotify(struct wl_listener *listener, void *data)
 {
-	Client *c = wl_container_of(listener, c, commit);
+        Client *c = wl_container_of(listener, c, commit);
+
+        /* mark a pending resize as completed */
+        if (c->resize && c->resize <= c->surface.xdg->configure_serial)
+                c->resize = 0;
+
+        // Damage the whole screen
+        if (c->mon)
+                wlr_output_damage_add_whole(c->mon->damage);
+}
 
-	/* mark a pending resize as completed */
-	if (c->resize && c->resize <= c->surface.xdg->configure_serial)
-		c->resize = 0;
+void
+commitnotify_sub(struct wl_listener *listener, void *data)
+{
+        Subsurface *s = wl_container_of(listener, s, commit);
+        if (s->c->mon)
+                wlr_output_damage_add_whole(s->c->mon->damage);
+}
+
+void
+createidleinhibitor(struct wl_listener *listener, void *data)
+{
+        struct wlr_idle_inhibitor_v1 *idle_inhibitor = data;
+        wl_signal_add(&idle_inhibitor->events.destroy, &destroy_idle_inhibitor);
+
+        wlr_idle_set_enabled(idle, seat, 0);
 }
 
 void
 createkeyboard(struct wlr_input_device *device)
 {
-	struct xkb_context *context;
-	struct xkb_keymap *keymap;
-	Keyboard *kb = device->data = calloc(1, sizeof(*kb));
-	kb->device = device;
+        struct xkb_context *context;
+        struct xkb_keymap *keymap;
+        Keyboard *kb = device->data = calloc(1, sizeof(*kb));
+        kb->device = device;
 
-	/* Prepare an XKB keymap and assign it to the keyboard. */
-	context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
-	keymap = xkb_map_new_from_names(context, &xkb_rules,
-		XKB_KEYMAP_COMPILE_NO_FLAGS);
+        /* Prepare an XKB keymap and assign it to the keyboard. */
+        context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
+        keymap = xkb_keymap_new_from_names(context, xkb_rules,
+                                           XKB_KEYMAP_COMPILE_NO_FLAGS);
 
-	wlr_keyboard_set_keymap(device->keyboard, keymap);
-	xkb_keymap_unref(keymap);
-	xkb_context_unref(context);
-	wlr_keyboard_set_repeat_info(device->keyboard, repeat_rate, repeat_delay);
+        wlr_keyboard_set_keymap(device->keyboard, keymap);
+        xkb_keymap_unref(keymap);
+        xkb_context_unref(context);
+        wlr_keyboard_set_repeat_info(device->keyboard, repeat_rate, repeat_delay);
 
-	/* Here we set up listeners for keyboard events. */
-	LISTEN(&device->keyboard->events.modifiers, &kb->modifiers, keypressmod);
-	LISTEN(&device->keyboard->events.key, &kb->key, keypress);
-	LISTEN(&device->events.destroy, &kb->destroy, cleanupkeyboard);
+        /* Here we set up listeners for keyboard events. */
+        LISTEN(&device->keyboard->events.modifiers, &kb->modifiers, keypressmod);
+        LISTEN(&device->keyboard->events.key, &kb->key, keypress);
+        LISTEN(&device->events.destroy, &kb->destroy, cleanupkeyboard);
 
-	wlr_seat_set_keyboard(seat, device);
+        wlr_seat_set_keyboard(seat, device);
 
-	/* And add the keyboard to our list of keyboards */
-	wl_list_insert(&keyboards, &kb->link);
+        /* And add the keyboard to our list of keyboards */
+        wl_list_insert(&keyboards, &kb->link);
 }
 
 void
 createmon(struct wl_listener *listener, void *data)
 {
-	/* This event is raised by the backend when a new output (aka a display or
-	 * monitor) becomes available. */
-	struct wlr_output *wlr_output = data;
-	const MonitorRule *r;
-	Monitor *m = wlr_output->data = calloc(1, sizeof(*m));
-	m->wlr_output = wlr_output;
-
-	/* Initialize monitor state using configured rules */
-	for (size_t i = 0; i < LENGTH(m->layers); i++)
-		wl_list_init(&m->layers[i]);
-	m->tagset[0] = m->tagset[1] = 1;
-	for (r = monrules; r < END(monrules); r++) {
-		if (!r->name || strstr(wlr_output->name, r->name)) {
-			m->mfact = r->mfact;
-			m->nmaster = r->nmaster;
-			wlr_output_set_scale(wlr_output, r->scale);
-			wlr_xcursor_manager_load(cursor_mgr, r->scale);
-			m->lt[0] = m->lt[1] = r->lt;
-			wlr_output_set_transform(wlr_output, r->rr);
-			break;
-		}
-	}
-
-	/* The mode is a tuple of (width, height, refresh rate), and each
-	 * monitor supports only a specific set of modes. We just pick the
-	 * monitor's preferred mode; a more sophisticated compositor would let
-	 * the user configure it. */
-	wlr_output_set_mode(wlr_output, wlr_output_preferred_mode(wlr_output));
-	wlr_output_enable_adaptive_sync(wlr_output, 1);
-
-	/* Set up event listeners */
-	LISTEN(&wlr_output->events.frame, &m->frame, rendermon);
-	LISTEN(&wlr_output->events.destroy, &m->destroy, cleanupmon);
-
-	wl_list_insert(&mons, &m->link);
-	wlr_output_enable(wlr_output, 1);
-	if (!wlr_output_commit(wlr_output))
-		return;
-
-	/* Adds this to the output layout in the order it was configured in.
-	 *
-	 * The output layout utility automatically adds a wl_output global to the
-	 * display, which Wayland clients can see to find out information about the
-	 * output (such as DPI, scale factor, manufacturer, etc).
-	 */
-	wlr_output_layout_add(output_layout, wlr_output, r->x, r->y);
-	sgeom = *wlr_output_layout_get_box(output_layout, NULL);
-
-	/* When adding monitors, the geometries of all monitors must be updated */
-	wl_list_for_each(m, &mons, link) {
-		/* The first monitor in the list is the most recently added */
-		Client *c;
-		wl_list_for_each(c, &clients, link) {
-			if (c->isfloating)
-				resize(c, c->geom.x + m->w.width, c->geom.y,
-						c->geom.width, c->geom.height, 0);
-		}
-		return;
-	}
+        /* This event is raised by the backend when a new output (aka a display or
+         * monitor) becomes available. */
+        struct wlr_output *wlr_output = data;
+        MonitorRule r;
+        Monitor *m = wlr_output->data = calloc(1, sizeof(*m));
+        wl_list_init(&m->dscm);
+        m->wlr_output = wlr_output;
+        m->gappih = gappih;
+        m->gappiv = gappiv;
+        m->gappoh = gappoh;
+        m->gappov = gappov;
+
+        /* Initialize monitor state using configured rules */
+        for (size_t i = 0; i < LENGTH(m->layers); i++)
+                wl_list_init(&m->layers[i]);
+        m->damage = wlr_output_damage_create(wlr_output);
+        m->tagset[0] = m->tagset[1] = 1;
+        for (int i = 0; i < nummonrules; i++) {
+                r = monrules[i];
+                if (!r.name || strstr(wlr_output->name, r.name)) {
+                        m->mfact = r.mfact;
+                        m->nmaster = r.nmaster;
+                        wlr_output_set_scale(wlr_output, r.scale);
+                        wlr_xcursor_manager_load(cursor_mgr, r.scale);
+                        m->lt[0] = m->lt[1] = r.lt;
+                        wlr_output_set_transform(wlr_output, r.rr);
+                        break;
+                }
+        }
+
+        /* The mode is a tuple of (width, height, refresh rate), and each
+         * monitor supports only a specific set of modes. We just pick the
+         * monitor's preferred mode; a more sophisticated compositor would let
+         * the user configure it. */
+        wlr_output_set_mode(wlr_output, wlr_output_preferred_mode(wlr_output));
+        wlr_output_enable_adaptive_sync(wlr_output, 1);
+
+        /* Set up event listeners */
+        LISTEN(&wlr_output->events.frame, &m->frame, rendermon);
+        LISTEN(&wlr_output->events.destroy, &m->destroy, cleanupmon);
+
+        wlr_output_enable(wlr_output, 1);
+        if (!wlr_output_commit(wlr_output))
+                return;
+
+        wl_list_insert(&mons, &m->link);
+        printstatus();
+
+        /* Adds this to the output layout in the order it was configured in.
+         *
+         * The output layout utility automatically adds a wl_output global to the
+         * display, which Wayland clients can see to find out information about the
+         * output (such as DPI, scale factor, manufacturer, etc).
+         */
+        wlr_output_layout_add(output_layout, wlr_output, r.x, r.y);
+        sgeom = *wlr_output_layout_get_box(output_layout, NULL);
+
+        /* When adding monitors, the geometries of all monitors must be updated */
+        wl_list_for_each(m, &mons, link) {
+                /* The first monitor in the list is the most recently added */
+                Client *c;
+                wl_list_for_each(c, &clients, link) {
+                        if (c->isfloating)
+                                resize(c, c->geom.x + m->w.width, c->geom.y,
+                                       c->geom.width, c->geom.height, 0, 1);
+                }
+                return;
+        }
 }
 
 void
 createnotify(struct wl_listener *listener, void *data)
 {
-	/* This event is raised when wlr_xdg_shell receives a new xdg surface from a
-	 * client, either a toplevel (application window) or popup. */
-	struct wlr_xdg_surface *xdg_surface = data;
-	Client *c;
-
-	if (xdg_surface->role != WLR_XDG_SURFACE_ROLE_TOPLEVEL)
-		return;
-
-	/* Allocate a Client for this surface */
-	c = xdg_surface->data = calloc(1, sizeof(*c));
-	c->surface.xdg = xdg_surface;
-	c->bw = borderpx;
-
-	/* Tell the client not to try anything fancy */
-	wlr_xdg_toplevel_set_tiled(c->surface.xdg, WLR_EDGE_TOP |
-			WLR_EDGE_BOTTOM | WLR_EDGE_LEFT | WLR_EDGE_RIGHT);
-
-	LISTEN(&xdg_surface->surface->events.commit, &c->commit, commitnotify);
-	LISTEN(&xdg_surface->events.map, &c->map, mapnotify);
-	LISTEN(&xdg_surface->events.unmap, &c->unmap, unmapnotify);
-	LISTEN(&xdg_surface->events.destroy, &c->destroy, destroynotify);
-	LISTEN(&xdg_surface->toplevel->events.request_fullscreen, &c->fullscreen,
-			fullscreennotify);
-	c->isfullscreen = 0;
+        /* This event is raised when wlr_xdg_shell receives a new xdg surface from a
+         * client, either a toplevel (application window) or popup. */
+        struct wlr_xdg_surface *xdg_surface = data;
+        Client *c;
+
+        if (xdg_surface->role != WLR_XDG_SURFACE_ROLE_TOPLEVEL) {
+                c = selclient();
+                if (c) {
+                        struct wlr_box constraint = {
+                                .x = 0,
+                                .y = 0,
+                                .width = c->geom.width,
+                                .height = c->geom.height,
+                        };
+                        wlr_xdg_popup_unconstrain_from_box(xdg_surface->popup,
+                                                           &constraint);
+                }
+                return;
+        }
+
+        /* Allocate a Client for this surface */
+        c = xdg_surface->data = calloc(1, sizeof(*c));
+        c->surface.xdg = xdg_surface;
+        c->bw = borderpx;
+        c->alpha = default_alpha;
+
+        /* LISTEN(&xdg_surface->surface->events.commit, &c->commit, commitnotify); */
+        LISTEN(&xdg_surface->surface->events.new_subsurface, &c->new_sub, new_subnotify);
+        LISTEN(&xdg_surface->events.map, &c->map, mapnotify);
+        LISTEN(&xdg_surface->events.unmap, &c->unmap, unmapnotify);
+        LISTEN(&xdg_surface->events.destroy, &c->destroy, destroynotify);
+        LISTEN(&xdg_surface->toplevel->events.set_title, &c->set_title, updatetitle);
+        LISTEN(&xdg_surface->toplevel->events.request_fullscreen, &c->fullscreen,
+               fullscreennotify);
+        c->isfullscreen = 0;
 }
 
 void
 createlayersurface(struct wl_listener *listener, void *data)
 {
-	struct wlr_layer_surface_v1 *wlr_layer_surface = data;
-	LayerSurface *layersurface;
-	Monitor *m;
-	struct wlr_layer_surface_v1_state old_state;
+        struct wlr_layer_surface_v1 *wlr_layer_surface = data;
+        LayerSurface *layersurface;
+        Monitor *m;
+        struct wlr_layer_surface_v1_state old_state;
 
-	if (!wlr_layer_surface->output) {
-		wlr_layer_surface->output = selmon->wlr_output;
-	}
+        if (!wlr_layer_surface->output) {
+                wlr_layer_surface->output = selmon->wlr_output;
+        }
 
-	layersurface = calloc(1, sizeof(LayerSurface));
-	LISTEN(&wlr_layer_surface->surface->events.commit,
-		&layersurface->surface_commit, commitlayersurfacenotify);
-	LISTEN(&wlr_layer_surface->events.destroy, &layersurface->destroy,
-			destroylayersurfacenotify);
-	LISTEN(&wlr_layer_surface->events.map, &layersurface->map,
-			maplayersurfacenotify);
-	LISTEN(&wlr_layer_surface->events.unmap, &layersurface->unmap,
-			unmaplayersurfacenotify);
+        layersurface = calloc(1, sizeof(LayerSurface));
+        LISTEN(&wlr_layer_surface->surface->events.commit,
+               &layersurface->surface_commit, commitlayersurfacenotify);
+        LISTEN(&wlr_layer_surface->events.destroy, &layersurface->destroy,
+               destroylayersurfacenotify);
+        LISTEN(&wlr_layer_surface->events.map, &layersurface->map,
+               maplayersurfacenotify);
+        LISTEN(&wlr_layer_surface->events.unmap, &layersurface->unmap,
+               unmaplayersurfacenotify);
 
-	layersurface->layer_surface = wlr_layer_surface;
-	wlr_layer_surface->data = layersurface;
+        layersurface->layer_surface = wlr_layer_surface;
+        wlr_layer_surface->data = layersurface;
 
-	m = wlr_layer_surface->output->data;
-	wl_list_insert(&m->layers[wlr_layer_surface->client_pending.layer],
-			&layersurface->link);
+        m = wlr_layer_surface->output->data;
+        wl_list_insert(&m->layers[wlr_layer_surface->client_pending.layer],
+                       &layersurface->link);
 
-	// Temporarily set the layer's current state to client_pending
-	// so that we can easily arrange it
-	old_state = wlr_layer_surface->current;
-	wlr_layer_surface->current = wlr_layer_surface->client_pending;
-	arrangelayers(m);
-	wlr_layer_surface->current = old_state;
+        // Temporarily set the layer's current state to client_pending
+        // so that we can easily arrange it
+        old_state = wlr_layer_surface->current;
+        wlr_layer_surface->current = wlr_layer_surface->client_pending;
+        arrangelayers(m);
+        wlr_layer_surface->current = old_state;
 }
 
 void
 createpointer(struct wlr_input_device *device)
 {
-	if (wlr_input_device_is_libinput(device)) {
-		struct libinput_device *libinput_device =  (struct libinput_device*)
-			wlr_libinput_get_device_handle(device);
+        if (wlr_input_device_is_libinput(device)) {
+                struct libinput_device *libinput_device =  (struct libinput_device*)
+                        wlr_libinput_get_device_handle(device);
 
-		if (tap_to_click && libinput_device_config_tap_get_finger_count(libinput_device))
-			libinput_device_config_tap_set_enabled(libinput_device, LIBINPUT_CONFIG_TAP_ENABLED);
+                if (tap_to_click &&
+                    libinput_device_config_tap_get_finger_count(libinput_device))
+                        libinput_device_config_tap_set_enabled(
+                                libinput_device, LIBINPUT_CONFIG_TAP_ENABLED);
 
-		if (libinput_device_config_scroll_has_natural_scroll(libinput_device))
-			libinput_device_config_scroll_set_natural_scroll_enabled(libinput_device, natural_scrolling);
-	}
+                if (libinput_device_config_scroll_has_natural_scroll(libinput_device))
+                        libinput_device_config_scroll_set_natural_scroll_enabled(
+                                libinput_device, natural_scrolling);
+        }
 
-	/* We don't do anything special with pointers. All of our pointer handling
-	 * is proxied through wlr_cursor. On another compositor, you might take this
-	 * opportunity to do libinput configuration on the device to set
-	 * acceleration, etc. */
-	wlr_cursor_attach_input_device(cursor, device);
+        /* We don't do anything special with pointers. All of our pointer handling
+         * is proxied through wlr_cursor. On another compositor, you might take this
+         * opportunity to do libinput configuration on the device to set
+         * acceleration, etc. */
+        wlr_cursor_attach_input_device(cursor, device);
 }
 
 void
-createxdeco(struct wl_listener *listener, void *data)
+cursorframe(struct wl_listener *listener, void *data)
 {
-	struct wlr_xdg_toplevel_decoration_v1 *wlr_deco = data;
-	Decoration *d = wlr_deco->data = calloc(1, sizeof(*d));
-
-	LISTEN(&wlr_deco->events.request_mode, &d->request_mode, getxdecomode);
-	LISTEN(&wlr_deco->events.destroy, &d->destroy, destroyxdeco);
+        /* This event is forwarded by the cursor when a pointer emits an frame
+         * event. Frame events are sent after regular pointer events to group
+         * multiple events together. For instance, two axis events may happen at the
+         * same time, in which case a frame event won't be sent in between. */
+        /* Notify the client with pointer focus of the frame event. */
+        wlr_seat_pointer_notify_frame(seat);
+}
 
-	getxdecomode(&d->request_mode, wlr_deco);
+void
+cyclelayout(const Arg *arg)
+{
+        Layout *l;
+        unsigned int index = 0;
+        for (l = (Layout *)layouts; l != selmon->lt[selmon->sellt]; l++, index++);
+        if (arg->i > 0) {
+                if (index < (numlayouts - 1))
+                        setlayout(&((Arg) {.v = (l + 1)}));
+                else
+                        setlayout(&((Arg) {.v = layouts}));
+        } else {
+                if (index > 0)
+                        setlayout(&((Arg) {.v = (l - 1)}));
+                else
+                        setlayout(&((Arg) {.v = &layouts[numlayouts - 1]}));
+        }
 }
 
 void
-cursorframe(struct wl_listener *listener, void *data)
+destroyidleinhibitor(struct wl_listener *listener, void *data)
 {
-	/* This event is forwarded by the cursor when a pointer emits an frame
-	 * event. Frame events are sent after regular pointer events to group
-	 * multiple events together. For instance, two axis events may happen at the
-	 * same time, in which case a frame event won't be sent in between. */
-	/* Notify the client with pointer focus of the frame event. */
-	wlr_seat_pointer_notify_frame(seat);
+        /* I've been testing and at this point the inhibitor has not yet been
+         * removed from the list, checking if it has at least one item. */
+        wlr_idle_set_enabled(idle, seat, wl_list_length(&idle_inhibit_mgr->inhibitors) <= 1);
 }
 
 void
 destroylayersurfacenotify(struct wl_listener *listener, void *data)
 {
-	LayerSurface *layersurface = wl_container_of(listener, layersurface, destroy);
+        LayerSurface *layersurface = wl_container_of(listener, layersurface, destroy);
 
-	if (layersurface->layer_surface->mapped)
-		unmaplayersurface(layersurface);
-	wl_list_remove(&layersurface->link);
-	wl_list_remove(&layersurface->destroy.link);
-	wl_list_remove(&layersurface->map.link);
-	wl_list_remove(&layersurface->unmap.link);
-	wl_list_remove(&layersurface->surface_commit.link);
-	if (layersurface->layer_surface->output) {
-		Monitor *m = layersurface->layer_surface->output->data;
-		if (m)
-			arrangelayers(m);
-		layersurface->layer_surface->output = NULL;
-	}
-	free(layersurface);
+        if (layersurface->layer_surface->mapped)
+                unmaplayersurface(layersurface);
+        wl_list_remove(&layersurface->link);
+        wl_list_remove(&layersurface->destroy.link);
+        wl_list_remove(&layersurface->map.link);
+        wl_list_remove(&layersurface->unmap.link);
+        wl_list_remove(&layersurface->surface_commit.link);
+        if (layersurface->layer_surface->output) {
+                Monitor *m = layersurface->layer_surface->output->data;
+                if (m) {
+                        arrangelayers(m);
+                        wlr_output_damage_add_whole(m->damage);
+                }
+                layersurface->layer_surface->output = NULL;
+        }
+        free(layersurface);
 }
 
 void
 destroynotify(struct wl_listener *listener, void *data)
 {
-	/* Called when the surface is destroyed and should never be shown again. */
-	Client *c = wl_container_of(listener, c, destroy);
-	wl_list_remove(&c->map.link);
-	wl_list_remove(&c->unmap.link);
-	wl_list_remove(&c->destroy.link);
-	wl_list_remove(&c->fullscreen.link);
+        /* Called when the surface is destroyed and should never be shown again. */
+        Client *c = wl_container_of(listener, c, destroy);
+
+        // Damage the whole screen
+        if (c->mon)
+                wlr_output_damage_add_whole(c->mon->damage);
+
+        wl_list_remove(&c->map.link);
+        wl_list_remove(&c->unmap.link);
+        wl_list_remove(&c->destroy.link);
+        if (client_is_unmanaged(c)) {
 #ifdef XWAYLAND
-	if (c->type == X11Managed)
-		wl_list_remove(&c->activate.link);
-	else if (c->type == XDGShell)
+                wl_list_remove(&c->configure.link);
+                free(c);
+                return;
+        } else if (c->type == X11Managed) {
+                wl_list_remove(&c->activate.link);
+                wl_list_remove(&c->configure.link);
 #endif
-		wl_list_remove(&c->commit.link);
-	free(c);
+        } else {
+                wl_list_remove(&c->commit.link);
+        }
+        wl_list_remove(&c->set_title.link);
+        wl_list_remove(&c->fullscreen.link);
+        free(c);
 }
 
 void
-destroyxdeco(struct wl_listener *listener, void *data)
+destroynotify_sub(struct wl_listener *listener, void *data)
 {
-	struct wlr_xdg_toplevel_decoration_v1 *wlr_deco = data;
-	Decoration *d = wlr_deco->data;
-
-	wl_list_remove(&d->destroy.link);
-	wl_list_remove(&d->request_mode.link);
-	free(d);
+        Subsurface *s = wl_container_of(listener, s, destroy);
+        wl_list_remove(&s->commit.link);
+        wl_list_remove(&s->map.link);
+        wl_list_remove(&s->unmap.link);
+        wl_list_remove(&s->destroy.link);
+        free(s);
 }
 
 void
 togglefullscreen(const Arg *arg)
 {
-	Client *sel = selclient();
-	if (sel)
-		setfullscreen(sel, !sel->isfullscreen);
+        Client *sel = selclient();
+        if (sel)
+                setfullscreen(sel, !sel->isfullscreen);
 }
 
 void
 setfullscreen(Client *c, int fullscreen)
 {
-	c->isfullscreen = fullscreen;
-	c->bw = (1 - fullscreen) * borderpx;
-	client_set_fullscreen(c, fullscreen);
-
-	if (fullscreen) {
-		c->prevx = c->geom.x;
-		c->prevy = c->geom.y;
-		c->prevheight = c->geom.height;
-		c->prevwidth = c->geom.width;
-		resize(c, c->mon->m.x, c->mon->m.y, c->mon->m.width, c->mon->m.height, 0);
-	} else {
-		/* restore previous size instead of arrange for floating windows since
-		 * client positions are set by the user and cannot be recalculated */
-		resize(c, c->prevx, c->prevy, c->prevwidth, c->prevheight, 0);
-		arrange(c->mon);
-	}
+        c->isfullscreen = fullscreen;
+        c->bw = (1 - fullscreen) * borderpx;
+        client_set_fullscreen(c, fullscreen);
+
+        if (fullscreen) {
+                c->prevx = c->geom.x;
+                c->prevy = c->geom.y;
+                c->prevheight = c->geom.height;
+                c->prevwidth = c->geom.width;
+                c->prevalpha = c->alpha;
+                c->alpha = 1;
+                resize(c, c->mon->m.x, c->mon->m.y, c->mon->m.width, c->mon->m.height, 0,
+                       !smartborders);
+                wl_list_remove(&c->slink);
+                wl_list_insert(&stack, &c->slink);
+                motionnotify(0);
+        } else {
+                /* restore previous size instead of arrange for floating windows since
+                 * client positions are set by the user and cannot be recalculated */
+                c->alpha = c->prevalpha;
+                resize(c, c->prevx, c->prevy, c->prevwidth, c->prevheight, 0, 1);
+                if (!c->isfloating) {
+                        wl_list_remove(&c->slink);
+                        wl_list_insert(stack.prev, &c->slink);
+                }
+                arrange(c->mon);
+        }
 }
 
 void
 fullscreennotify(struct wl_listener *listener, void *data)
 {
-	Client *c = wl_container_of(listener, c, fullscreen);
-	setfullscreen(c, !c->isfullscreen);
+        Client *c = wl_container_of(listener, c, fullscreen);
+        struct wlr_xdg_toplevel_set_fullscreen_event *event = data;
+        if (!c->mon) {
+                /* if the client is not mapped yet, let mapnotify() call setfullscreen() */
+                c->isfullscreen = event->fullscreen;
+                return;
+        }
+        setfullscreen(c, event->fullscreen);
 }
 
 Monitor *
 dirtomon(enum wlr_direction dir)
 {
-	struct wlr_output *next;
-	if ((next = wlr_output_layout_adjacent_output(output_layout,
-			dir, selmon->wlr_output, selmon->m.x, selmon->m.y)))
-		return next->data;
-	if ((next = wlr_output_layout_farthest_output(output_layout,
-			dir ^ (WLR_DIRECTION_LEFT|WLR_DIRECTION_RIGHT),
-			selmon->wlr_output, selmon->m.x, selmon->m.y)))
-		return next->data;
-	return selmon;
+        struct wlr_output *next;
+        if ((next = wlr_output_layout_adjacent_output(
+                     output_layout, dir, selmon->wlr_output, selmon->m.x, selmon->m.y)))
+                return next->data;
+        if ((next = wlr_output_layout_farthest_output(
+                     output_layout, dir ^ (WLR_DIRECTION_LEFT|WLR_DIRECTION_RIGHT),
+                     selmon->wlr_output, selmon->m.x, selmon->m.y)))
+                return next->data;
+        return selmon;
 }
 
 void
 focusclient(Client *c, int lift)
 {
-	struct wlr_surface *old = seat->keyboard_state.focused_surface;
-	struct wlr_keyboard *kb;
-
-	/* Raise client in stacking order if requested */
-	if (c && lift) {
-		wl_list_remove(&c->slink);
-		wl_list_insert(&stack, &c->slink);
-	}
-
-	if (c && client_surface(c) == old)
-		return;
-
-	/* Put the new client atop the focus stack and select its monitor */
-	if (c) {
-		wl_list_remove(&c->flink);
-		wl_list_insert(&fstack, &c->flink);
-		selmon = c->mon;
-	}
-	printstatus();
-
-	/* Deactivate old client if focus is changing */
-	if (old && (!c || client_surface(c) != old)) {
-		/* If an overlay is focused, don't focus or activate the client,
-		 * but only update its position in fstack to render its border with focuscolor
-		 * and focus it after the overlay is closed.
-		 * It's probably pointless to check if old is a layer surface
-		 * since it can't be anything else at this point. */
-		if (wlr_surface_is_layer_surface(old)) {
-			struct wlr_layer_surface_v1 *wlr_layer_surface =
-				wlr_layer_surface_v1_from_wlr_surface(old);
-
-			if (wlr_layer_surface->mapped && (
-						wlr_layer_surface->current.layer == ZWLR_LAYER_SHELL_V1_LAYER_TOP ||
-						wlr_layer_surface->current.layer == ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY
-						))
-				return;
-		} else {
-			client_activate_surface(old, 0);
-		}
-	}
-
-	if (!c) {
-		/* With no client, all we have left is to clear focus */
-		wlr_seat_keyboard_notify_clear_focus(seat);
-		return;
-	}
-
-	/* Have a client, so focus its top-level wlr_surface */
-	kb = wlr_seat_get_keyboard(seat);
-	wlr_seat_keyboard_notify_enter(seat, client_surface(c),
-			kb->keycodes, kb->num_keycodes, &kb->modifiers);
-
-	/* Activate the new client */
-	client_activate_surface(client_surface(c), 1);
+        struct wlr_surface *old = seat->keyboard_state.focused_surface;
+        struct wlr_keyboard *kb;
+
+        /* Raise client in stacking order if requested */
+        if (c && lift && (c->isfloating || c->isfullscreen)) {
+                wl_list_remove(&c->slink);
+                wl_list_insert(&stack, &c->slink);
+        }
+
+        if (c && client_surface(c) == old)
+                return;
+
+        /* Put the new client atop the focus stack and select its monitor */
+        if (c) {
+                wl_list_remove(&c->flink);
+                wl_list_insert(&fstack, &c->flink);
+                selmon = c->mon;
+                c->isurgent = 0;
+        }
+
+        /* Deactivate old client if focus is changing */
+        if (old && (!c || client_surface(c) != old)) {
+                /* If an overlay is focused, don't focus or activate the client,
+                 * but only update its position in fstack to render its border
+                 * with focuscolor and focus it after the overlay is closed.
+                 * It's probably pointless to check if old is a layer surface
+                 * since it can't be anything else at this point. */
+                if (wlr_surface_is_layer_surface(old)) {
+                        struct wlr_layer_surface_v1 *oldsurface =
+                                wlr_layer_surface_v1_from_wlr_surface(old);
+
+                        if (oldsurface->mapped && (
+                                    oldsurface->current.layer == ZWLR_LAYER_SHELL_V1_LAYER_TOP ||
+                                    oldsurface->current.layer == ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY))
+                                return;
+                } else {
+                        client_activate_surface(old, 0);
+                }
+        }
+
+        printstatus();
+
+        if (!c) {
+                /* With no client, all we have left is to clear focus */
+                wlr_seat_keyboard_notify_clear_focus(seat);
+                return;
+        }
+
+        /* Have a client, so focus its top-level wlr_surface */
+        kb = wlr_seat_get_keyboard(seat);
+        wlr_seat_keyboard_notify_enter(seat, client_surface(c),
+                                       kb->keycodes, kb->num_keycodes, &kb->modifiers);
+
+        /* Activate the new client */
+        client_activate_surface(client_surface(c), 1);
 }
 
 void
 focusmon(const Arg *arg)
 {
-	do
-		selmon = dirtomon(arg->i);
-	while (!selmon->wlr_output->enabled);
-	focusclient(focustop(selmon), 1);
+        do
+                selmon = dirtomon(arg->i);
+        while (!selmon->wlr_output->enabled);
+        focusclient(focustop(selmon), 1);
 }
 
 void
 focusstack(const Arg *arg)
 {
-	/* Focus the next or previous client (in tiling order) on selmon */
-	Client *c, *sel = selclient();
-	if (!sel)
-		return;
-	if (arg->i > 0) {
-		wl_list_for_each(c, &sel->link, link) {
-			if (&c->link == &clients)
-				continue;  /* wrap past the sentinel node */
-			if (VISIBLEON(c, selmon))
-				break;  /* found it */
-		}
-	} else {
-		wl_list_for_each_reverse(c, &sel->link, link) {
-			if (&c->link == &clients)
-				continue;  /* wrap past the sentinel node */
-			if (VISIBLEON(c, selmon))
-				break;  /* found it */
-		}
-	}
-	/* If only one client is visible on selmon, then c == sel */
-	focusclient(c, 1);
+        /* Focus the next or previous client (in tiling order) on selmon */
+        Client *c, *sel = selclient();
+        if (!sel || sel->isfullscreen)
+                return;
+        if (arg->i > 0) {
+                wl_list_for_each(c, &sel->link, link) {
+                        if (&c->link == &clients)
+                                continue;  /* wrap past the sentinel node */
+                        if (VISIBLEON(c, selmon))
+                                break;  /* found it */
+                }
+        } else {
+                wl_list_for_each_reverse(c, &sel->link, link) {
+                        if (&c->link == &clients)
+                                continue;  /* wrap past the sentinel node */
+                        if (VISIBLEON(c, selmon))
+                                break;  /* found it */
+                }
+        }
+        /* If only one client is visible on selmon, then c == sel */
+        focusclient(c, 1);
 }
 
 Client *
 focustop(Monitor *m)
 {
-	Client *c;
-	wl_list_for_each(c, &fstack, flink)
-		if (VISIBLEON(c, m))
-			return c;
-	return NULL;
-}
-
-void
-getxdecomode(struct wl_listener *listener, void *data)
-{
-	struct wlr_xdg_toplevel_decoration_v1 *wlr_deco = data;
-	wlr_xdg_toplevel_decoration_v1_set_mode(wlr_deco,
-			WLR_XDG_TOPLEVEL_DECORATION_V1_MODE_SERVER_SIDE);
+        Client *c;
+        wl_list_for_each(c, &fstack, flink)
+                if (VISIBLEON(c, m))
+                        return c;
+        return NULL;
 }
 
 void
 incnmaster(const Arg *arg)
 {
-	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
-	arrange(selmon);
+        selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
+        arrange(selmon);
 }
 
 void
 inputdevice(struct wl_listener *listener, void *data)
 {
-	/* This event is raised by the backend when a new input device becomes
-	 * available. */
-	struct wlr_input_device *device = data;
-	uint32_t caps;
-
-	switch (device->type) {
-	case WLR_INPUT_DEVICE_KEYBOARD:
-		createkeyboard(device);
-		break;
-	case WLR_INPUT_DEVICE_POINTER:
-		createpointer(device);
-		break;
-	default:
-		/* TODO handle other input device types */
-		break;
-	}
-
-	/* We need to let the wlr_seat know what our capabilities are, which is
-	 * communiciated to the client. In dwl we always have a cursor, even if
-	 * there are no pointer devices, so we always include that capability. */
-	/* TODO do we actually require a cursor? */
-	caps = WL_SEAT_CAPABILITY_POINTER;
-	if (!wl_list_empty(&keyboards))
-		caps |= WL_SEAT_CAPABILITY_KEYBOARD;
-	wlr_seat_set_capabilities(seat, caps);
+        /* This event is raised by the backend when a new input device becomes
+         * available. */
+        struct wlr_input_device *device = data;
+        uint32_t caps;
+
+        switch (device->type) {
+        case WLR_INPUT_DEVICE_KEYBOARD:
+                createkeyboard(device);
+                break;
+        case WLR_INPUT_DEVICE_POINTER:
+                createpointer(device);
+                break;
+        default:
+                /* TODO handle other input device types */
+                break;
+        }
+
+        /* We need to let the wlr_seat know what our capabilities are, which is
+         * communiciated to the client. In dwl we always have a cursor, even if
+         * there are no pointer devices, so we always include that capability. */
+        /* TODO do we actually require a cursor? */
+        caps = WL_SEAT_CAPABILITY_POINTER;
+        if (!wl_list_empty(&keyboards))
+                caps |= WL_SEAT_CAPABILITY_KEYBOARD;
+        wlr_seat_set_capabilities(seat, caps);
 }
 
 int
-keybinding(uint32_t mods, xkb_keysym_t sym)
-{
-	/*
-	 * Here we handle compositor keybindings. This is when the compositor is
-	 * processing keys, rather than passing them on to the client for its own
-	 * processing.
-	 */
-	int handled = 0;
-	const Key *k;
-	for (k = keys; k < END(keys); k++) {
-		if (CLEANMASK(mods) == CLEANMASK(k->mod) &&
-				sym == k->keysym && k->func) {
-			k->func(&k->arg);
-			handled = 1;
-		}
-	}
-	return handled;
+keybinding(uint32_t mods, xkb_keycode_t keycode)
+{
+        /*
+         * Here we handle compositor keybindings. This is when the compositor is
+         * processing keys, rather than passing them on to the client for its own
+         * processing.
+         */
+        int handled = 0;
+        Key k;
+        for (int i = 0; i < numkeys; i++) {
+                k = keys[i];
+                if (CLEANMASK(mods) == CLEANMASK(k.mod) &&
+                    keycode == k.keycode && k.func) {
+                        dscm_safe_call(DSCM_CALL_ACTION, k.func, NULL);
+                        handled = 1;
+                }
+        }
+        return handled;
 }
 
 void
 keypress(struct wl_listener *listener, void *data)
 {
-	int i;
-	/* This event is raised when a key is pressed or released. */
-	Keyboard *kb = wl_container_of(listener, kb, key);
-	struct wlr_event_keyboard_key *event = data;
-
-	/* Translate libinput keycode -> xkbcommon */
-	uint32_t keycode = event->keycode + 8;
-	/* Get a list of keysyms based on the keymap for this keyboard */
-	const xkb_keysym_t *syms;
-	int nsyms = xkb_state_key_get_syms(
-			kb->device->keyboard->xkb_state, keycode, &syms);
+        /* This event is raised when a key is pressed or released. */
+        Keyboard *kb = wl_container_of(listener, kb, key);
+        struct wlr_event_keyboard_key *event = data;
 
-	int handled = 0;
-	uint32_t mods = wlr_keyboard_get_modifiers(kb->device->keyboard);
+        /* Translate libinput keycode -> xkbcommon */
+        uint32_t keycode = event->keycode + 8;
+        int handled = 0;
+        uint32_t mods = wlr_keyboard_get_modifiers(kb->device->keyboard);
 
-	wlr_idle_notify_activity(idle, seat);
+        wlr_idle_notify_activity(idle, seat);
 
-	/* On _press_, attempt to process a compositor keybinding. */
-	if (event->state == WL_KEYBOARD_KEY_STATE_PRESSED)
-		for (i = 0; i < nsyms; i++)
-			handled = keybinding(mods, syms[i]) || handled;
+        if (!input_inhibit_mgr->active_inhibitor
+                        && event->state == WL_KEYBOARD_KEY_STATE_PRESSED)
+                handled = keybinding(mods, keycode) || handled;
 
-	if (!handled) {
-		/* Pass unhandled keycodes along to the client. */
-		wlr_seat_set_keyboard(seat, kb->device);
-		wlr_seat_keyboard_notify_key(seat, event->time_msec,
-			event->keycode, event->state);
-	}
+        if (!handled) {
+                /* Pass unhandled keycodes along to the client. */
+                wlr_seat_set_keyboard(seat, kb->device);
+                wlr_seat_keyboard_notify_key(seat, event->time_msec,
+                                             event->keycode, event->state);
+        }
 }
 
 void
 keypressmod(struct wl_listener *listener, void *data)
 {
-	/* This event is raised when a modifier key, such as shift or alt, is
-	 * pressed. We simply communicate this to the client. */
-	Keyboard *kb = wl_container_of(listener, kb, modifiers);
-	/*
-	 * A seat can only have one keyboard, but this is a limitation of the
-	 * Wayland protocol - not wlroots. We assign all connected keyboards to the
-	 * same seat. You can swap out the underlying wlr_keyboard like this and
-	 * wlr_seat handles this transparently.
-	 */
-	wlr_seat_set_keyboard(seat, kb->device);
-	/* Send modifiers to the client. */
-	wlr_seat_keyboard_notify_modifiers(seat,
-		&kb->device->keyboard->modifiers);
+        /* This event is raised when a modifier key, such as shift or alt, is
+         * pressed. We simply communicate this to the client. */
+        Keyboard *kb = wl_container_of(listener, kb, modifiers);
+        /*
+         * A seat can only have one keyboard, but this is a limitation of the
+         * Wayland protocol - not wlroots. We assign all connected keyboards to the
+         * same seat. You can swap out the underlying wlr_keyboard like this and
+         * wlr_seat handles this transparently.
+         */
+        wlr_seat_set_keyboard(seat, kb->device);
+        /* Send modifiers to the client. */
+        wlr_seat_keyboard_notify_modifiers(seat,
+                                           &kb->device->keyboard->modifiers);
 }
 
 void
 killclient(const Arg *arg)
 {
-	Client *sel = selclient();
-	if (!sel)
-		return;
-	client_send_close(sel);
+        Client *sel = selclient();
+        if (!sel)
+                return;
+        client_send_close(sel);
 }
 
 void
 maplayersurfacenotify(struct wl_listener *listener, void *data)
 {
-	LayerSurface *layersurface = wl_container_of(listener, layersurface, map);
-	wlr_surface_send_enter(layersurface->layer_surface->surface, layersurface->layer_surface->output);
-	motionnotify(0);
+        LayerSurface *layersurface = wl_container_of(listener, layersurface, map);
+        wlr_surface_send_enter(layersurface->layer_surface->surface,
+                               layersurface->layer_surface->output);
+        motionnotify(0);
 }
 
 void
 mapnotify(struct wl_listener *listener, void *data)
 {
-	/* Called when the surface is mapped, or ready to display on-screen. */
-	Client *c = wl_container_of(listener, c, map);
+        /* Called when the surface is mapped, or ready to display on-screen. */
+        Client *c = wl_container_of(listener, c, map), *sel = selclient();
 
-	if (client_is_unmanaged(c)) {
-		/* Insert this independent into independents lists. */
-		wl_list_insert(&independents, &c->link);
-		return;
-	}
+        /* Insert this client into client lists. */
+        wl_list_insert(&clients, &c->link);
+        wl_list_insert(&fstack, &c->flink);
 
-	/* Insert this client into client lists. */
-	wl_list_insert(&clients, &c->link);
-	wl_list_insert(&fstack, &c->flink);
-	wl_list_insert(&stack, &c->slink);
+        client_get_geometry(c, &c->geom);
+        c->geom.width += 2 * c->bw;
+        c->geom.height += 2 * c->bw;
 
-	client_get_geometry(c, &c->geom);
-	c->geom.width += 2 * c->bw;
-	c->geom.height += 2 * c->bw;
+        /* Tell the client not to try anything fancy */
+        client_set_tiled(c,
+                         WLR_EDGE_TOP | WLR_EDGE_BOTTOM | WLR_EDGE_LEFT | WLR_EDGE_RIGHT);
 
-	/* Set initial monitor, tags, floating status, and focus */
-	applyrules(c);
+        /* Set initial monitor, tags, floating status, and focus */
+        applyrules(c);
+        printstatus();
+
+        if (c->isfullscreen)
+                setfullscreen(c, 1);
+        /* Switch focus from fullscreened client if a new client is spawned. */
+        else if (sel && sel->isfullscreen && VISIBLEON(sel, c->mon))
+                setfullscreen(sel, 0);
+
+        // Damage the whole screen
+        wlr_output_damage_add_whole(c->mon->damage);
+
+#ifdef XWAYLAND
+        if (c->type != XDGShell)
+                LISTEN(&c->surface.xwayland->surface->events.commit, &c->commit,
+                       commitnotifyx11);
+        else
+#endif
+                LISTEN(&c->surface.xdg->surface->events.commit, &c->commit,
+                       commitnotify);
 }
 
+void
+mapnotify_sub(struct wl_listener *listener, void *data)
+{
+        Subsurface *s = wl_container_of(listener, s, map);
+        wl_list_insert(&subsurfaces, &s->link);
+        wlr_output_damage_add_whole(s->c->mon->damage);
+        LISTEN(&s->subsurface->surface->events.commit, &s->commit, commitnotify_sub);
+}
+
+
 void
 monocle(Monitor *m)
 {
-	Client *c;
+        Client *c;
 
-	wl_list_for_each(c, &clients, link) {
-		if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
-			continue;
-		resize(c, m->w.x, m->w.y, m->w.width, m->w.height, 0);
-	}
+        wl_list_for_each(c, &clients, link) {
+                if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
+                        continue;
+                resize(c, m->w.x, m->w.y, m->w.width, m->w.height, 0, !smartborders);
+        }
+
+        /* Lift selected client */
+        c = selclient();
+        if (c) {
+                wl_list_remove(&c->slink);
+                wl_list_insert(&stack, &c->slink);
+        }
 }
 
 void
 motionabsolute(struct wl_listener *listener, void *data)
 {
-	/* This event is forwarded by the cursor when a pointer emits an _absolute_
-	 * motion event, from 0..1 on each axis. This happens, for example, when
-	 * wlroots is running under a Wayland window rather than KMS+DRM, and you
-	 * move the mouse over the window. You could enter the window from any edge,
-	 * so we have to warp the mouse there. There is also some hardware which
-	 * emits these events. */
-	struct wlr_event_pointer_motion_absolute *event = data;
-	wlr_cursor_warp_absolute(cursor, event->device, event->x, event->y);
-	motionnotify(event->time_msec);
+        /* This event is forwarded by the cursor when a pointer emits an _absolute_
+         * motion event, from 0..1 on each axis. This happens, for example, when
+         * wlroots is running under a Wayland window rather than KMS+DRM, and you
+         * move the mouse over the window. You could enter the window from any edge,
+         * so we have to warp the mouse there. There is also some hardware which
+         * emits these events. */
+        struct wlr_event_pointer_motion_absolute *event = data;
+        wlr_cursor_warp_absolute(cursor, event->device, event->x, event->y);
+        motionnotify(event->time_msec);
 }
 
 void
 motionnotify(uint32_t time)
 {
-	double sx = 0, sy = 0;
-	struct wlr_surface *surface = NULL;
-	Client *c = NULL;
-
-	// time is 0 in internal calls meant to restore pointer focus.
-	if (time) {
-		wlr_idle_notify_activity(idle, seat);
-
-		/* Update selmon (even while dragging a window) */
-		if (sloppyfocus)
-			selmon = xytomon(cursor->x, cursor->y);
-	}
-
-	/* If we are currently grabbing the mouse, handle and return */
-	if (cursor_mode == CurMove) {
-		/* Move the grabbed client to the new position. */
-		resize(grabc, cursor->x - grabcx, cursor->y - grabcy,
-				grabc->geom.width, grabc->geom.height, 1);
-		return;
-	} else if (cursor_mode == CurResize) {
-		resize(grabc, grabc->geom.x, grabc->geom.y,
-				cursor->x - grabc->geom.x,
-				cursor->y - grabc->geom.y, 1);
-		return;
-	}
-
-	if ((surface = xytolayersurface(&selmon->layers[ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY],
-					cursor->x, cursor->y, &sx, &sy)))
-		;
-	else if ((surface = xytolayersurface(&selmon->layers[ZWLR_LAYER_SHELL_V1_LAYER_TOP],
-					cursor->x, cursor->y, &sx, &sy)))
-		;
+        double sx = 0, sy = 0;
+        struct wlr_surface *surface = NULL;
+        Client *c = NULL;
+
+        // time is 0 in internal calls meant to restore pointer focus.
+        if (time) {
+                wlr_idle_notify_activity(idle, seat);
+
+                /* Update selmon (even while dragging a window) */
+                if (sloppyfocus)
+                        selmon = xytomon(cursor->x, cursor->y);
+        }
+
+        /* If we are currently grabbing the mouse, handle and return */
+        if (cursor_mode == CurMove) {
+                /* Move the grabbed client to the new position. */
+                resize(grabc, cursor->x - grabcx, cursor->y - grabcy,
+                       grabc->geom.width, grabc->geom.height, 1, 1);
+                return;
+        } else if (cursor_mode == CurResize) {
+                resize(grabc, grabc->geom.x, grabc->geom.y,
+                       cursor->x - grabc->geom.x,
+                       cursor->y - grabc->geom.y, 1, 1);
+                return;
+        }
+
+        if ((surface = xytolayersurface(&selmon->layers[ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY],
+                                        cursor->x, cursor->y, &sx, &sy)))
+                ;
+        else if ((surface = xytolayersurface(
+                          &selmon->layers[ZWLR_LAYER_SHELL_V1_LAYER_TOP],
+                          cursor->x, cursor->y, &sx, &sy)))
+                ;
 #ifdef XWAYLAND
-	/* Find an independent under the pointer and send the event along. */
-	else if ((c = xytoindependent(cursor->x, cursor->y))) {
-		surface = wlr_surface_surface_at(c->surface.xwayland->surface,
-				cursor->x - c->surface.xwayland->x - c->bw,
-				cursor->y - c->surface.xwayland->y - c->bw, &sx, &sy);
-
-	/* Otherwise, find the client under the pointer and send the event along. */
-	}
+        /* Find an independent under the pointer and send the event along. */
+        else if ((c = xytoindependent(cursor->x, cursor->y))) {
+                surface = wlr_surface_surface_at(
+                        c->surface.xwayland->surface,
+                        cursor->x - c->surface.xwayland->x - c->bw,
+                        cursor->y - c->surface.xwayland->y - c->bw, &sx, &sy);
+
+                /* Otherwise, find the client under the pointer
+                 * and send the event along. */
+        }
 #endif
-	else if ((c = xytoclient(cursor->x, cursor->y))) {
-		surface = client_surface_at(c, cursor->x - c->geom.x - c->bw,
-				cursor->y - c->geom.y - c->bw, &sx, &sy);
-	}
-	else if ((surface = xytolayersurface(&selmon->layers[ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM],
-					cursor->x, cursor->y, &sx, &sy)))
-		;
-	else
-		surface = xytolayersurface(&selmon->layers[ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND],
-					cursor->x, cursor->y, &sx, &sy);
-
-	/* If there's no client surface under the cursor, set the cursor image to a
-	 * default. This is what makes the cursor image appear when you move it
-	 * off of a client or over its border. */
-	if (!surface && time)
-		wlr_xcursor_manager_set_cursor_image(cursor_mgr,
-				"left_ptr", cursor);
-
-	pointerfocus(c, surface, sx, sy, time);
+        else if ((c = xytoclient(cursor->x, cursor->y))) {
+                surface = client_surface_at(c, cursor->x - c->geom.x - c->bw,
+                                            cursor->y - c->geom.y - c->bw, &sx, &sy);
+        }
+        else if ((surface = xytolayersurface(
+                          &selmon->layers[ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM],
+                          cursor->x, cursor->y, &sx, &sy)))
+                ;
+        else
+                surface = xytolayersurface(
+                        &selmon->layers[ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND],
+                        cursor->x, cursor->y, &sx, &sy);
+
+        /* If there's no client surface under the cursor, set the cursor image to a
+         * default. This is what makes the cursor image appear when you move it
+         * off of a client or over its border. */
+        if (!surface && time)
+                wlr_xcursor_manager_set_cursor_image(cursor_mgr,
+                                                     "left_ptr", cursor);
+
+        pointerfocus(c, surface, sx, sy, time);
 }
 
 void
 motionrelative(struct wl_listener *listener, void *data)
 {
-	/* This event is forwarded by the cursor when a pointer emits a _relative_
-	 * pointer motion event (i.e. a delta) */
-	struct wlr_event_pointer_motion *event = data;
-	/* The cursor doesn't move unless we tell it to. The cursor automatically
-	 * handles constraining the motion to the output layout, as well as any
-	 * special configuration applied for the specific input device which
-	 * generated the event. You can pass NULL for the device if you want to move
-	 * the cursor around without any input. */
-	wlr_cursor_move(cursor, event->device,
-			event->delta_x, event->delta_y);
-	motionnotify(event->time_msec);
+        /* This event is forwarded by the cursor when a pointer emits a _relative_
+         * pointer motion event (i.e. a delta) */
+        struct wlr_event_pointer_motion *event = data;
+        /* The cursor doesn't move unless we tell it to. The cursor automatically
+         * handles constraining the motion to the output layout, as well as any
+         * special configuration applied for the specific input device which
+         * generated the event. You can pass NULL for the device if you want to move
+         * the cursor around without any input. */
+        wlr_cursor_move(cursor, event->device,
+                        event->delta_x, event->delta_y);
+        motionnotify(event->time_msec);
 }
 
 void
 moveresize(const Arg *arg)
 {
-	if (cursor_mode != CurNormal || !(grabc = xytoclient(cursor->x, cursor->y)))
-		return;
-
-	/* Float the window and tell motionnotify to grab it */
-	setfloating(grabc, 1);
-	switch (cursor_mode = arg->ui) {
-	case CurMove:
-		grabcx = cursor->x - grabc->geom.x;
-		grabcy = cursor->y - grabc->geom.y;
-		wlr_xcursor_manager_set_cursor_image(cursor_mgr, "fleur", cursor);
-		break;
-	case CurResize:
-		/* Doesn't work for X11 output - the next absolute motion event
-		 * returns the cursor to where it started */
-		wlr_cursor_warp_closest(cursor, NULL,
-				grabc->geom.x + grabc->geom.width,
-				grabc->geom.y + grabc->geom.height);
-		wlr_xcursor_manager_set_cursor_image(cursor_mgr,
-				"bottom_right_corner", cursor);
-		break;
-	}
+        if (cursor_mode != CurNormal || !(grabc = xytoclient(cursor->x, cursor->y)))
+                return;
+
+        /* Float the window and tell motionnotify to grab it */
+        setfloating(grabc, 1);
+        switch (cursor_mode = arg->ui) {
+        case CurMove:
+                grabcx = cursor->x - grabc->geom.x;
+                grabcy = cursor->y - grabc->geom.y;
+                wlr_xcursor_manager_set_cursor_image(cursor_mgr, "fleur", cursor);
+                break;
+        case CurResize:
+                /* Doesn't work for X11 output - the next absolute motion event
+                 * returns the cursor to where it started */
+                wlr_cursor_warp_closest(cursor, NULL,
+                                        grabc->geom.x + grabc->geom.width,
+                                        grabc->geom.y + grabc->geom.height);
+                wlr_xcursor_manager_set_cursor_image(cursor_mgr,
+                                                     "bottom_right_corner", cursor);
+                break;
+        }
 }
 
+void
+new_subnotify(struct wl_listener *listener, void *data) {
+        struct wlr_subsurface *subsurface = data;
+        Subsurface *s = subsurface->data = calloc(1, sizeof(*s));
+        s->subsurface = subsurface;
+        s->c = wl_container_of(listener, s->c, new_sub);
+
+        LISTEN(&s->subsurface->events.map, &s->map, mapnotify_sub);
+        LISTEN(&s->subsurface->events.unmap, &s->unmap, unmapnotify_sub);
+        LISTEN(&s->subsurface->events.destroy, &s->destroy, destroynotify_sub);
+}
+
+
 void
 outputmgrapply(struct wl_listener *listener, void *data)
 {
-	struct wlr_output_configuration_v1 *config = data;
-	outputmgrapplyortest(config, 0);
+        struct wlr_output_configuration_v1 *config = data;
+        outputmgrapplyortest(config, 0);
 }
 
 void
 outputmgrapplyortest(struct wlr_output_configuration_v1 *config, int test)
 {
-	/*
-	 * Called when a client such as wlr-randr requests a change in output
-	 * configuration.  This is only one way that the layout can be changed,
-	 * so any Monitor information should be updated by updatemons() after an
-	 * output_layout.change event, not here.
-	 */
-	struct wlr_output_configuration_head_v1 *config_head;
-	int ok = 1;
-
-	wl_list_for_each(config_head, &config->heads, link) {
-		struct wlr_output *wlr_output = config_head->state.output;
-
-		wlr_output_enable(wlr_output, config_head->state.enabled);
-		if (config_head->state.enabled) {
-			if (config_head->state.mode)
-				wlr_output_set_mode(wlr_output, config_head->state.mode);
-			else
-				wlr_output_set_custom_mode(wlr_output,
-						config_head->state.custom_mode.width,
-						config_head->state.custom_mode.height,
-						config_head->state.custom_mode.refresh);
-
-			wlr_output_layout_move(output_layout, wlr_output,
-					config_head->state.x, config_head->state.y);
-			wlr_output_set_transform(wlr_output, config_head->state.transform);
-			wlr_output_set_scale(wlr_output, config_head->state.scale);
-		}
-
-		if (!(ok = wlr_output_test(wlr_output)))
-			break;
-	}
-	wl_list_for_each(config_head, &config->heads, link) {
-		if (ok && !test)
-			wlr_output_commit(config_head->state.output);
-		else
-			wlr_output_rollback(config_head->state.output);
-	}
-	if (ok)
-		wlr_output_configuration_v1_send_succeeded(config);
-	else
-		wlr_output_configuration_v1_send_failed(config);
-	wlr_output_configuration_v1_destroy(config);
+        /*
+         * Called when a client such as wlr-randr requests a change in output
+         * configuration.  This is only one way that the layout can be changed,
+         * so any Monitor information should be updated by updatemons() after an
+         * output_layout.change event, not here.
+         */
+        struct wlr_output_configuration_head_v1 *config_head;
+        int ok = 1;
+
+        wl_list_for_each(config_head, &config->heads, link) {
+                struct wlr_output *wlr_output = config_head->state.output;
+
+                wlr_output_enable(wlr_output, config_head->state.enabled);
+                if (config_head->state.enabled) {
+                        if (config_head->state.mode)
+                                wlr_output_set_mode(wlr_output, config_head->state.mode);
+                        else
+                                wlr_output_set_custom_mode(
+                                        wlr_output,
+                                        config_head->state.custom_mode.width,
+                                        config_head->state.custom_mode.height,
+                                        config_head->state.custom_mode.refresh);
+
+                        wlr_output_layout_move(
+                                output_layout, wlr_output,
+                                config_head->state.x, config_head->state.y);
+                        wlr_output_set_transform(wlr_output,
+                                                 config_head->state.transform);
+                        wlr_output_set_scale(wlr_output, config_head->state.scale);
+                }
+
+                if (!(ok = wlr_output_test(wlr_output)))
+                        break;
+        }
+        wl_list_for_each(config_head, &config->heads, link) {
+                if (ok && !test)
+                        wlr_output_commit(config_head->state.output);
+                else
+                        wlr_output_rollback(config_head->state.output);
+        }
+        if (ok)
+                wlr_output_configuration_v1_send_succeeded(config);
+        else
+                wlr_output_configuration_v1_send_failed(config);
+        wlr_output_configuration_v1_destroy(config);
 }
 
 void
 outputmgrtest(struct wl_listener *listener, void *data)
 {
-	struct wlr_output_configuration_v1 *config = data;
-	outputmgrapplyortest(config, 1);
+        struct wlr_output_configuration_v1 *config = data;
+        outputmgrapplyortest(config, 1);
 }
 
 void
 pointerfocus(Client *c, struct wlr_surface *surface, double sx, double sy,
-		uint32_t time)
+             uint32_t time)
 {
-	struct timespec now;
-	int internal_call = !time;
+        struct timespec now;
+        int internal_call = !time;
 
-	/* Use top level surface if nothing more specific given */
-	if (c && !surface)
-		surface = client_surface(c);
+        /* Use top level surface if nothing more specific given */
+        if (c && !surface)
+                surface = client_surface(c);
 
-	/* If surface is NULL, clear pointer focus */
-	if (!surface) {
-		wlr_seat_pointer_notify_clear_focus(seat);
-		return;
-	}
+        /* If surface is NULL, clear pointer focus */
+        if (!surface) {
+                wlr_seat_pointer_notify_clear_focus(seat);
+                return;
+        }
 
-	if (internal_call) {
-		clock_gettime(CLOCK_MONOTONIC, &now);
-		time = now.tv_sec * 1000 + now.tv_nsec / 1000000;
-	}
+        if (internal_call) {
+                clock_gettime(CLOCK_MONOTONIC, &now);
+                time = now.tv_sec * 1000 + now.tv_nsec / 1000000;
+        }
 
-	/* If surface is already focused, only notify of motion */
-	if (surface == seat->pointer_state.focused_surface) {
-		wlr_seat_pointer_notify_motion(seat, time, sx, sy);
-		return;
-	}
+        wlr_seat_pointer_notify_enter(seat, surface, sx, sy);
+        wlr_seat_pointer_notify_motion(seat, time, sx, sy);
 
-	/* Otherwise, let the client know that the mouse cursor has entered one
-	 * of its surfaces, and make keyboard focus follow if desired. */
-	wlr_seat_pointer_notify_enter(seat, surface, sx, sy);
-
-	if (!c || client_is_unmanaged(c))
-		return;
-
-	if (sloppyfocus && !internal_call)
-		focusclient(c, 0);
+        if (sloppyfocus && c && !client_is_unmanaged(c) && !internal_call)
+                focusclient(c, 0);
 }
 
 void
 printstatus(void)
 {
-	Monitor *m = NULL;
-	Client *c = NULL;
-	unsigned int activetags;
-
-	wl_list_for_each(m, &mons, link) {
-		activetags=0;
-		wl_list_for_each(c, &clients, link) {
-			if (c->mon == m)
-				activetags |= c->tags;
-		}
-		if (focustop(m))
-			printf("%s title %s\n", m->wlr_output->name, client_get_title(focustop(m)));
-		else
-			printf("%s title \n", m->wlr_output->name);
-
-		printf("%s selmon %u\n", m->wlr_output->name, m == selmon);
-		printf("%s tags %u %u\n", m->wlr_output->name, activetags, m->tagset[m->seltags]);
-		printf("%s layout %s\n", m->wlr_output->name, m->lt[m->sellt]->symbol);
-	}
-	fflush(stdout);
+        Monitor *m = NULL;
+        Client *c;
+        unsigned int occ, urg, sel;
+
+        wl_list_for_each(m, &mons, link) {
+                occ = urg = 0;
+                wl_list_for_each(c, &clients, link) {
+                        if (c->mon != m)
+                                continue;
+                        occ |= c->tags;
+                        if (c->isurgent)
+                                urg |= c->tags;
+                }
+                if ((c = focustop(m))) {
+                        printf("%s title %s\n", m->wlr_output->name,
+                               client_get_title(focustop(m)));
+                        sel = c->tags;
+                } else {
+                        printf("%s title \n", m->wlr_output->name);
+                        sel = 0;
+                }
+
+                printf("%s selmon %u\n", m->wlr_output->name, m == selmon);
+                printf("%s tags %u %u %u %u\n", m->wlr_output->name, occ,
+                       m->tagset[m->seltags],
+                       sel, urg);
+                printf("%s layout %s\n", m->wlr_output->name, m->lt[m->sellt]->symbol);
+                dscm_printstatus(m);
+        }
+        fflush(stdout);
 }
 
 void
 quit(const Arg *arg)
 {
-	wl_display_terminate(dpy);
+        wl_display_terminate(dpy);
+}
+
+void
+quitsignal(int signo)
+{
+        quit(NULL);
 }
 
 void
 render(struct wlr_surface *surface, int sx, int sy, void *data)
 {
-	/* This function is called for every surface that needs to be rendered. */
-	struct render_data *rdata = data;
-	struct wlr_output *output = rdata->output;
-	double ox = 0, oy = 0;
-	struct wlr_box obox;
-	float matrix[9];
-	enum wl_output_transform transform;
-
-	/* We first obtain a wlr_texture, which is a GPU resource. wlroots
-	 * automatically handles negotiating these with the client. The underlying
-	 * resource could be an opaque handle passed from the client, or the client
-	 * could have sent a pixel buffer which we copied to the GPU, or a few other
-	 * means. You don't have to worry about this, wlroots takes care of it. */
-	struct wlr_texture *texture = wlr_surface_get_texture(surface);
-	if (!texture)
-		return;
-
-	/* The client has a position in layout coordinates. If you have two displays,
-	 * one next to the other, both 1080p, a client on the rightmost display might
-	 * have layout coordinates of 2000,100. We need to translate that to
-	 * output-local coordinates, or (2000 - 1920). */
-	wlr_output_layout_output_coords(output_layout, output, &ox, &oy);
-
-	/* We also have to apply the scale factor for HiDPI outputs. This is only
-	 * part of the puzzle, dwl does not fully support HiDPI. */
-	obox.x = ox + rdata->x + sx;
-	obox.y = oy + rdata->y + sy;
-	obox.width = surface->current.width;
-	obox.height = surface->current.height;
-	scalebox(&obox, output->scale);
-
-	/*
-	 * Those familiar with OpenGL are also familiar with the role of matrices
-	 * in graphics programming. We need to prepare a matrix to render the
-	 * client with. wlr_matrix_project_box is a helper which takes a box with
-	 * a desired x, y coordinates, width and height, and an output geometry,
-	 * then prepares an orthographic projection and multiplies the necessary
-	 * transforms to produce a model-view-projection matrix.
-	 *
-	 * Naturally you can do this any way you like, for example to make a 3D
-	 * compositor.
-	 */
-	transform = wlr_output_transform_invert(surface->current.transform);
-	wlr_matrix_project_box(matrix, &obox, transform, 0,
-		output->transform_matrix);
-
-	/* This takes our matrix, the texture, and an alpha, and performs the actual
-	 * rendering on the GPU. */
-	wlr_render_texture_with_matrix(drw, texture, matrix, 1);
-
-	/* This lets the client know that we've displayed that frame and it can
-	 * prepare another one now if it likes. */
-	wlr_surface_send_frame_done(surface, rdata->when);
+        /* This function is called for every surface that needs to be rendered. */
+        struct render_data *rdata = data;
+        struct wlr_output *output = rdata->output;
+        double ox = 0, oy = 0;
+        struct wlr_box obox;
+        float matrix[9];
+        enum wl_output_transform transform;
+
+        /* We first obtain a wlr_texture, which is a GPU resource. wlroots
+         * automatically handles negotiating these with the client. The underlying
+         * resource could be an opaque handle passed from the client, or the client
+         * could have sent a pixel buffer which we copied to the GPU, or a few other
+         * means. You don't have to worry about this, wlroots takes care of it. */
+        struct wlr_texture *texture = wlr_surface_get_texture(surface);
+        if (!texture)
+                return;
+
+        /* The client has a position in layout coordinates. If you have two displays,
+         * one next to the other, both 1080p, a client on the rightmost display might
+         * have layout coordinates of 2000,100. We need to translate that to
+         * output-local coordinates, or (2000 - 1920). */
+        wlr_output_layout_output_coords(output_layout, output, &ox, &oy);
+
+        /* We also have to apply the scale factor for HiDPI outputs. This is only
+         * part of the puzzle, dwl does not fully support HiDPI. */
+        obox.x = ox + rdata->x + sx;
+        obox.y = oy + rdata->y + sy;
+        obox.width = surface->current.width;
+        obox.height = surface->current.height;
+        scalebox(&obox, output->scale);
+
+        /*
+         * Those familiar with OpenGL are also familiar with the role of matrices
+         * in graphics programming. We need to prepare a matrix to render the
+         * client with. wlr_matrix_project_box is a helper which takes a box with
+         * a desired x, y coordinates, width and height, and an output geometry,
+         * then prepares an orthographic projection and multiplies the necessary
+         * transforms to produce a model-view-projection matrix.
+         *
+         * Naturally you can do this any way you like, for example to make a 3D
+         * compositor.
+         */
+        transform = wlr_output_transform_invert(surface->current.transform);
+        wlr_matrix_project_box(matrix, &obox, transform, 0,
+                               output->transform_matrix);
+
+        /* This takes our matrix, the texture, and an alpha, and performs the actual
+         * rendering on the GPU. */
+        wlr_render_texture_with_matrix(drw, texture, matrix, rdata->alpha);
+
+        /* This lets the client know that we've displayed that frame and it can
+         * prepare another one now if it likes. */
+        wlr_surface_send_frame_done(surface, rdata->when);
+
+        wlr_presentation_surface_sampled_on_output(presentation, surface, output);
 }
 
 void
 renderclients(Monitor *m, struct timespec *now)
 {
-	Client *c, *sel = selclient();
-	const float *color;
-	double ox, oy;
-	int i, w, h;
-	struct render_data rdata;
-	struct wlr_box *borders;
-	struct wlr_surface *surface;
-	/* Each subsequent window we render is rendered on top of the last. Because
-	 * our stacking list is ordered front-to-back, we iterate over it backwards. */
-	wl_list_for_each_reverse(c, &stack, slink) {
-		/* Only render visible clients which show on this monitor */
-		if (!VISIBLEON(c, c->mon) || !wlr_output_layout_intersects(
-					output_layout, m->wlr_output, &c->geom))
-			continue;
-
-		surface = client_surface(c);
-		ox = c->geom.x, oy = c->geom.y;
-		wlr_output_layout_output_coords(output_layout, m->wlr_output,
-				&ox, &oy);
-
-		if (c->bw) {
-			w = surface->current.width;
-			h = surface->current.height;
-			borders = (struct wlr_box[4]) {
-				{ox, oy, w + 2 * c->bw, c->bw},             /* top */
-				{ox, oy + c->bw, c->bw, h},                 /* left */
-				{ox + c->bw + w, oy + c->bw, c->bw, h},     /* right */
-				{ox, oy + c->bw + h, w + 2 * c->bw, c->bw}, /* bottom */
-			};
-
-			/* Draw window borders */
-			color = (c == sel) ? focuscolor : bordercolor;
-			for (i = 0; i < 4; i++) {
-				scalebox(&borders[i], m->wlr_output->scale);
-				wlr_render_rect(drw, &borders[i], color,
-						m->wlr_output->transform_matrix);
-			}
-		}
-
-		/* This calls our render function for each surface among the
-		 * xdg_surface's toplevel and popups. */
-		rdata.output = m->wlr_output;
-		rdata.when = now;
-		rdata.x = c->geom.x + c->bw;
-		rdata.y = c->geom.y + c->bw;
-		client_for_each_surface(c, render, &rdata);
-	}
+        Client *c, *sel = selclient();
+        const float *color;
+        double ox, oy;
+        int i, w, h;
+        struct render_data rdata;
+        struct wlr_box *borders;
+        struct wlr_surface *surface;
+        /* Each subsequent window we render is rendered on top of the last. Because
+         * our stacking list is ordered front-to-back, we iterate over it backwards. */
+        wl_list_for_each_reverse(c, &stack, slink) {
+                /* Only render visible clients which show on this monitor */
+                if (!VISIBLEON(c, c->mon) || !wlr_output_layout_intersects(
+                            output_layout, m->wlr_output, &c->geom))
+                        continue;
+
+                surface = client_surface(c);
+                ox = c->geom.x, oy = c->geom.y;
+                wlr_output_layout_output_coords(output_layout, m->wlr_output,
+                                                &ox, &oy);
+
+                if (c->bw) {
+                        w = surface->current.width;
+                        h = surface->current.height;
+                        borders = (struct wlr_box[4]) {
+                                {ox, oy, w + 2 * c->bw, c->bw},             /* top */
+                                {ox, oy + c->bw, c->bw, h},                 /* left */
+                                {ox + c->bw + w, oy + c->bw, c->bw, h},     /* right */
+                                {ox, oy + c->bw + h, w + 2 * c->bw, c->bw}, /* bottom */
+                        };
+
+                        /* Draw window borders */
+                        color = (c == sel) ? focuscolor : bordercolor;
+                        for (i = 0; i < 4; i++) {
+                                scalebox(&borders[i], m->wlr_output->scale);
+                                wlr_render_rect(drw, &borders[i], color,
+                                                m->wlr_output->transform_matrix);
+                        }
+                }
+
+                /* This calls our render function for each surface among the
+                 * xdg_surface's toplevel and popups. */
+                rdata.output = m->wlr_output;
+                rdata.when = now;
+                rdata.x = c->geom.x + c->bw;
+                rdata.y = c->geom.y + c->bw;
+                rdata.alpha = c->alpha;
+                client_for_each_surface(c, render, &rdata);
+        }
+}
+
+void
+renderdragicon(Monitor *m, struct timespec *now)
+{
+        struct render_data rdata;
+        if (!drag_icon || !drag_icon->mapped || xytomon(cursor->x, cursor->y) != m)
+                return;
+        rdata.output = m->wlr_output;
+        rdata.when = now;
+        rdata.x = cursor->x;
+        rdata.y = cursor->y;
+        wlr_surface_for_each_surface(drag_icon->surface, render, &rdata);
 }
 
 void
 renderlayer(struct wl_list *layer_surfaces, struct timespec *now)
 {
-	LayerSurface *layersurface;
-	wl_list_for_each(layersurface, layer_surfaces, link) {
-		struct render_data rdata = {
-			.output = layersurface->layer_surface->output,
-			.when = now,
-			.x = layersurface->geo.x,
-			.y = layersurface->geo.y,
-		};
+        LayerSurface *layersurface;
+        wl_list_for_each(layersurface, layer_surfaces, link) {
+                struct render_data rdata = {
+                        .output = layersurface->layer_surface->output,
+                        .when = now,
+                        .x = layersurface->geo.x,
+                        .y = layersurface->geo.y,
+                        .alpha = 1,
+                };
 
-		wlr_surface_for_each_surface(layersurface->layer_surface->surface,
-				render, &rdata);
-	}
+                wlr_surface_for_each_surface(layersurface->layer_surface->surface,
+                                             render, &rdata);
+        }
 }
 
 void
 rendermon(struct wl_listener *listener, void *data)
 {
-	Client *c;
-	int render = 1;
-
-	/* This function is called every time an output is ready to display a frame,
-	 * generally at the output's refresh rate (e.g. 60Hz). */
-	Monitor *m = wl_container_of(listener, m, frame);
-
-	struct timespec now;
-	clock_gettime(CLOCK_MONOTONIC, &now);
-
-	/* Do not render if any XDG clients have an outstanding resize. */
-	wl_list_for_each(c, &stack, slink) {
-		if (c->resize) {
-			wlr_surface_send_frame_done(client_surface(c), &now);
-			render = 0;
-		}
-	}
-
-	/* wlr_output_attach_render makes the OpenGL context current. */
-	if (!wlr_output_attach_render(m->wlr_output, NULL))
-		return;
-
-	if (render) {
-		/* Begin the renderer (calls glViewport and some other GL sanity checks) */
-		wlr_renderer_begin(drw, m->wlr_output->width, m->wlr_output->height);
-		wlr_renderer_clear(drw, rootcolor);
-
-		renderlayer(&m->layers[ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND], &now);
-		renderlayer(&m->layers[ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM], &now);
-		renderclients(m, &now);
+        Client *c;
+        int render;
+        bool needs_frame;
+        pixman_region32_t damage;
+
+        /* This function is called every time an output is ready to display a frame,
+         * generally at the output's refresh rate (e.g. 60Hz). */
+        Monitor *m = wl_container_of(listener, m, frame);
+
+        struct timespec now;
+        clock_gettime(CLOCK_MONOTONIC, &now);
+
+        /* If there is any XDG client which is awaiting resize, request a new
+         * frame from that client, and do not render anything new until there
+         * are no pending resizes remaining. */
+        wl_list_for_each(c, &stack, slink) {
+                if (c->resize) {
+                        wlr_surface_send_frame_done(client_surface(c), &now);
+                        return;
+                }
+        }
+
+        /* Do not render if no new frame is needed */
+        pixman_region32_init(&damage);
+        render = wlr_output_damage_attach_render(m->damage, &needs_frame, &damage);
+        pixman_region32_fini(&damage);
+        if (!render || !needs_frame) {
+                /* Rollback is needed because attach_render is double-buffered */
+                wlr_output_rollback(m->wlr_output);
+                return;
+        }
+
+        /* Begin the renderer (calls glViewport and some other GL sanity checks) */
+        wlr_renderer_begin(drw, m->wlr_output->width, m->wlr_output->height);
+        wlr_renderer_clear(drw, rootcolor);
+
+        renderlayer(&m->layers[ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND], &now);
+        renderlayer(&m->layers[ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM], &now);
+        renderclients(m, &now);
 #ifdef XWAYLAND
-		renderindependents(m->wlr_output, &now);
+        renderindependents(m->wlr_output, &now);
 #endif
-		renderlayer(&m->layers[ZWLR_LAYER_SHELL_V1_LAYER_TOP], &now);
-		renderlayer(&m->layers[ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY], &now);
+        renderlayer(&m->layers[ZWLR_LAYER_SHELL_V1_LAYER_TOP], &now);
+        renderlayer(&m->layers[ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY], &now);
+        renderdragicon(m, &now);
 
-		/* Hardware cursors are rendered by the GPU on a separate plane, and can be
-		 * moved around without re-rendering what's beneath them - which is more
-		 * efficient. However, not all hardware supports hardware cursors. For this
-		 * reason, wlroots provides a software fallback, which we ask it to render
-		 * here. wlr_cursor handles configuring hardware vs software cursors for you,
-		 * and this function is a no-op when hardware cursors are in use. */
-		wlr_output_render_software_cursors(m->wlr_output, NULL);
+        /* Hardware cursors are rendered by the GPU on a separate plane, and can be
+         * moved around without re-rendering what's beneath them - which is more
+         * efficient. However, not all hardware supports hardware cursors. For this
+         * reason, wlroots provides a software fallback, which we ask it to render
+         * here. wlr_cursor handles configuring hardware vs software cursors for you,
+         * and this function is a no-op when hardware cursors are in use. */
+        wlr_output_render_software_cursors(m->wlr_output, NULL);
 
-		/* Conclude rendering and swap the buffers, showing the final frame
-		 * on-screen. */
-		wlr_renderer_end(drw);
-	}
+        /* Conclude rendering and swap the buffers, showing the final frame
+         * on-screen. */
+        wlr_renderer_end(drw);
+        wlr_output_set_damage(m->wlr_output, &m->damage->current);
+        wlr_output_commit(m->wlr_output);
+}
 
-	wlr_output_commit(m->wlr_output);
+void
+resize(Client *c, int x, int y, int w, int h, int interact, int draw_borders)
+{
+        /*
+         * Note that I took some shortcuts here. In a more fleshed-out
+         * compositor, you'd wait for the client to prepare a buffer at
+         * the new size, then commit any movement that was prepared.
+         */
+        struct wlr_box *bbox = interact ? &sgeom : &c->mon->w;
+        c->geom.x = x;
+        c->geom.y = y;
+        c->geom.width = w;
+        c->geom.height = h;
+        c->bw = (1 - !draw_borders) * borderpx;
+        applybounds(c, bbox);
+        /* wlroots makes this a no-op if size hasn't changed */
+        c->resize = client_set_size(c, c->geom.width - 2 * c->bw,
+                                    c->geom.height - 2 * c->bw);
 }
 
 void
-resize(Client *c, int x, int y, int w, int h, int interact)
+setupsignals() {
+        /* Block real-time signals so that they can be
+         * used as custom user signals. */
+        struct sigaction sa;
+        sa.sa_handler = SIG_IGN;
+        for (int i = SIGRTMIN; i <= SIGRTMAX; i++)
+                sigaction(i, &sa, NULL);
+}
+
+void
+requeststartdrag(struct wl_listener *listener, void *data)
 {
-	/*
-	 * Note that I took some shortcuts here. In a more fleshed-out
-	 * compositor, you'd wait for the client to prepare a buffer at
-	 * the new size, then commit any movement that was prepared.
-	 */
-	struct wlr_box *bbox = interact ? &sgeom : &c->mon->w;
-	c->geom.x = x;
-	c->geom.y = y;
-	c->geom.width = w;
-	c->geom.height = h;
-	applybounds(c, bbox);
-	/* wlroots makes this a no-op if size hasn't changed */
-	c->resize = client_set_size(c, c->geom.width - 2 * c->bw,
-			c->geom.height - 2 * c->bw);
+        struct wlr_seat_request_start_drag_event *event = data;
+
+        if (wlr_seat_validate_pointer_grab_serial(seat, event->origin,
+                                                  event->serial))
+                wlr_seat_start_pointer_drag(seat, event->drag, event->serial);
+        else
+                wlr_data_source_destroy(event->drag->source);
 }
 
 void
 run(char *startup_cmd)
 {
-	pid_t startup_pid = -1;
-
-	/* Add a Unix socket to the Wayland display. */
-	const char *socket = wl_display_add_socket_auto(dpy);
-	if (!socket)
-		BARF("startup: display_add_socket_auto");
-
-	/* Start the backend. This will enumerate outputs and inputs, become the DRM
-	 * master, etc */
-	if (!wlr_backend_start(backend))
-		BARF("startup: backend_start");
-
-	/* Now that outputs are initialized, choose initial selmon based on
-	 * cursor position, and set default cursor image */
-	selmon = xytomon(cursor->x, cursor->y);
-
-	/* TODO hack to get cursor to display in its initial location (100, 100)
-	 * instead of (0, 0) and then jumping.  still may not be fully
-	 * initialized, as the image/coordinates are not transformed for the
-	 * monitor when displayed here */
-	wlr_cursor_warp_closest(cursor, NULL, cursor->x, cursor->y);
-	wlr_xcursor_manager_set_cursor_image(cursor_mgr, "left_ptr", cursor);
-
-	/* Set the WAYLAND_DISPLAY environment variable to our socket and run the
-	 * startup command if requested. */
-	setenv("WAYLAND_DISPLAY", socket, 1);
-
-	if (startup_cmd) {
-		startup_pid = fork();
-		if (startup_pid < 0)
-			EBARF("startup: fork");
-		if (startup_pid == 0) {
-			dup2(STDERR_FILENO, STDOUT_FILENO);
-			execl("/bin/sh", "/bin/sh", "-c", startup_cmd, NULL);
-			EBARF("startup: execl");
-		}
-	}
-
-	/* Run the Wayland event loop. This does not return until you exit the
-	 * compositor. Starting the backend rigged up all of the necessary event
-	 * loop configuration to listen to libinput events, DRM events, generate
-	 * frame events at the refresh rate, and so on. */
-	wl_display_run(dpy);
-
-	if (startup_cmd) {
-		kill(startup_pid, SIGTERM);
-		waitpid(startup_pid, NULL, 0);
-	}
+        pid_t startup_pid = -1;
+
+        /* Add a Unix socket to the Wayland display. */
+        const char *socket = wl_display_add_socket_auto(dpy);
+        if (!socket)
+                BARF("startup: display_add_socket_auto");
+        setenv("WAYLAND_DISPLAY", socket, 1);
+
+        /* Now that the socket exists, run the startup command */
+        if (startup_cmd) {
+                int piperw[2];
+                pipe(piperw);
+                startup_pid = fork();
+                if (startup_pid < 0)
+                        EBARF("startup: fork");
+                if (startup_pid == 0) {
+                        dup2(piperw[0], STDIN_FILENO);
+                        close(piperw[1]);
+                        execl("/bin/sh", "/bin/sh", "-c", startup_cmd, NULL);
+                        EBARF("startup: execl");
+                }
+                dup2(piperw[1], STDOUT_FILENO);
+                close(piperw[0]);
+        }
+
+        /* If nobody is reading the status output, don't terminate */
+        signal(SIGPIPE, SIG_IGN);
+        printstatus();
+
+        /* Start the backend. This will enumerate outputs and inputs, become the DRM
+         * master, etc */
+        if (!wlr_backend_start(backend))
+                BARF("startup: backend_start");
+
+        /* Now that outputs are initialized, choose initial selmon based on
+         * cursor position, and set default cursor image */
+        selmon = xytomon(cursor->x, cursor->y);
+
+        /* TODO hack to get cursor to display in its initial location (100, 100)
+         * instead of (0, 0) and then jumping.  still may not be fully
+         * initialized, as the image/coordinates are not transformed for the
+         * monitor when displayed here */
+        wlr_cursor_warp_closest(cursor, NULL, cursor->x, cursor->y);
+        wlr_xcursor_manager_set_cursor_image(cursor_mgr, "left_ptr", cursor);
+
+        /* Run the Wayland event loop. This does not return until you exit the
+         * compositor. Starting the backend rigged up all of the necessary event
+         * loop configuration to listen to libinput events, DRM events, generate
+         * frame events at the refresh rate, and so on. */
+        wl_display_run(dpy);
+
+        if (startup_cmd) {
+                kill(startup_pid, SIGTERM);
+                waitpid(startup_pid, NULL, 0);
+        }
 }
 
 void
 scalebox(struct wlr_box *box, float scale)
 {
-	box->width =  ROUND((box->x + box->width) * scale) -  ROUND(box->x * scale);
-	box->height = ROUND((box->y + box->height) * scale) - ROUND(box->y * scale);
-	box->x = ROUND(box->x * scale);
-	box->y = ROUND(box->y * scale);
+        box->width =  ROUND((box->x + box->width) * scale) -  ROUND(box->x * scale);
+        box->height = ROUND((box->y + box->height) * scale) - ROUND(box->y * scale);
+        box->x = ROUND(box->x * scale);
+        box->y = ROUND(box->y * scale);
 }
 
 Client *
 selclient(void)
 {
-	Client *c = wl_container_of(fstack.next, c, flink);
-	if (wl_list_empty(&fstack) || !VISIBLEON(c, selmon))
-		return NULL;
-	return c;
+        Client *c = wl_container_of(fstack.next, c, flink);
+        if (wl_list_empty(&fstack) || !VISIBLEON(c, selmon))
+                return NULL;
+        return c;
 }
 
 void
 setcursor(struct wl_listener *listener, void *data)
 {
-	/* This event is raised by the seat when a client provides a cursor image */
-	struct wlr_seat_pointer_request_set_cursor_event *event = data;
-	/* If we're "grabbing" the cursor, don't use the client's image */
-	/* TODO still need to save the provided surface to restore later */
-	if (cursor_mode != CurNormal)
-		return;
-	/* This can be sent by any client, so we check to make sure this one is
-	 * actually has pointer focus first. If so, we can tell the cursor to
-	 * use the provided surface as the cursor image. It will set the
-	 * hardware cursor on the output that it's currently on and continue to
-	 * do so as the cursor moves between outputs. */
-	if (event->seat_client == seat->pointer_state.focused_client)
-		wlr_cursor_set_surface(cursor, event->surface,
-				event->hotspot_x, event->hotspot_y);
+        /* This event is raised by the seat when a client provides a cursor image */
+        struct wlr_seat_pointer_request_set_cursor_event *event = data;
+        /* If we're "grabbing" the cursor, don't use the client's image */
+        /* TODO still need to save the provided surface to restore later */
+        if (cursor_mode != CurNormal)
+                return;
+        /* This can be sent by any client, so we check to make sure this one is
+         * actually has pointer focus first. If so, we can tell the cursor to
+         * use the provided surface as the cursor image. It will set the
+         * hardware cursor on the output that it's currently on and continue to
+         * do so as the cursor moves between outputs. */
+        if (event->seat_client == seat->pointer_state.focused_client)
+                wlr_cursor_set_surface(cursor, event->surface,
+                                       event->hotspot_x, event->hotspot_y);
 }
 
 void
 setfloating(Client *c, int floating)
 {
-	c->isfloating = floating;
-	arrange(c->mon);
+        if (c->isfloating != floating) {
+                wl_list_remove(&c->slink);
+                wl_list_insert(floating ? &stack : stack.prev, &c->slink);
+        }
+        c->isfloating = floating;
+        arrange(c->mon);
+}
+
+void
+setgaps(int oh, int ov, int ih, int iv)
+{
+        if (oh < 0) oh = 0;
+        if (ov < 0) ov = 0;
+        if (ih < 0) ih = 0;
+        if (iv < 0) iv = 0;
+
+        selmon->gappoh = oh;
+        selmon->gappov = ov;
+        selmon->gappih = ih;
+        selmon->gappiv = iv;
+        arrange(selmon);
+}
+
+void
+togglegaps(const Arg *arg)
+{
+        enablegaps = !enablegaps;
+        arrange(selmon);
+}
+
+void
+defaultgaps(const Arg *arg)
+{
+        setgaps(gappoh, gappov, gappih, gappiv);
+}
+
+void
+incrgaps(const Arg *arg)
+{
+        setgaps(
+                selmon->gappoh + arg->i,
+                selmon->gappov + arg->i,
+                selmon->gappih + arg->i,
+                selmon->gappiv + arg->i
+                );
+}
+
+void
+incrigaps(const Arg *arg)
+{
+        setgaps(
+                selmon->gappoh,
+                selmon->gappov,
+                selmon->gappih + arg->i,
+                selmon->gappiv + arg->i
+                );
+}
+
+void
+incrogaps(const Arg *arg)
+{
+        setgaps(
+                selmon->gappoh + arg->i,
+                selmon->gappov + arg->i,
+                selmon->gappih,
+                selmon->gappiv
+                );
+}
+
+void
+incrohgaps(const Arg *arg)
+{
+        setgaps(
+                selmon->gappoh + arg->i,
+                selmon->gappov,
+                selmon->gappih,
+                selmon->gappiv
+                );
+}
+
+void
+incrovgaps(const Arg *arg)
+{
+        setgaps(
+                selmon->gappoh,
+                selmon->gappov + arg->i,
+                selmon->gappih,
+                selmon->gappiv
+                );
+}
+
+void
+incrihgaps(const Arg *arg)
+{
+        setgaps(
+                selmon->gappoh,
+                selmon->gappov,
+                selmon->gappih + arg->i,
+                selmon->gappiv
+                );
+}
+
+void
+incrivgaps(const Arg *arg)
+{
+        setgaps(
+                selmon->gappoh,
+                selmon->gappov,
+                selmon->gappih,
+                selmon->gappiv + arg->i
+                );
 }
 
 void
 setlayout(const Arg *arg)
 {
-	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
-		selmon->sellt ^= 1;
-	if (arg && arg->v)
-		selmon->lt[selmon->sellt] = (Layout *)arg->v;
-	/* TODO change layout symbol? */
-	arrange(selmon);
-	printstatus();
+        if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
+                selmon->sellt ^= 1;
+        if (arg && arg->v)
+                selmon->lt[selmon->sellt] = (Layout *)arg->v;
+        if (!selmon->lt[selmon->sellt]->arrange) {
+                /* floating layout, draw borders around all clients */
+                Client *c;
+                wl_list_for_each(c, &clients, link) {
+                        if (c->bw)
+                                continue;
+                        resize(c, c->geom.x, c->geom.y, c->geom.width, c->geom.height, 0, 1);
+                }
+        }
+        /* TODO change layout symbol? */
+        arrange(selmon);
+        printstatus();
 }
 
 /* arg > 1.0 will set mfact absolutely */
 void
 setmfact(const Arg *arg)
 {
-	float f;
+        float f;
 
-	if (!arg || !selmon->lt[selmon->sellt]->arrange)
-		return;
-	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
-	if (f < 0.1 || f > 0.9)
-		return;
-	selmon->mfact = f;
-	arrange(selmon);
+        if (!arg || !selmon->lt[selmon->sellt]->arrange)
+                return;
+        f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
+        if (f < 0.1 || f > 0.9)
+                return;
+        selmon->mfact = f;
+        arrange(selmon);
 }
 
 void
 setmon(Client *c, Monitor *m, unsigned int newtags)
 {
-	Monitor *oldmon = c->mon;
+        Monitor *oldmon = c->mon;
 
-	if (oldmon == m)
-		return;
-	c->mon = m;
+        if (oldmon == m)
+                return;
+        c->mon = m;
 
-	/* TODO leave/enter is not optimal but works */
-	if (oldmon) {
-		wlr_surface_send_leave(client_surface(c), oldmon->wlr_output);
-		arrange(oldmon);
-	}
-	if (m) {
-		/* Make sure window actually overlaps with the monitor */
-		applybounds(c, &m->m);
-		wlr_surface_send_enter(client_surface(c), m->wlr_output);
-		c->tags = newtags ? newtags : m->tagset[m->seltags]; /* assign tags of target monitor */
-		arrange(m);
-	}
-	focusclient(focustop(selmon), 1);
+        /* TODO leave/enter is not optimal but works */
+        if (oldmon) {
+                wlr_surface_send_leave(client_surface(c), oldmon->wlr_output);
+                arrange(oldmon);
+        }
+        if (m) {
+                /* Make sure window actually overlaps with the monitor */
+                applybounds(c, &m->m);
+                wlr_surface_send_enter(client_surface(c), m->wlr_output);
+                c->tags = newtags ? newtags : m->tagset[m->seltags]; /* assign tags of target monitor */
+                arrange(m);
+        }
+        focusclient(focustop(selmon), 1);
 }
 
 void
 setpsel(struct wl_listener *listener, void *data)
 {
-	/* This event is raised by the seat when a client wants to set the selection,
-	 * usually when the user copies something. wlroots allows compositors to
-	 * ignore such requests if they so choose, but in dwl we always honor
-	 */
-	struct wlr_seat_request_set_primary_selection_event *event = data;
-	wlr_seat_set_primary_selection(seat, event->source, event->serial);
+        /* This event is raised by the seat when a client wants to set the selection,
+         * usually when the user copies something. wlroots allows compositors to
+         * ignore such requests if they so choose, but in dwl we always honor
+         */
+        struct wlr_seat_request_set_primary_selection_event *event = data;
+        wlr_seat_set_primary_selection(seat, event->source, event->serial);
 }
 
 void
 setsel(struct wl_listener *listener, void *data)
 {
-	/* This event is raised by the seat when a client wants to set the selection,
-	 * usually when the user copies something. wlroots allows compositors to
-	 * ignore such requests if they so choose, but in dwl we always honor
-	 */
-	struct wlr_seat_request_set_selection_event *event = data;
-	wlr_seat_set_selection(seat, event->source, event->serial);
-}
-
-void
-setup(void)
-{
-	/* The Wayland display is managed by libwayland. It handles accepting
-	 * clients from the Unix socket, manging Wayland globals, and so on. */
-	dpy = wl_display_create();
-
-	/* clean up child processes immediately */
-	sigchld(0);
-
-	/* The backend is a wlroots feature which abstracts the underlying input and
-	 * output hardware. The autocreate option will choose the most suitable
-	 * backend based on the current environment, such as opening an X11 window
-	 * if an X11 server is running. The NULL argument here optionally allows you
-	 * to pass in a custom renderer if wlr_renderer doesn't meet your needs. The
-	 * backend uses the renderer, for example, to fall back to software cursors
-	 * if the backend does not support hardware cursors (some older GPUs
-	 * don't). */
-	if (!(backend = wlr_backend_autocreate(dpy)))
-		BARF("couldn't create backend");
-
-	/* If we don't provide a renderer, autocreate makes a GLES2 renderer for us.
-	 * The renderer is responsible for defining the various pixel formats it
-	 * supports for shared memory, this configures that for clients. */
-	drw = wlr_backend_get_renderer(backend);
-	wlr_renderer_init_wl_display(drw, dpy);
-
-	/* This creates some hands-off wlroots interfaces. The compositor is
-	 * necessary for clients to allocate surfaces and the data device manager
-	 * handles the clipboard. Each of these wlroots interfaces has room for you
-	 * to dig your fingers in and play with their behavior if you want. Note that
-	 * the clients cannot set the selection directly without compositor approval,
-	 * see the setsel() function. */
-	compositor = wlr_compositor_create(dpy, drw);
-	wlr_export_dmabuf_manager_v1_create(dpy);
-	wlr_screencopy_manager_v1_create(dpy);
-	wlr_data_control_manager_v1_create(dpy);
-	wlr_data_device_manager_create(dpy);
-	wlr_gamma_control_manager_v1_create(dpy);
-	wlr_primary_selection_v1_device_manager_create(dpy);
-	wlr_viewporter_create(dpy);
-
-	/* Creates an output layout, which a wlroots utility for working with an
-	 * arrangement of screens in a physical layout. */
-	output_layout = wlr_output_layout_create();
-	wl_signal_add(&output_layout->events.change, &layout_change);
-	wlr_xdg_output_manager_v1_create(dpy, output_layout);
-
-	/* Configure a listener to be notified when new outputs are available on the
-	 * backend. */
-	wl_list_init(&mons);
-	wl_signal_add(&backend->events.new_output, &new_output);
-
-	/* Set up our client lists and the xdg-shell. The xdg-shell is a
-	 * Wayland protocol which is used for application windows. For more
-	 * detail on shells, refer to the article:
-	 *
-	 * https://drewdevault.com/2018/07/29/Wayland-shells.html
-	 */
-	wl_list_init(&clients);
-	wl_list_init(&fstack);
-	wl_list_init(&stack);
-	wl_list_init(&independents);
-
-	idle = wlr_idle_create(dpy);
-
-	layer_shell = wlr_layer_shell_v1_create(dpy);
-	wl_signal_add(&layer_shell->events.new_surface, &new_layer_shell_surface);
-
-	xdg_shell = wlr_xdg_shell_create(dpy);
-	wl_signal_add(&xdg_shell->events.new_surface, &new_xdg_surface);
-
-	/* Use xdg_decoration protocol to negotiate server-side decorations */
-	xdeco_mgr = wlr_xdg_decoration_manager_v1_create(dpy);
-	wl_signal_add(&xdeco_mgr->events.new_toplevel_decoration, &new_xdeco);
-
-	/*
-	 * Creates a cursor, which is a wlroots utility for tracking the cursor
-	 * image shown on screen.
-	 */
-	cursor = wlr_cursor_create();
-	wlr_cursor_attach_output_layout(cursor, output_layout);
-
-	/* Creates an xcursor manager, another wlroots utility which loads up
-	 * Xcursor themes to source cursor images from and makes sure that cursor
-	 * images are available at all scale factors on the screen (necessary for
-	 * HiDPI support). Scaled cursors will be loaded with each output. */
-	cursor_mgr = wlr_xcursor_manager_create(NULL, 24);
-
-	/*
-	 * wlr_cursor *only* displays an image on screen. It does not move around
-	 * when the pointer moves. However, we can attach input devices to it, and
-	 * it will generate aggregate events for all of them. In these events, we
-	 * can choose how we want to process them, forwarding them to clients and
-	 * moving the cursor around. More detail on this process is described in my
-	 * input handling blog post:
-	 *
-	 * https://drewdevault.com/2018/07/17/Input-handling-in-wlroots.html
-	 *
-	 * And more comments are sprinkled throughout the notify functions above.
-	 */
-	wl_signal_add(&cursor->events.motion, &cursor_motion);
-	wl_signal_add(&cursor->events.motion_absolute, &cursor_motion_absolute);
-	wl_signal_add(&cursor->events.button, &cursor_button);
-	wl_signal_add(&cursor->events.axis, &cursor_axis);
-	wl_signal_add(&cursor->events.frame, &cursor_frame);
-
-	/*
-	 * Configures a seat, which is a single "seat" at which a user sits and
-	 * operates the computer. This conceptually includes up to one keyboard,
-	 * pointer, touch, and drawing tablet device. We also rig up a listener to
-	 * let us know when new input devices are available on the backend.
-	 */
-	wl_list_init(&keyboards);
-	wl_signal_add(&backend->events.new_input, &new_input);
-	virtual_keyboard_mgr = wlr_virtual_keyboard_manager_v1_create(dpy);
-	wl_signal_add(&virtual_keyboard_mgr->events.new_virtual_keyboard,
-			&new_virtual_keyboard);
-	seat = wlr_seat_create(dpy, "seat0");
-	wl_signal_add(&seat->events.request_set_cursor,
-			&request_cursor);
-	wl_signal_add(&seat->events.request_set_selection,
-			&request_set_sel);
-	wl_signal_add(&seat->events.request_set_primary_selection,
-			&request_set_psel);
-
-	output_mgr = wlr_output_manager_v1_create(dpy);
-	wl_signal_add(&output_mgr->events.apply, &output_mgr_apply);
-	wl_signal_add(&output_mgr->events.test, &output_mgr_test);
+        /* This event is raised by the seat when a client wants to set the selection,
+         * usually when the user copies something. wlroots allows compositors to
+         * ignore such requests if they so choose, but in dwl we always honor
+         */
+        struct wlr_seat_request_set_selection_event *event = data;
+        wlr_seat_set_selection(seat, event->source, event->serial);
+}
+
+int
+reloadconfig(int signal, void *data) {
+        Client *c;
+        Monitor *m;
+        char *config_file = (char*)data;
+
+        dscm_config_parse(config_file);
+
+        /* Redraw clients */
+        wl_list_for_each(c, &clients, link) {
+                if (c->bw > 0)
+                        c->bw = borderpx;
+                resize(c, c->geom.x, c->geom.y, c->geom.width, c->geom.height, 0, c->bw);
+        }
+
+        /* Rearrange clients on all monitors */
+        wl_list_for_each(m, &mons, link)
+                arrange(m);
+
+        /* Send events to observing clients, notifying of possible changes */
+        dscm_sendevents();
+
+        return 0;
+}
+
+void
+setup(char *config_file)
+{
+        /* The Wayland display is managed by libwayland. It handles accepting
+         * clients from the Unix socket, manging Wayland globals, and so on. */
+        dpy = wl_display_create();
+
+        /* Set up signal handlers */
+        sigchld(0);
+        signal(SIGINT, quitsignal);
+        signal(SIGTERM, quitsignal);
+
+        /* Block user signals so that they can be handled */
+        setupsignals();
+
+        /* The backend is a wlroots feature which abstracts the underlying input and
+         * output hardware. The autocreate option will choose the most suitable
+         * backend based on the current environment, such as opening an X11 window
+         * if an X11 server is running. The NULL argument here optionally allows you
+         * to pass in a custom renderer if wlr_renderer doesn't meet your needs. The
+         * backend uses the renderer, for example, to fall back to software cursors
+         * if the backend does not support hardware cursors (some older GPUs
+         * don't). */
+        if (!(backend = wlr_backend_autocreate(dpy)))
+                BARF("couldn't create backend");
+
+        /* If we don't provide a renderer, autocreate makes a GLES2 renderer for us.
+         * The renderer is responsible for defining the various pixel formats it
+         * supports for shared memory, this configures that for clients. */
+        drw = wlr_backend_get_renderer(backend);
+        wlr_renderer_init_wl_display(drw, dpy);
+
+        /* This creates some hands-off wlroots interfaces. The compositor is
+         * necessary for clients to allocate surfaces and the data device manager
+         * handles the clipboard. Each of these wlroots interfaces has room for you
+         * to dig your fingers in and play with their behavior if you want. Note that
+         * the clients cannot set the selection directly without compositor approval,
+         * see the setsel() function. */
+        compositor = wlr_compositor_create(dpy, drw);
+        wlr_export_dmabuf_manager_v1_create(dpy);
+        wlr_screencopy_manager_v1_create(dpy);
+        wlr_data_control_manager_v1_create(dpy);
+        wlr_data_device_manager_create(dpy);
+        wlr_gamma_control_manager_v1_create(dpy);
+        wlr_primary_selection_v1_device_manager_create(dpy);
+        wlr_viewporter_create(dpy);
+
+        /* Initializes the interface used to implement urgency hints */
+        activation = wlr_xdg_activation_v1_create(dpy);
+        wl_signal_add(&activation->events.request_activate, &request_activate);
+
+        /* Creates an output layout, which a wlroots utility for working with an
+         * arrangement of screens in a physical layout. */
+        output_layout = wlr_output_layout_create();
+        wl_signal_add(&output_layout->events.change, &layout_change);
+        wlr_xdg_output_manager_v1_create(dpy, output_layout);
+
+        /* Configure a listener to be notified when new outputs are available on the
+         * backend. */
+        wl_list_init(&mons);
+        wl_signal_add(&backend->events.new_output, &new_output);
+
+        /* Set up our client lists and the xdg-shell. The xdg-shell is a
+         * Wayland protocol which is used for application windows. For more
+         * detail on shells, refer to the article:
+         *
+         * https://drewdevault.com/2018/07/29/Wayland-shells.html
+         */
+        wl_list_init(&clients);
+        wl_list_init(&fstack);
+        wl_list_init(&stack);
+        wl_list_init(&independents);
+        wl_list_init(&subsurfaces);
+        wl_list_init(&dscm_clients);
+
+        idle = wlr_idle_create(dpy);
+
+        idle_inhibit_mgr = wlr_idle_inhibit_v1_create(dpy);
+        wl_signal_add(&idle_inhibit_mgr->events.new_inhibitor, &new_idle_inhibitor);
+
+        layer_shell = wlr_layer_shell_v1_create(dpy);
+        wl_signal_add(&layer_shell->events.new_surface, &new_layer_shell_surface);
+
+        xdg_shell = wlr_xdg_shell_create(dpy);
+        wl_signal_add(&xdg_shell->events.new_surface, &new_xdg_surface);
+
+        input_inhibit_mgr = wlr_input_inhibit_manager_create(dpy);
+
+        /* Use decoration protocols to negotiate server-side decorations */
+        wlr_server_decoration_manager_set_default_mode(
+                wlr_server_decoration_manager_create(dpy),
+                WLR_SERVER_DECORATION_MANAGER_MODE_SERVER);
+        wlr_xdg_decoration_manager_v1_create(dpy);
+
+        /*
+         * Creates a cursor, which is a wlroots utility for tracking the cursor
+         * image shown on screen.
+         */
+        cursor = wlr_cursor_create();
+        wlr_cursor_attach_output_layout(cursor, output_layout);
+
+        /* Creates an xcursor manager, another wlroots utility which loads up
+         * Xcursor themes to source cursor images from and makes sure that cursor
+         * images are available at all scale factors on the screen (necessary for
+         * HiDPI support). Scaled cursors will be loaded with each output. */
+        cursor_mgr = wlr_xcursor_manager_create(NULL, 24);
+
+        /*
+         * wlr_cursor *only* displays an image on screen. It does not move around
+         * when the pointer moves. However, we can attach input devices to it, and
+         * it will generate aggregate events for all of them. In these events, we
+         * can choose how we want to process them, forwarding them to clients and
+         * moving the cursor around. More detail on this process is described in my
+         * input handling blog post:
+         *
+         * https://drewdevault.com/2018/07/17/Input-handling-in-wlroots.html
+         *
+         * And more comments are sprinkled throughout the notify functions above.
+         */
+        wl_signal_add(&cursor->events.motion, &cursor_motion);
+        wl_signal_add(&cursor->events.motion_absolute, &cursor_motion_absolute);
+        wl_signal_add(&cursor->events.button, &cursor_button);
+        wl_signal_add(&cursor->events.axis, &cursor_axis);
+        wl_signal_add(&cursor->events.frame, &cursor_frame);
+
+        /*
+         * Configures a seat, which is a single "seat" at which a user sits and
+         * operates the computer. This conceptually includes up to one keyboard,
+         * pointer, touch, and drawing tablet device. We also rig up a listener to
+         * let us know when new input devices are available on the backend.
+         */
+        wl_list_init(&keyboards);
+        wl_signal_add(&backend->events.new_input, &new_input);
+        virtual_keyboard_mgr = wlr_virtual_keyboard_manager_v1_create(dpy);
+        wl_signal_add(&virtual_keyboard_mgr->events.new_virtual_keyboard,
+                      &new_virtual_keyboard);
+        seat = wlr_seat_create(dpy, "seat0");
+        wl_signal_add(&seat->events.request_set_cursor,
+                      &request_cursor);
+        wl_signal_add(&seat->events.request_set_selection,
+                      &request_set_sel);
+        wl_signal_add(&seat->events.request_set_primary_selection,
+                      &request_set_psel);
+        wl_signal_add(&seat->events.request_start_drag, &request_start_drag);
+        wl_signal_add(&seat->events.start_drag, &start_drag);
+
+        output_mgr = wlr_output_manager_v1_create(dpy);
+        wl_signal_add(&output_mgr->events.apply, &output_mgr_apply);
+        wl_signal_add(&output_mgr->events.test, &output_mgr_test);
+
+        struct wl_event_loop *loop = wl_display_get_event_loop(dpy);
+
+        /* Add handlers for user signals */
+        /* TODO: Add config option for adding custom handlers to signal. */
+        wl_event_loop_add_signal(loop, SIGRTMIN, &reloadconfig, config_file);
+
+        presentation = wlr_presentation_create(dpy, backend);
+        wl_global_create(dpy, &dscm_v1_interface, 1, NULL, dscm_bind);
 
 #ifdef XWAYLAND
-	/*
-	 * Initialise the XWayland X server.
-	 * It will be started when the first X client is started.
-	 */
-	xwayland = wlr_xwayland_create(dpy, compositor, 1);
-	if (xwayland) {
-		wl_signal_add(&xwayland->events.ready, &xwayland_ready);
-		wl_signal_add(&xwayland->events.new_surface, &new_xwayland_surface);
-
-		/*
-		 * Create the XWayland cursor manager at scale 1, setting its default
-		 * pointer to match the rest of dwl.
-		 */
-		xcursor_mgr = wlr_xcursor_manager_create(NULL, 24);
-		wlr_xcursor_manager_load(xcursor_mgr, 1);
-		if ((xcursor = wlr_xcursor_manager_get_xcursor(xcursor_mgr, "left_ptr", 1)))
-			wlr_xwayland_set_cursor(xwayland,
-					xcursor->images[0]->buffer, xcursor->images[0]->width * 4,
-					xcursor->images[0]->width, xcursor->images[0]->height,
-					xcursor->images[0]->hotspot_x, xcursor->images[0]->hotspot_y);
-
-		setenv("DISPLAY", xwayland->display_name, 1);
-	} else {
-		fprintf(stderr, "failed to setup XWayland X server, continuing without it\n");
-	}
+        /*
+         * Initialise the XWayland X server.
+         * It will be started when the first X client is started.
+         */
+        xwayland = wlr_xwayland_create(dpy, compositor, 1);
+        if (xwayland) {
+                wl_signal_add(&xwayland->events.ready, &xwayland_ready);
+                wl_signal_add(&xwayland->events.new_surface, &new_xwayland_surface);
+
+                setenv("DISPLAY", xwayland->display_name, 1);
+        } else {
+                fprintf(stderr, "failed to setup XWayland X server, \
+                        continuing without it\n");
+        }
 #endif
 }
 
 void
 sigchld(int unused)
 {
-	/* We should be able to remove this function in favor of a simple
-	 *     signal(SIGCHLD, SIG_IGN);
-	 * but the Xwayland implementation in wlroots currently prevents us from
-	 * setting our own disposition for SIGCHLD.
-	 */
-	if (signal(SIGCHLD, sigchld) == SIG_ERR)
-		EBARF("can't install SIGCHLD handler");
-	while (0 < waitpid(-1, NULL, WNOHANG))
-		;
+        /* We should be able to remove this function in favor of a simple
+         *     signal(SIGCHLD, SIG_IGN);
+         * but the Xwayland implementation in wlroots currently prevents us from
+         * setting our own disposition for SIGCHLD.
+         */
+        if (signal(SIGCHLD, sigchld) == SIG_ERR)
+                EBARF("can't install SIGCHLD handler");
+        while (0 < waitpid(-1, NULL, WNOHANG))
+                ;
 }
 
 void
 spawn(const Arg *arg)
 {
-	if (fork() == 0) {
-		dup2(STDERR_FILENO, STDOUT_FILENO);
-		setsid();
-		execvp(((char **)arg->v)[0], (char **)arg->v);
-		EBARF("dwl: execvp %s failed", ((char **)arg->v)[0]);
-	}
+        if (fork() == 0) {
+                dup2(STDERR_FILENO, STDOUT_FILENO);
+                setsid();
+                execvp(((char **)arg->v)[0], (char **)arg->v);
+                EBARF("dwl: execvp %s failed", ((char **)arg->v)[0]);
+        }
+}
+
+void
+dragdestroy(struct wl_listener *listener, void *data)
+{
+        drag_icon = NULL;
+        // Focus enter isn't sent during drag, so refocus the focused node.
+        focusclient(selclient(), 1);
+}
+
+void
+startdrag(struct wl_listener *listener, void *data)
+{
+        struct wlr_drag *wlr_drag = data;
+        drag_icon = wlr_drag->icon;
+
+        if (!drag_icon)
+                return;
+
+        wl_signal_add(&wlr_drag->events.destroy, &drag_destroy);
 }
 
 void
 tag(const Arg *arg)
 {
-	Client *sel = selclient();
-	if (sel && arg->ui & TAGMASK) {
-		sel->tags = arg->ui & TAGMASK;
-		focusclient(focustop(selmon), 1);
-		arrange(selmon);
-	}
-	printstatus();
+        Client *sel = selclient();
+        if (sel && arg->ui & TAGMASK) {
+                sel->tags = arg->ui & TAGMASK;
+                focusclient(focustop(selmon), 1);
+                arrange(selmon);
+        }
+        printstatus();
 }
 
 void
 tagmon(const Arg *arg)
 {
-	Client *sel = selclient();
-	if (!sel)
-		return;
-	setmon(sel, dirtomon(arg->i), 0);
+        Client *sel = selclient();
+        if (!sel)
+                return;
+        setmon(sel, dirtomon(arg->i), 0);
 }
 
 void
 tile(Monitor *m)
 {
-	unsigned int i, n = 0, h, mw, my, ty;
-	Client *c;
-
-	wl_list_for_each(c, &clients, link)
-		if (VISIBLEON(c, m) && !c->isfloating)
-			n++;
-	if (n == 0)
-		return;
-
-	if (n > m->nmaster)
-		mw = m->nmaster ? m->w.width * m->mfact : 0;
-	else
-		mw = m->w.width;
-	i = my = ty = 0;
-	wl_list_for_each(c, &clients, link) {
-		if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
-			continue;
-		if (i < m->nmaster) {
-			h = (m->w.height - my) / (MIN(n, m->nmaster) - i);
-			resize(c, m->w.x, m->w.y + my, mw, h, 0);
-			my += c->geom.height;
-		} else {
-			h = (m->w.height - ty) / (n - i);
-			resize(c, m->w.x + mw, m->w.y + ty, m->w.width - mw, h, 0);
-			ty += c->geom.height;
-		}
-		i++;
-	}
+        unsigned int i, n = 0, h, r, oe = enablegaps, ie = enablegaps, mw, my, ty,
+                enableborders = 1;
+        Client *c;
+
+        wl_list_for_each(c, &clients, link)
+                if (VISIBLEON(c, m) && !c->isfloating)
+                        n++;
+        if (n == 0)
+                return;
+
+        if (smartgaps == n)
+                oe = 0; // outer gaps disabled
+        if (smartborders == n)
+                enableborders = 0;
+
+        if (n > m->nmaster)
+                mw = m->nmaster ? (m->w.width + m->gappiv*ie) * m->mfact : 0;
+        else
+                mw = m->w.width - 2*m->gappov*oe + m->gappiv*ie;
+        i = 0;
+        my = ty = m->gappoh*oe;
+        wl_list_for_each(c, &clients, link) {
+                if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
+                        continue;
+                if (i < m->nmaster) {
+                        r = MIN(n, m->nmaster) - i;
+                        h = (m->w.height - my - m->gappoh*oe - m->gappih*ie * (r - 1)) / r;
+                        resize(c, m->w.x + m->gappov*oe, m->w.y + my,
+                               mw - m->gappiv*ie, h, 0, enableborders);
+                        my += c->geom.height + m->gappih*ie;
+                } else {
+                        r = n - i;
+                        h = (m->w.height - ty - m->gappoh*oe - m->gappih*ie * (r - 1)) / r;
+                        resize(c, m->w.x + mw + m->gappov*oe, m->w.y + ty,
+                               m->w.width - mw - 2*m->gappov*oe, h, 0, enableborders);
+                        ty += c->geom.height + m->gappih*ie;
+                }
+                i++;
+        }
 }
 
 void
 togglefloating(const Arg *arg)
 {
-	Client *sel = selclient();
-	if (!sel)
-		return;
-	/* return if fullscreen */
-	setfloating(sel, !sel->isfloating /* || sel->isfixed */);
+        Client *sel = selclient();
+        if (!sel)
+                return;
+        /* return if fullscreen */
+        setfloating(sel, !sel->isfloating /* || sel->isfixed */);
 }
 
 void
 toggletag(const Arg *arg)
 {
-	unsigned int newtags;
-	Client *sel = selclient();
-	if (!sel)
-		return;
-	newtags = sel->tags ^ (arg->ui & TAGMASK);
-	if (newtags) {
-		sel->tags = newtags;
-		focusclient(focustop(selmon), 1);
-		arrange(selmon);
-	}
-	printstatus();
+        unsigned int newtags;
+        Client *sel = selclient();
+        if (!sel)
+                return;
+        newtags = sel->tags ^ (arg->ui & TAGMASK);
+        if (newtags) {
+                sel->tags = newtags;
+                focusclient(focustop(selmon), 1);
+                arrange(selmon);
+        }
+        printstatus();
 }
 
 void
 toggleview(const Arg *arg)
 {
-	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
+        unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
 
-	if (newtagset) {
-		selmon->tagset[selmon->seltags] = newtagset;
-		focusclient(focustop(selmon), 1);
-		arrange(selmon);
-	}
-	printstatus();
+        if (newtagset) {
+                selmon->tagset[selmon->seltags] = newtagset;
+                focusclient(focustop(selmon), 1);
+                arrange(selmon);
+        }
+        printstatus();
 }
 
 void
 unmaplayersurface(LayerSurface *layersurface)
 {
-	layersurface->layer_surface->mapped = 0;
-	if (layersurface->layer_surface->surface ==
-			seat->keyboard_state.focused_surface)
-		focusclient(selclient(), 1);
-	motionnotify(0);
+        layersurface->layer_surface->mapped = 0;
+        if (layersurface->layer_surface->surface ==
+            seat->keyboard_state.focused_surface)
+                focusclient(selclient(), 1);
+        motionnotify(0);
 }
 
 void
 unmaplayersurfacenotify(struct wl_listener *listener, void *data)
 {
-	LayerSurface *layersurface = wl_container_of(listener, layersurface, unmap);
-	unmaplayersurface(layersurface);
+        LayerSurface *layersurface = wl_container_of(listener, layersurface, unmap);
+        unmaplayersurface(layersurface);
 }
 
 void
 unmapnotify(struct wl_listener *listener, void *data)
 {
-	/* Called when the surface is unmapped, and should no longer be shown. */
-	Client *c = wl_container_of(listener, c, unmap);
-	wl_list_remove(&c->link);
-	if (client_is_unmanaged(c))
-		return;
+        /* Called when the surface is unmapped, and should no longer be shown. */
+        Client *c = wl_container_of(listener, c, unmap);
+
+        // Damage the whole screen
+        if (c->mon)
+                wlr_output_damage_add_whole(c->mon->damage);
 
-	setmon(c, NULL, 0);
-	wl_list_remove(&c->flink);
-	wl_list_remove(&c->slink);
+        wl_list_remove(&c->link);
+        if (client_is_unmanaged(c))
+                return;
+
+        setmon(c, NULL, 0);
+        wl_list_remove(&c->flink);
+        wl_list_remove(&c->slink);
+        printstatus();
+}
+
+void
+unmapnotify_sub(struct wl_listener *listener, void *data)
+{
+        Subsurface *s = wl_container_of(listener, s, unmap);
+        wl_list_remove(&s->link);
 }
 
 void
 updatemons(struct wl_listener *listener, void *data)
 {
-	/*
-	 * Called whenever the output layout changes: adding or removing a
-	 * monitor, changing an output's mode or position, etc.  This is where
-	 * the change officially happens and we update geometry, window
-	 * positions, focus, and the stored configuration in wlroots'
-	 * output-manager implementation.
-	 */
-	struct wlr_output_configuration_v1 *config =
-		wlr_output_configuration_v1_create();
-	Monitor *m;
-	sgeom = *wlr_output_layout_get_box(output_layout, NULL);
-	wl_list_for_each(m, &mons, link) {
-		struct wlr_output_configuration_head_v1 *config_head =
-			wlr_output_configuration_head_v1_create(config, m->wlr_output);
-
-		/* TODO: move clients off disabled monitors */
-		/* TODO: move focus if selmon is disabled */
-
-		/* Get the effective monitor geometry to use for surfaces */
-		m->m = m->w = *wlr_output_layout_get_box(output_layout, m->wlr_output);
-		/* Calculate the effective monitor geometry to use for clients */
-		arrangelayers(m);
-		/* Don't move clients to the left output when plugging monitors */
-		arrange(m);
-
-		config_head->state.enabled = m->wlr_output->enabled;
-		config_head->state.mode = m->wlr_output->current_mode;
-		config_head->state.x = m->m.x;
-		config_head->state.y = m->m.y;
-	}
-
-	wlr_output_manager_v1_set_configuration(output_mgr, config);
+        /*
+         * Called whenever the output layout changes: adding or removing a
+         * monitor, changing an output's mode or position, etc.  This is where
+         * the change officially happens and we update geometry, window
+         * positions, focus, and the stored configuration in wlroots'
+         * output-manager implementation.
+         */
+        struct wlr_output_configuration_v1 *config =
+                wlr_output_configuration_v1_create();
+        Monitor *m;
+        sgeom = *wlr_output_layout_get_box(output_layout, NULL);
+        wl_list_for_each(m, &mons, link) {
+                struct wlr_output_configuration_head_v1 *config_head =
+                        wlr_output_configuration_head_v1_create(config, m->wlr_output);
+
+                /* TODO: move clients off disabled monitors */
+                /* TODO: move focus if selmon is disabled */
+
+                /* Get the effective monitor geometry to use for surfaces */
+                m->m = m->w = *wlr_output_layout_get_box(output_layout, m->wlr_output);
+                /* Calculate the effective monitor geometry to use for clients */
+                arrangelayers(m);
+                /* Don't move clients to the left output when plugging monitors */
+                arrange(m);
+
+                config_head->state.enabled = m->wlr_output->enabled;
+                config_head->state.mode = m->wlr_output->current_mode;
+                config_head->state.x = m->m.x;
+                config_head->state.y = m->m.y;
+        }
+
+        wlr_output_manager_v1_set_configuration(output_mgr, config);
+}
+
+void
+updatetitle(struct wl_listener *listener, void *data)
+{
+        Client *c = wl_container_of(listener, c, set_title);
+        if (c == focustop(c->mon))
+                printstatus();
 }
 
+void
+urgent(struct wl_listener *listener, void *data)
+{
+        struct wlr_xdg_activation_v1_request_activate_event *event = data;
+        Client *c;
+
+        if (!wlr_surface_is_xdg_surface(event->surface))
+                return;
+        c = wlr_xdg_surface_from_wlr_surface(event->surface)->data;
+        if (c != selclient()) {
+                c->isurgent = 1;
+                printstatus();
+        }
+}
+
+
 void
 view(const Arg *arg)
 {
-	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
-		return;
-	selmon->seltags ^= 1; /* toggle sel tagset */
-	if (arg->ui & TAGMASK)
-		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
-	focusclient(focustop(selmon), 1);
-	arrange(selmon);
-	printstatus();
+        unsigned int currtagset = selmon->tagset[selmon->seltags];
+        if ((arg->ui & TAGMASK) == currtagset)
+                return;
+        selmon->prevtagset = currtagset;
+        selmon->seltags ^= 1; /* toggle sel tagset */
+        if (arg->ui & TAGMASK)
+                selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+        focusclient(focustop(selmon), 1);
+        arrange(selmon);
+        printstatus();
+}
+
+void
+viewprev(const Arg *arg)
+{
+        unsigned int tagset = selmon->tagset[selmon->seltags];
+        selmon->tagset[selmon->seltags] = selmon->prevtagset;
+        selmon->prevtagset = tagset;
+        focusclient(focustop(selmon), 1);
+        arrange(selmon);
+        printstatus();
 }
 
 void
 virtualkeyboard(struct wl_listener *listener, void *data)
 {
-	struct wlr_virtual_keyboard_v1 *keyboard = data;
-	struct wlr_input_device *device = &keyboard->input_device;
-	createkeyboard(device);
+        struct wlr_virtual_keyboard_v1 *keyboard = data;
+        struct wlr_input_device *device = &keyboard->input_device;
+        createkeyboard(device);
+}
+
+void
+writepid(const char *runtimedir)
+{
+        /* Writes a pid file so that services managers like Shepherd
+         * can provision dwl-guile correcly to other services that
+         * depend on an existing wayland display. */
+        char buf[128];
+        FILE *pidfile;
+        snprintf(buf, 128, "%s/dwl-guile.pid", runtimedir);
+        pidfile = fopen(buf, "w");
+        fprintf(pidfile, "%d", getpid());
+        fclose(pidfile);
 }
 
 Client *
 xytoclient(double x, double y)
 {
-	/* Find the topmost visible client (if any) at point (x, y), including
-	 * borders. This relies on stack being ordered from top to bottom. */
-	Client *c;
-	wl_list_for_each(c, &stack, slink)
-		if (VISIBLEON(c, c->mon) && wlr_box_contains_point(&c->geom, x, y))
-			return c;
-	return NULL;
+        /* Find the topmost visible client (if any) at point (x, y), excluding
+         * borders. This relies on stack being ordered from top to bottom. */
+        Client *c;
+        wl_list_for_each(c, &stack, slink) {
+                struct wlr_box p = {
+                        .y = c->geom.y + borderpx,
+                        .x = c->geom.x + borderpx,
+                        .height = c->geom.height - 2 * borderpx,
+                        .width = c->geom.width - 2 * borderpx,
+                };
+                if (VISIBLEON(c, c->mon) && wlr_box_contains_point(&p, x, y))
+                        return c;
+        }
+        return NULL;
 }
 
 struct wlr_surface *
 xytolayersurface(struct wl_list *layer_surfaces, double x, double y,
-		double *sx, double *sy)
+                 double *sx, double *sy)
 {
-	LayerSurface *layersurface;
-	wl_list_for_each_reverse(layersurface, layer_surfaces, link) {
-		struct wlr_surface *sub;
-		if (!layersurface->layer_surface->mapped)
-			continue;
-		sub = wlr_layer_surface_v1_surface_at(
-				layersurface->layer_surface,
-				x - layersurface->geo.x,
-				y - layersurface->geo.y,
-				sx, sy);
-		if (sub)
-			return sub;
+        LayerSurface *layersurface;
+        wl_list_for_each_reverse(layersurface, layer_surfaces, link) {
+                struct wlr_surface *sub;
+                if (!layersurface->layer_surface->mapped)
+                        continue;
+                sub = wlr_layer_surface_v1_surface_at(
+                        layersurface->layer_surface,
+                        x - layersurface->geo.x,
+                        y - layersurface->geo.y,
+                        sx, sy);
+                if (sub)
+                        return sub;
 
-	}
-	return NULL;
+        }
+        return NULL;
 }
 
 Monitor *
 xytomon(double x, double y)
 {
-	struct wlr_output *o = wlr_output_layout_output_at(output_layout, x, y);
-	return o ? o->data : NULL;
+        struct wlr_output *o = wlr_output_layout_output_at(output_layout, x, y);
+        return o ? o->data : NULL;
 }
 
 void
 zoom(const Arg *arg)
 {
-	Client *c, *sel = selclient();
+        Client *c, *sel = selclient();
 
-	if (!sel || !selmon->lt[selmon->sellt]->arrange || sel->isfloating)
-		return;
+        if (!sel || !selmon->lt[selmon->sellt]->arrange || sel->isfloating)
+                return;
 
-	/* Search for the first tiled window that is not sel, marking sel as
-	 * NULL if we pass it along the way */
-	wl_list_for_each(c, &clients, link)
-		if (VISIBLEON(c, selmon) && !c->isfloating) {
-			if (c != sel)
-				break;
-			sel = NULL;
-		}
+        /* Search for the first tiled window that is not sel, marking sel as
+         * NULL if we pass it along the way */
+        wl_list_for_each(c, &clients, link)
+                if (VISIBLEON(c, selmon) && !c->isfloating) {
+                        if (c != sel)
+                                break;
+                        sel = NULL;
+                }
 
-	/* Return if no other tiled window was found */
-	if (&c->link == &clients)
-		return;
+        /* Return if no other tiled window was found */
+        if (&c->link == &clients)
+                return;
 
-	/* If we passed sel, move c to the front; otherwise, move sel to the
-	 * front */
-	if (!sel)
-		sel = c;
-	wl_list_remove(&sel->link);
-	wl_list_insert(&clients, &sel->link);
+        /* If we passed sel, move c to the front; otherwise, move sel to the
+         * front */
+        if (!sel)
+                sel = c;
+        wl_list_remove(&sel->link);
+        wl_list_insert(&clients, &sel->link);
 
-	focusclient(sel, 1);
-	arrange(selmon);
+        focusclient(sel, 1);
+        arrange(selmon);
 }
 
 #ifdef XWAYLAND
 void
 activatex11(struct wl_listener *listener, void *data)
 {
-	Client *c = wl_container_of(listener, c, activate);
+        Client *c = wl_container_of(listener, c, activate);
 
-	/* Only "managed" windows can be activated */
-	if (c->type == X11Managed)
-		wlr_xwayland_surface_activate(c->surface.xwayland, 1);
+        /* Only "managed" windows can be activated */
+        if (c->type == X11Managed)
+                wlr_xwayland_surface_activate(c->surface.xwayland, 1);
 }
 
 void
 configurex11(struct wl_listener *listener, void *data)
 {
-	Client *c = wl_container_of(listener, c, configure);
-	struct wlr_xwayland_surface_configure_event *event = data;
-	wlr_xwayland_surface_configure(c->surface.xwayland,
-			event->x, event->y, event->width, event->height);
+        Client *c = wl_container_of(listener, c, configure);
+        struct wlr_xwayland_surface_configure_event *event = data;
+        wlr_xwayland_surface_configure(c->surface.xwayland,
+                                       event->x, event->y, event->width, event->height);
 }
 
 void
 createnotifyx11(struct wl_listener *listener, void *data)
 {
-	struct wlr_xwayland_surface *xwayland_surface = data;
-	Client *c;
-	wl_list_for_each(c, &clients, link)
-		if (c->isfullscreen && VISIBLEON(c, c->mon))
-			setfullscreen(c, 0);
-
-	/* Allocate a Client for this surface */
-	c = xwayland_surface->data = calloc(1, sizeof(*c));
-	c->surface.xwayland = xwayland_surface;
-	c->type = xwayland_surface->override_redirect ? X11Unmanaged : X11Managed;
-	c->bw = borderpx;
-	c->isfullscreen = 0;
-
-	/* Listen to the various events it can emit */
-	LISTEN(&xwayland_surface->events.map, &c->map, mapnotify);
-	LISTEN(&xwayland_surface->events.unmap, &c->unmap, unmapnotify);
-	LISTEN(&xwayland_surface->events.request_activate, &c->activate,
-			activatex11);
-	LISTEN(&xwayland_surface->events.request_configure, &c->configure,
-			configurex11);
-	LISTEN(&xwayland_surface->events.destroy, &c->destroy, destroynotify);
-	LISTEN(&xwayland_surface->events.request_fullscreen, &c->fullscreen,
-			fullscreennotify);
+        struct wlr_xwayland_surface *xwayland_surface = data;
+        Client *c;
+        wl_list_for_each(c, &clients, link)
+                if (c->isfullscreen && VISIBLEON(c, c->mon))
+                        setfullscreen(c, 0);
+
+        /* Allocate a Client for this surface */
+        c = xwayland_surface->data = calloc(1, sizeof(*c));
+        c->surface.xwayland = xwayland_surface;
+        c->type = xwayland_surface->override_redirect ? X11Unmanaged : X11Managed;
+        c->bw = borderpx;
+        c->isfullscreen = 0;
+        c->alpha = default_alpha;
+
+        /* Listen to the various events it can emit */
+        if (c->type == X11Managed) {
+                LISTEN(&xwayland_surface->events.map, &c->map, mapnotify);
+                LISTEN(&xwayland_surface->events.request_activate, &c->activate,
+                       activatex11);
+                LISTEN(&xwayland_surface->events.set_title, &c->set_title, updatetitle);
+                LISTEN(&xwayland_surface->events.request_fullscreen, &c->fullscreen,
+                       fullscreennotify);
+        }
+        else {
+                LISTEN(&xwayland_surface->events.map, &c->map, mapnotify_unmanaged);
+        }
+        LISTEN(&xwayland_surface->events.unmap, &c->unmap, unmapnotify);
+        LISTEN(&xwayland_surface->events.request_configure, &c->configure,
+               configurex11);
+        LISTEN(&xwayland_surface->events.set_title, &c->set_title, updatetitle);
+        LISTEN(&xwayland_surface->events.destroy, &c->destroy, destroynotify);
+}
+
+void
+commitnotifyx11(struct wl_listener *listener, void *data)
+{
+        Client *c = wl_container_of(listener, c, commit);
+
+        // Damage the whole screen
+        wlr_output_damage_add_whole(c->mon->damage);
 }
 
 Atom
 getatom(xcb_connection_t *xc, const char *name)
 {
-	Atom atom = 0;
-	xcb_intern_atom_reply_t *reply;
-	xcb_intern_atom_cookie_t cookie = xcb_intern_atom(xc, 0, strlen(name), name);
-	if ((reply = xcb_intern_atom_reply(xc, cookie, NULL)))
-		atom = reply->atom;
-	free(reply);
+        Atom atom = 0;
+        xcb_intern_atom_reply_t *reply;
+        xcb_intern_atom_cookie_t cookie = xcb_intern_atom(xc, 0, strlen(name), name);
+        if ((reply = xcb_intern_atom_reply(xc, cookie, NULL)))
+                atom = reply->atom;
+        free(reply);
 
-	return atom;
+        return atom;
 }
 
+void
+mapnotify_unmanaged(struct wl_listener *listener, void *data)
+{
+        Client *c = wl_container_of(listener, c, map);
+        wl_list_insert(&independents, &c->link);
+        client_get_geometry(c, &c->geom);
+        c->mon = xytomon(c->geom.x, c->geom.y);
+        LISTEN(&c->surface.xwayland->surface->events.commit, &c->commit, commitnotifyx11);
+        wlr_output_damage_add_whole(c->mon->damage);
+}
+
+
 void
 renderindependents(struct wlr_output *output, struct timespec *now)
 {
-	Client *c;
-	struct render_data rdata;
-	struct wlr_box geom;
+        Client *c;
+        struct render_data rdata;
+        struct wlr_box geom;
 
-	wl_list_for_each_reverse(c, &independents, link) {
-		geom.x = c->surface.xwayland->x;
-		geom.y = c->surface.xwayland->y;
-		geom.width = c->surface.xwayland->width;
-		geom.height = c->surface.xwayland->height;
+        wl_list_for_each_reverse(c, &independents, link) {
+                geom.x = c->surface.xwayland->x;
+                geom.y = c->surface.xwayland->y;
+                geom.width = c->surface.xwayland->width;
+                geom.height = c->surface.xwayland->height;
 
-		/* Only render visible clients which show on this output */
-		if (!wlr_output_layout_intersects(output_layout, output, &geom))
-			continue;
+                /* Only render visible clients which show on this output */
+                if (!wlr_output_layout_intersects(output_layout, output, &geom))
+                        continue;
 
-		rdata.output = output;
-		rdata.when = now;
-		rdata.x = c->surface.xwayland->x;
-		rdata.y = c->surface.xwayland->y;
-		wlr_surface_for_each_surface(c->surface.xwayland->surface, render, &rdata);
-	}
+                rdata.output = output;
+                rdata.when = now;
+                rdata.x = c->surface.xwayland->x;
+                rdata.y = c->surface.xwayland->y;
+                rdata.alpha = c->alpha;
+
+                wlr_surface_for_each_surface(c->surface.xwayland->surface, render, &rdata);
+        }
 }
 
 void
 xwaylandready(struct wl_listener *listener, void *data)
 {
-	struct wlr_xcursor *xcursor;
-	xcb_connection_t *xc = xcb_connect(xwayland->display_name, NULL);
-	int err = xcb_connection_has_error(xc);
-	if (err) {
-		fprintf(stderr, "xcb_connect to X server failed with code %d\n. Continuing with degraded functionality.\n", err);
-		return;
-	}
+        struct wlr_xcursor *xcursor;
+        xcb_connection_t *xc = xcb_connect(xwayland->display_name, NULL);
+        int err = xcb_connection_has_error(xc);
+        if (err) {
+                fprintf(stderr, "xcb_connect to X server failed with code %d\n. \
+                        Continuing with degraded functionality.\n", err);
+                return;
+        }
+
+        /* Collect atoms we are interested in.  If getatom returns 0, we will
+         * not detect that window type. */
+        netatom[NetWMWindowTypeDialog] = getatom(xc, "_NET_WM_WINDOW_TYPE_DIALOG");
+        netatom[NetWMWindowTypeSplash] = getatom(xc, "_NET_WM_WINDOW_TYPE_SPLASH");
+        netatom[NetWMWindowTypeToolbar] = getatom(xc, "_NET_WM_WINDOW_TYPE_TOOLBAR");
+        netatom[NetWMWindowTypeUtility] = getatom(xc, "_NET_WM_WINDOW_TYPE_UTILITY");
+
+        /* assign the one and only seat */
+        wlr_xwayland_set_seat(xwayland, seat);
+
+        /* Set the default XWayland cursor to match the rest of dwl. */
+        if ((xcursor = wlr_xcursor_manager_get_xcursor(cursor_mgr, "left_ptr", 1)))
+                wlr_xwayland_set_cursor(xwayland,
+                                        xcursor->images[0]->buffer,
+                                        xcursor->images[0]->width * 4,
+                                        xcursor->images[0]->width,
+                                        xcursor->images[0]->height,
+                                        xcursor->images[0]->hotspot_x,
+                                        xcursor->images[0]->hotspot_y);
+
+        xcb_disconnect(xc);
+}
 
-	/* Collect atoms we are interested in.  If getatom returns 0, we will
-	 * not detect that window type. */
-	netatom[NetWMWindowTypeDialog] = getatom(xc, "_NET_WM_WINDOW_TYPE_DIALOG");
-	netatom[NetWMWindowTypeSplash] = getatom(xc, "_NET_WM_WINDOW_TYPE_SPLASH");
-	netatom[NetWMWindowTypeToolbar] = getatom(xc, "_NET_WM_WINDOW_TYPE_TOOLBAR");
-	netatom[NetWMWindowTypeUtility] = getatom(xc, "_NET_WM_WINDOW_TYPE_UTILITY");
+Client *
+xytoindependent(double x, double y)
+{
+        /* Find the topmost visible independent at point (x, y).
+         * For independents, the most recently created can be used as the "top".
+         * We rely on the X11 convention of unmapping unmanaged when the "owning"
+         * client loses focus, which ensures that unmanaged are only visible on
+         * the current tag. */
+        Client *c;
+        wl_list_for_each_reverse(c, &independents, link) {
+                struct wlr_box geom = {
+                        .x = c->surface.xwayland->x,
+                        .y = c->surface.xwayland->y,
+                        .width = c->surface.xwayland->width,
+                        .height = c->surface.xwayland->height,
+                };
+                if (wlr_box_contains_point(&geom, x, y))
+                        return c;
+        }
+        return NULL;
+}
+#endif
 
-	/* assign the one and only seat */
-	wlr_xwayland_set_seat(xwayland, seat);
+void
+dscm_sendeventsclient(DscmClient *c)
+{
+        char root[HEXLENGTH], border[HEXLENGTH],
+                focus[HEXLENGTH], text[HEXLENGTH];
 
-	/* Set the default XWayland cursor to match the rest of dwl. */
-	if ((xcursor = wlr_xcursor_manager_get_xcursor(cursor_mgr, "left_ptr", 1)))
-		wlr_xwayland_set_cursor(xwayland,
-				xcursor->images[0]->buffer, xcursor->images[0]->width * 4,
-				xcursor->images[0]->width, xcursor->images[0]->height,
-				xcursor->images[0]->hotspot_x, xcursor->images[0]->hotspot_y);
+        for (int i = 0; i < numtags; i++)
+                dscm_v1_send_tag(c->resource, tags[i]);
+        for (int i = 0; i < numlayouts; i++)
+                dscm_v1_send_layout(c->resource, layouts[i].symbol);
 
-	xcb_disconnect(xc);
+        dscm_rgbatostr(root, rootcolor);
+        dscm_rgbatostr(border, bordercolor);
+        dscm_rgbatostr(focus, focuscolor);
+        dscm_rgbatostr(text, textcolor);
+        dscm_v1_send_colorscheme(c->resource, root, border, focus, text);
 }
 
-Client *
-xytoindependent(double x, double y)
+void
+dscm_sendevents(void)
 {
-	/* Find the topmost visible independent at point (x, y).
-	 * For independents, the most recently created can be used as the "top".
-	 * We rely on the X11 convention of unmapping unmanaged when the "owning"
-	 * client loses focus, which ensures that unmanaged are only visible on
-	 * the current tag. */
-	Client *c;
-	wl_list_for_each_reverse(c, &independents, link) {
-		struct wlr_box geom = {
-			.x = c->surface.xwayland->x,
-			.y = c->surface.xwayland->y,
-			.width = c->surface.xwayland->width,
-			.height = c->surface.xwayland->height,
-		};
-		if (wlr_box_contains_point(&geom, x, y))
-			return c;
-	}
-	return NULL;
+        DscmClient *c;
+        wl_list_for_each(c, &dscm_clients, link)
+                dscm_sendeventsclient(c);
+}
+
+void
+dscm_rgbatostr(char *buf, float *color)
+{
+        if (!color)
+                return;
+
+        unsigned int r, g, b, a;
+        r = MAX(0, MIN(255, (int)ROUND(color[0] * 256.0)));
+        g = MAX(0, MIN(255, (int)ROUND(color[1] * 256.0)));
+        b = MAX(0, MIN(255, (int)ROUND(color[2] * 256.0)));
+        a = MAX(0, MIN(255, (int)ROUND(color[3] * 256.0)));
+        snprintf(buf, HEXLENGTH, "%02X%02X%02X%02X", r, g, b, a);
+}
+
+void
+dscm_closemon(struct wl_client *client, struct wl_resource *resource)
+{
+        wl_resource_destroy(resource);
+}
+
+void
+dscm_destroymon(struct wl_resource *resource) {
+        DscmMonitor *mon = wl_resource_get_user_data(resource);
+        if (mon) {
+                wl_list_remove(&mon->link);
+                free(mon);
+        }
+}
+
+void
+dscm_printstatusmon(Monitor *m, const DscmMonitor *mon)
+{
+        Client *c, *focused;
+        int tagmask, state, numclients, focusedclient;
+        focused = focustop(m);
+        dscm_monitor_v1_send_selected(mon->resource, m == selmon);
+
+        for (int tag = 0; tag < numtags; tag++) {
+                numclients = state = 0;
+                focusedclient = -1;
+                tagmask = 1 << tag;
+                if ((tagmask & m->tagset[m->seltags]) != 0)
+                        state = state | DSCM_MONITOR_V1_TAG_STATE_ACTIVE;
+                wl_list_for_each(c, &clients, link) {
+                        if (c->mon != m)
+                                continue;
+                        if (!(c->tags & tagmask))
+                                continue;
+                        if (c == focused)
+                                focusedclient = numclients;
+                        numclients++;
+                        if (c->isurgent)
+                                state = state | DSCM_MONITOR_V1_TAG_STATE_URGENT;
+                }
+                dscm_monitor_v1_send_tag(mon->resource, tag, state,
+                                         numclients, focusedclient);
+        }
+        dscm_monitor_v1_send_layout(mon->resource, m->lt[m->sellt] - layouts);
+        dscm_monitor_v1_send_title(mon->resource, focused ?
+                                   client_get_title(focused) : "");
+        dscm_monitor_v1_send_frame(mon->resource);
+}
+
+void
+dscm_printstatus(Monitor *m)
+{
+        DscmMonitor *mon;
+        wl_list_for_each(mon, &m->dscm, link)
+                dscm_printstatusmon(m, mon);
+}
+
+void
+dscm_settags(struct wl_client *client, struct wl_resource *resource,
+             uint32_t t, uint32_t toggletagset)
+{
+        DscmMonitor *mon;
+        Monitor *m;
+        mon = wl_resource_get_user_data(resource);
+        if (!mon)
+                return;
+        m = mon->monitor;
+        if ((t & TAGMASK) == m->tagset[m->seltags])
+                return;
+        if (toggletagset)
+                m->seltags ^= 1;
+        if (t & TAGMASK)
+                m->tagset[m->seltags] = t & TAGMASK;
+
+        focusclient(focustop(m), 1);
+        arrange(m);
+        printstatus();
+}
+
+void
+dscm_setlayout(struct wl_client *client, struct wl_resource *resource,
+               uint32_t layout)
+{
+        DscmMonitor *mon;
+        Monitor *m;
+        mon = wl_resource_get_user_data(resource);
+        if (!mon)
+                return;
+        m = mon->monitor;
+        if (layout >= numlayouts)
+                return;
+        if (layout != m->lt[m->sellt] - layouts)
+                m->sellt ^= 1;
+
+        m->lt[m->sellt] = &layouts[layout];
+        arrange(m);
+        printstatus();
+}
+
+void
+dscm_setclient(struct wl_client *client, struct wl_resource *resource,
+               uint32_t and, uint32_t xor)
+{
+        DscmMonitor *mon;
+        Client *sel;
+        unsigned int newtags;
+        mon = wl_resource_get_user_data(resource);
+        if (!mon)
+                return;
+        sel = focustop(mon->monitor);
+        if (!sel)
+                return;
+        newtags = (sel->tags & and) ^ xor;
+        if (newtags) {
+                sel->tags = newtags;
+                focusclient(focustop(selmon), 1);
+                arrange(selmon);
+                printstatus();
+        }
+}
+
+void
+dscm_release(struct wl_client *client, struct wl_resource *resource)
+{
+        wl_resource_destroy(resource);
+}
+
+void
+dscm_getmon(struct wl_client *client, struct wl_resource *resource,
+            uint32_t id, struct wl_resource *output)
+{
+        DscmMonitor *mon;
+        struct wlr_output *wlr_output = wlr_output_from_resource(output);
+        struct Monitor *m = wlr_output->data;
+        struct wl_resource *dscm_monitor_resource = wl_resource_create(
+                client,
+                &dscm_monitor_v1_interface, wl_resource_get_version(resource), id);
+        if (!resource) {
+                wl_client_post_no_memory(client);
+                return;
+        }
+        mon = calloc(1, sizeof(DscmMonitor));
+        mon->resource = dscm_monitor_resource;
+        mon->monitor = m;
+        wl_resource_set_implementation(dscm_monitor_resource, &dscm_monitor_implementation,
+                                       mon, dscm_destroymon);
+        wl_list_insert(&m->dscm, &mon->link);
+        dscm_printstatusmon(m, mon);
+}
+
+void
+dscm_destroy(struct wl_resource *resource)
+{
+        DscmClient *c = wl_resource_get_user_data(resource);
+        if (c) {
+                wl_list_remove(&c->link);
+                free(c);
+        }
+}
+
+void
+dscm_bind(struct wl_client *client, void *data, uint32_t version, uint32_t id)
+{
+        DscmClient *c;
+        struct wl_resource *resource = wl_resource_create(
+                client,
+                &dscm_v1_interface, version, id);
+        if (!resource) {
+                wl_client_post_no_memory(client);
+                return;
+        }
+
+        c = calloc(1, sizeof(DscmClient));
+        c->resource = resource;
+        wl_resource_set_implementation(resource, &dscm_implementation, c, dscm_destroy);
+        wl_list_insert(&dscm_clients, &c->link);
+        dscm_sendevents();
 }
-#endif
 
 int
 main(int argc, char *argv[])
 {
-	char *startup_cmd = NULL;
-	int c;
-
-	while ((c = getopt(argc, argv, "s:h")) != -1) {
-		if (c == 's')
-			startup_cmd = optarg;
-		else
-			goto usage;
-	}
-	if (optind < argc)
-		goto usage;
-
-	// Wayland requires XDG_RUNTIME_DIR for creating its communications
-	// socket
-	if (!getenv("XDG_RUNTIME_DIR"))
-		BARF("XDG_RUNTIME_DIR must be set");
-	setup();
-	run(startup_cmd);
-	cleanup();
-	return EXIT_SUCCESS;
-
+        int c;
+        char *startup_cmd = NULL, *config_file = NULL, *runtimedir = NULL;
+
+        while ((c = getopt(argc, argv, "s:c:h")) != -1) {
+                if (c == 's')
+                        startup_cmd = optarg;
+                else if (c == 'c')
+                        config_file = optarg;
+                else
+                        goto usage;
+        }
+        if (optind < argc)
+                goto usage;
+
+        // Wayland requires XDG_RUNTIME_DIR for creating its communications
+        // socket
+        if (!(runtimedir = getenv("XDG_RUNTIME_DIR")))
+                BARF("XDG_RUNTIME_DIR must be set");
+        if (!config_file)
+                BARF("error: config path must be set using '-c'");
+        scm_init_guile();
+        dscm_register();
+        dscm_config_parse(config_file);
+        setup(config_file);
+        writepid(runtimedir);
+        run(startup_cmd);
+        dscm_config_cleanup();
+        cleanup();
+        return EXIT_SUCCESS;
 usage:
-	BARF("Usage: %s [-s startup command]", argv[0]);
+        BARF("Usage: %s [-c path to config.scm] [-s startup command]", argv[0]);
 }
diff --git a/guix.scm b/guix.scm
new file mode 100644
index 0000000..b66dcd3
--- /dev/null
+++ b/guix.scm
@@ -0,0 +1,38 @@
+(use-modules (dwl-guile packages)
+             (guix gexp)
+             (guix utils)
+             (guix packages)
+             (guix git-download)
+             (gnu packages wm)
+             (gnu packages guile))
+
+(define this-directory
+  (dirname (current-filename)))
+
+(define source
+  (local-file this-directory
+              #:recursive? #t
+              #:select? (git-predicate this-directory)))
+
+(package
+  (inherit dwl)
+  (source source)
+  (name "dwl-guile-devel")
+  (inputs
+    `(("guile-3.0" ,guile-3.0)
+      ("wlroots" ,wlroots)))
+  (arguments
+    (substitute-keyword-arguments
+      (package-arguments dwl)
+      ((#:phases phases)
+       `(modify-phases
+          ,phases
+            (replace
+              'install
+              (lambda*
+                (#:key inputs outputs #:allow-other-keys)
+                (let ((bin (string-append (assoc-ref outputs "out") "/bin")))
+                  (install-file "dwl" bin)
+                  (rename-file (string-append bin "/dwl")
+                               (string-append bin "/dwl-guile-devel"))
+                  #t))))))))
diff --git a/protocols/dscm-unstable-v1.xml b/protocols/dscm-unstable-v1.xml
new file mode 100644
index 0000000..c8fd797
--- /dev/null
+++ b/protocols/dscm-unstable-v1.xml
@@ -0,0 +1,177 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="dscm_unstable_v1">
+    <copyright>
+        Copyright (c) 2021 Raphael Robatsch
+        Copyright (c) 2021 Fredrik Engstrand
+
+        Permission is hereby granted, free of charge, to any person obtaining a
+        copy of this software and associated documentation files (the
+        "Software"), to deal in the Software without restriction, including
+        without limitation the rights to use, copy, modify, merge, publish,
+        distribute, sublicense, and/or sell copies of the Software, and to
+        permit persons to whom the Software is furnished to do so, subject to
+        the following conditions:
+
+        The above copyright notice and this permission notice (including the
+        next paragraph) shall be included in all copies or substantial portions
+        of the Software.
+
+        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+    </copyright>
+
+    <interface name="dscm_v1" version="1">
+        <description summary="control the dwl state">
+            This interface is exposed as a global in the wl_registry.
+
+            Clients can use this protocol to receive updates of the window manager
+            state (active tags, active layout, and focused window).
+            Clients can also control this state.
+
+            After binding, the client will receive the available tags and layouts
+            with the 'tag' and 'layout' events. These can be used in subsequent
+            dscm_monitor_v1.set_tags/set_layout requests, and to interpret the
+            dscm_monitor_v1.layout/tag events.
+        </description>
+
+        <request name="release" type="destructor">
+            <description summary="release dscm">
+                This request indicates that the client will not use the dscm
+                object any more. Objects that have been created through this instance
+                are not affected.
+            </description>
+        </request>
+
+        <request name="get_monitor">
+            <description summary="gets a dwl monitor from an output">
+                Gets a dscm monitor for the specified output. The window manager
+                state on the output can be controlled using the monitor.
+            </description>
+            <arg name="id" type="new_id" interface="dscm_monitor_v1" />
+            <arg name="output" type="object" interface="wl_output" />
+        </request>
+
+        <event name="tag">
+            <description summary="announces the presence of a tag">
+                This event is sent immediately after binding.
+                A roundtrip after binding guarantees that the client has received all tags.
+            </description>
+            <arg name="name" type="string"/>
+        </event>
+
+        <event name="layout">
+            <description summary="announces the presence of a layout">
+                This event is sent immediately after binding.
+                A roundtrip after binding guarantees that the client has received all layouts.
+            </description>
+            <arg name="name" type="string"/>
+        </event>
+
+        <event name="colorscheme">
+            <description summary="announces the current colorscheme">
+                This event is sent immediately after binding and will be resent
+                everytime the colorscheme changes. A roundtrip after binding
+                guarantees that the client has received the colorscheme.
+            </description>
+            <arg name="root" type="string" />
+            <arg name="border" type="string" />
+            <arg name="focus" type="string" />
+            <arg name="text" type="string" />
+        </event>
+    </interface>
+
+    <interface name="dscm_monitor_v1" version="1">
+        <description summary="control one monitor">
+            Observes and controls one monitor.
+
+            Events are double-buffered: Clients should cache all events and only
+            redraw themselves once the 'frame' event is sent.
+
+            Requests are not double-buffered: The compositor will update itself
+            immediately.
+        </description>
+
+        <enum name="tag_state">
+            <entry name="none" value="0" summary="no state"/>
+            <entry name="active" value="1" summary="tag is active"/>
+            <entry name="urgent" value="2" summary="tag has at least one urgent client"/>
+        </enum>
+
+        <request name="release" type="destructor">
+            <description summary="release dscm_monitor">
+                This request indicates that the client is done with this dscm_monitor.
+                All further requests are ignored.
+            </description>
+        </request>
+
+        <event name="selected">
+            <description summary="updates the selected state of the monitor">
+                If 'selected' is nonzero, this monitor is the currently selected one.
+            </description>
+            <arg name="selected" type="uint"/>
+        </event>
+
+        <event name="tag">
+            <description summary="updates the state of one tag">
+                Announces the update of a tag. num_clients and focused_client can be
+                used to draw client indicators.
+            </description>
+            <arg name="tag" type="uint" summary="index of a tag received by the dscm_v1.tag event." />
+            <arg name="state" type="uint" enum="tag_state"/>
+            <arg name="num_clients" type="uint" summary="number of clients on this tag"/>
+            <arg name="focused_client" type="int" summary="out of num_clients. -1 if there is no focused client"/>
+        </event>
+
+        <event name="layout">
+            <description summary="updates the selected layout">
+                Announces the update of the selected layout.
+            </description>
+            <arg name="layout" type="uint" summary="index of a layout received by the dscm_v1.layout event."/>
+        </event>
+
+        <event name="title">
+            <description summary="updates the focused client">
+                Announces the update of the selected client.
+            </description>
+            <arg name="title" type="string"/>
+        </event>
+
+        <event name="frame">
+            <description summary="end of status update sequence">
+                Sent after all other events belonging to the status update has been sent.
+                Clients should redraw themselves now.
+            </description>
+        </event>
+
+        <request name="set_tags">
+            <description summary="sets the active tags on this monitor.">
+                Changes are applied immediately.
+            </description>
+            <arg name="tagmask" type="uint" summary="bitmask of the tags that should be set."/>
+            <arg name="toggle_tagset" type="uint"/>
+        </request>
+
+        <request name="set_client_tags">
+            <description summary="updates the tags of the focused client.">
+                tags are updated as follows:
+                new_tags = (current_tags AND and_tags) XOR xor_tags
+
+                Changes are applied immediately.
+            </description>
+            <arg name="and_tags" type="uint"/>
+            <arg name="xor_tags" type="uint"/>
+        </request>
+
+        <request name="set_layout">
+            <description summary="sets the active layout on this monitor.">
+                Changes are applied immediately.
+            </description>
+            <arg name="layout" type="uint" summary="index of a layout received by the dscm_v1.layout event."/>
+        </request>
+    </interface>
+</protocol>
diff --git a/scripts/create-patches.sh b/scripts/create-patches.sh
new file mode 100755
index 0000000..41cd359
--- /dev/null
+++ b/scripts/create-patches.sh
@@ -0,0 +1,25 @@
+#!/bin/sh
+# $1 = dwl-guile patch tag to diff patches to
+
+git fetch --all
+rm -rf patches
+mkdir -p patches
+
+# Make sure we always have a branch/tag to diff against,
+# otherwise, the patch output will be inverted.
+DIFF_ORIGIN=$1
+[ -z $DIFF_ORIGIN ] && DIFF_ORIGIN="main"
+
+for patch in xwayland attachabove \
+    monitor-config focusmonpointer swallow movestack
+do
+    git fetch origin patch/$patch
+    git diff $DIFF_ORIGIN patch/$patch \
+        ':(exclude)README.md' \
+        ':(exclude)patches' \
+        ':(exclude)scripts/create-patches.sh' \
+        ':(exclude).gitignore' > patches/$patch.patch
+done
+
+# Create dwl-guile patch based on dwl v0.2.1
+git diff v0.2.1 > patches/dwl-guile.patch
