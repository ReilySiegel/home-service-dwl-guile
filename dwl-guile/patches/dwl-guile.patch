diff --git a/.github/ISSUE_TEMPLATE/bug_report.md b/.github/ISSUE_TEMPLATE/bug_report.md
deleted file mode 100644
index 6b60803..0000000
--- a/.github/ISSUE_TEMPLATE/bug_report.md
+++ /dev/null
@@ -1,22 +0,0 @@
----
-name: Bug report
-about: Something in dwl isn't working correctly
-title: ''
-labels: 'A: bug'
-assignees: ''
-
----
-
-## Info
-dwl version:
-wlroots version:
-## Description
-<!--
-Only report bugs that can be reproduced on the main line
-Report patch issues to their respective authors
-If the patch author doesn't respond within a reasonable time, email me:
-
-Leonardo Hernández Hernández <leohdz172@protonmail.com>
-
-but note that I'm NOT making any promises
--->
diff --git a/.github/ISSUE_TEMPLATE/enhancement-idea.md b/.github/ISSUE_TEMPLATE/enhancement-idea.md
deleted file mode 100644
index 0ac096d..0000000
--- a/.github/ISSUE_TEMPLATE/enhancement-idea.md
+++ /dev/null
@@ -1,10 +0,0 @@
----
-name: Enhancement idea
-about: Suggest a feature or improvement
-title: ''
-labels: 'A: enhancement'
-assignees: ''
-
----
-
-
diff --git a/.gitignore b/.gitignore
index 0dde90e..183032c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,4 +3,7 @@ dwl
 *-protocol.c
 *-protocol.h
 .ccls-cache
-config.h
+config.scm
+dwl.log
+*.patch
+patches
diff --git a/Makefile b/Makefile
index ccca079..d68575f 100644
--- a/Makefile
+++ b/Makefile
@@ -1,60 +1,67 @@
-.POSIX:
-.SUFFIXES:
-
 include config.mk
 
-# flags for compiling
-DWLCPPFLAGS = -I. -DWLR_USE_UNSTABLE -D_POSIX_C_SOURCE=200809L -DVERSION=\"$(VERSION)\" $(XWAYLAND)
-DWLDEVCFLAGS = -pedantic -Wall -Wextra -Wdeclaration-after-statement -Wno-unused-parameter -Wno-sign-compare -Wshadow -Wunused-macros\
-	-Werror=strict-prototypes -Werror=implicit -Werror=return-type -Werror=incompatible-pointer-types
+CFLAGS += -I. -DWLR_USE_UNSTABLE -D_POSIX_C_SOURCE=200809L -Wno-declaration-after-statement -Wno-unused-label -Wno-error=implicit-function-declaration $(XWAYLAND) $(DEBUGFLAGS) -DPREFIX=\"$(PREFIX)\"
 
-# CFLAGS / LDFLAGS
-PKGS      = wlroots wayland-server xkbcommon libinput $(XLIBS)
-DWLCFLAGS = `$(PKG_CONFIG) --cflags $(PKGS)` $(DWLCPPFLAGS) $(DWLDEVCFLAGS) $(CFLAGS)
-LDLIBS    = `$(PKG_CONFIG) --libs $(PKGS)` $(LIBS)
+WAYLAND_PROTOCOLS=$(shell pkg-config --variable=pkgdatadir wayland-protocols)
+WAYLAND_SCANNER=$(shell pkg-config --variable=wayland_scanner wayland-scanner)
+
+PKGS = wlroots wayland-server wayland-client xkbcommon libinput guile-3.0 pixman-1 $(XLIBS)
+CFLAGS += $(foreach p,$(PKGS),$(shell pkg-config --cflags $(p)))
+LDLIBS += $(foreach p,$(PKGS),$(shell pkg-config --libs $(p)))
 
 all: dwl
-dwl: dwl.o util.o
-	$(CC) dwl.o util.o $(LDLIBS) $(LDFLAGS) $(DWLCFLAGS) -o $@
-dwl.o: dwl.c config.mk config.h client.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h
-util.o: util.c util.h
+
+clean:
+	rm -f dwl *.o *-protocol.h *-protocol.c
+
+install: dwl
+	mv dwl dwl-guile
+	install -Dm755 dwl-guile $(PREFIX)/bin/dwl-guile
+	install -Dm644 doc/dwl-guile.1.man $(MANDIR)/man1/dwl-guile.1
+	cp -r share $(PREFIX)/share/dwl-guile
+
+.PHONY: all clean install
 
 # wayland-scanner is a tool which generates C headers and rigging for Wayland
 # protocols, which are specified in XML. wlroots requires you to rig these up
 # to your build system yourself and provide them in the include path.
-WAYLAND_SCANNER   = `$(PKG_CONFIG) --variable=wayland_scanner wayland-scanner`
-WAYLAND_PROTOCOLS = `$(PKG_CONFIG) --variable=pkgdatadir wayland-protocols`
-
 xdg-shell-protocol.h:
 	$(WAYLAND_SCANNER) server-header \
 		$(WAYLAND_PROTOCOLS)/stable/xdg-shell/xdg-shell.xml $@
+
+xdg-shell-protocol.c:
+	$(WAYLAND_SCANNER) private-code \
+		$(WAYLAND_PROTOCOLS)/stable/xdg-shell/xdg-shell.xml $@
+
+xdg-shell-protocol.o: xdg-shell-protocol.h
+
 wlr-layer-shell-unstable-v1-protocol.h:
 	$(WAYLAND_SCANNER) server-header \
 		protocols/wlr-layer-shell-unstable-v1.xml $@
 
-config.h:
-	cp config.def.h $@
-clean:
-	rm -f dwl *.o *-protocol.h
+wlr-layer-shell-unstable-v1-protocol.c:
+	$(WAYLAND_SCANNER) private-code \
+		protocols/wlr-layer-shell-unstable-v1.xml $@
 
-dist: clean
-	mkdir -p dwl-$(VERSION)
-	cp -R LICENSE* Makefile README.md client.h config.def.h\
-		config.mk protocols dwl.1 dwl.c util.c util.h\
-		dwl-$(VERSION)
-	tar -caf dwl-$(VERSION).tar.gz dwl-$(VERSION)
-	rm -rf dwl-$(VERSION)
+wlr-layer-shell-unstable-v1-protocol.o: wlr-layer-shell-unstable-v1-protocol.h
 
-install: dwl
-	mkdir -p $(DESTDIR)$(PREFIX)/bin
-	cp -f dwl $(DESTDIR)$(PREFIX)/bin
-	chmod 755 $(DESTDIR)$(PREFIX)/bin/dwl
-	mkdir -p $(DESTDIR)$(MANDIR)/man1
-	cp -f dwl.1 $(DESTDIR)$(MANDIR)/man1
-	chmod 644 $(DESTDIR)$(MANDIR)/man1/dwl.1
-uninstall:
-	rm -f $(DESTDIR)$(PREFIX)/bin/dwl $(DESTDIR)$(MANDIR)/man1/dwl.1
+dscm-unstable-v1-protocol.h:
+	$(WAYLAND_SCANNER) server-header \
+		protocols/dscm-unstable-v1.xml $@
 
-.SUFFIXES: .c .o
-.c.o:
-	$(CC) $(CPPFLAGS) $(DWLCFLAGS) -c $<
+dscm-unstable-v1-protocol-client.h:
+	$(WAYLAND_SCANNER) client-header \
+		protocols/dscm-unstable-v1.xml $@
+
+dscm-unstable-v1-protocol.c:
+	$(WAYLAND_SCANNER) private-code \
+		protocols/dscm-unstable-v1.xml $@
+
+dscm-unstable-v1-protocol.o: dscm-unstable-v1-protocol.h
+dscm-unstable-v1-protocol-client.o: dscm-unstable-v1-protocol-client.h
+
+dscm/ipc.o: dscm-unstable-v1-protocol-client.h util.h
+
+dwl.o: dscm/shared.h dscm/utils.h dscm/bindings.h dscm/config.h dscm/ipc.h client.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h dscm-unstable-v1-protocol.h util.h
+
+dwl: xdg-shell-protocol.o wlr-layer-shell-unstable-v1-protocol.o util.o dscm-unstable-v1-protocol.o dscm/ipc.o
diff --git a/README.md b/README.md
deleted file mode 100644
index 05f149c..0000000
--- a/README.md
+++ /dev/null
@@ -1,157 +0,0 @@
-# dwl - dwm for Wayland
-
-Join us on our [Discord server] or at [#dwl] on irc.libera.chat.
-
-dwl is a compact, hackable compositor for [Wayland] based on [wlroots]. It is
-intended to fill the same space in the Wayland world that dwm does in X11,
-primarily in terms of philosophy, and secondarily in terms of functionality.
-Like dwm, dwl is:
-
-- Easy to understand, hack on, and extend with patches
-- One C source file (or a very small number) configurable via `config.h`
-- Limited to 2200 SLOC to promote hackability
-- Tied to as few external dependencies as possible
-
-dwl is not meant to provide every feature under the sun. Instead, like dwm, it
-sticks to features which are necessary, simple, and straightforward to implement
-given the base on which it is built. Implemented default features are:
-
-- Any features provided by dwm/Xlib: simple window borders, tags, keybindings,
-  client rules, mouse move/resize. Providing a built-in status bar is an
-  exception to this goal, to avoid dependencies on font rendering and/or
-  drawing libraries when an external bar could work well.
-- Configurable multi-monitor layout support, including position and rotation
-- Configurable HiDPI/multi-DPI support
-- Idle-inhibit protocol which lets applications such as mpv disable idle
-  monitoring
-- Provide information to external status bars via stdout/stdin
-- Urgency hints via xdg-activate protocol
-- Support screen lockers via input-inhibitor protocol
-- Various Wayland protocols
-- XWayland support as provided by wlroots (can be enabled in `config.mk`)
-- Zero flickering - Wayland users naturally expect that "every frame is perfect"
-- Layer shell popups (used by Waybar)
-- Damage tracking provided by scenegraph API
-
-Features under consideration (possibly as patches) are:
-
-- Protocols made trivial by wlroots
-- Implement the text-input and input-method protocols to support IME once ibus
-  implements input-method v2 (see https://github.com/ibus/ibus/pull/2256 and
-  https://github.com/djpohly/dwl/pull/235)
-
-Feature *non-goals* for the main codebase include:
-
-- Client-side decoration (any more than is necessary to tell the clients not to)
-- Client-initiated window management, such as move, resize, and close, which can
-  be done through the compositor
-- Animations and visual effects
-
-## Building dwl
-
-dwl has only two dependencies: `wlroots` and `wayland-protocols`. 
-
-Simply install these (and their `-devel` versions if your distro has separate
-development packages) and run `make`.  If you wish to build against a Git
-version of wlroots, check out the [wlroots-next branch].
-
-To enable XWayland, you should also install xorg-xwayland and uncomment its flag
-in `config.mk`.
-
-## Configuration
-
-All configuration is done by editing `config.h` and recompiling, in the same
-manner as dwm. There is no way to separately restart the window manager in
-Wayland without restarting the entire display server, so any changes will take
-effect the next time dwl is executed.
-
-As in the dwm community, we encourage users to share patches they have created.
-Check out the [patches page on our wiki]!
-
-## Running dwl
-
-dwl can be run on any of the backends supported by wlroots. This means you can
-run it as a separate window inside either an X11 or Wayland session, as well
-as directly from a VT console. Depending on your distro's setup, you may need
-to add your user to the `video` and `input` groups before you can run dwl on
-a VT. If you are using `elogind` or `systemd-logind` you need to install
-polkit; otherwise you need to add yourself in the `seat` group and
-enable/start the seatd daemon.
-
-When dwl is run with no arguments, it will launch the server and begin handling
-any shortcuts configured in `config.h`. There is no status bar or other
-decoration initially; these are instead clients that can be run within
-the Wayland session.
-
-If you would like to run a script or command automatically at startup, you can
-specify the command using the `-s` option. This command will be executed as a
-shell command using `/bin/sh -c`.  It serves a similar function to `.xinitrc`,
-but differs in that the display server will not shut down when this process
-terminates. Instead, dwl will send this process a SIGTERM at shutdown and wait
-for it to terminate (if it hasn't already). This makes it ideal for execing into
-a user service manager like [s6], [anopa], [runit], or [`systemd --user`].
-
-Note: The `-s` command is run as a *child process* of dwl, which means that it
-does not have the ability to affect the environment of dwl or of any processes
-that it spawns. If you need to set environment variables that affect the entire
-dwl session, these must be set prior to running dwl. For example, Wayland
-requires a valid `XDG_RUNTIME_DIR`, which is usually set up by a session manager
-such as `elogind` or `systemd-logind`.  If your system doesn't do this
-automatically, you will need to configure it prior to launching `dwl`, e.g.:
-
-    export XDG_RUNTIME_DIR=/tmp/xdg-runtime-$(id -u)
-    mkdir -p $XDG_RUNTIME_DIR
-    dwl
-
-### Status information
-
-Information about selected layouts, current window title, and
-selected/occupied/urgent tags is written to the stdin of the `-s` command (see
-the `printstatus()` function for details).  This information can be used to
-populate an external status bar with a script that parses the information.
-Failing to read this information will cause dwl to block, so if you do want to
-run a startup command that does not consume the status information, you can
-close standard input with the `<&-` shell redirection, for example:
-
-    dwl -s 'foot --server <&-'
-
-If your startup command is a shell script, you can achieve the same inside the
-script with the line
-
-    exec <&-
-
-To get a list of status bars that work with dwl consult our [wiki].
-
-## Replacements for X applications
-
-You can find a [list of useful resources on our wiki].
-
-## Acknowledgements
-
-dwl began by extending the TinyWL example provided (CC0) by the sway/wlroots
-developers. This was made possible in many cases by looking at how sway
-accomplished something, then trying to do the same in as suckless a way as
-possible.
-
-Many thanks to suckless.org and the dwm developers and community for the
-inspiration, and to the various contributors to the project, including:
-
-- Alexander Courtis for the XWayland implementation
-- Guido Cella for the layer-shell protocol implementation, patch maintenance,
-  and for helping to keep the project running
-- Stivvo for output management and fullscreen support, and patch maintenance
-
-
-[Discord server]: https://discord.gg/jJxZnrGPWN
-[#dwl]: https://web.libera.chat/?channels=#dwl
-[Wayland]: https://wayland.freedesktop.org/
-[wlroots]: https://gitlab.freedesktop.org/wlroots/wlroots/
-[wlroots-next branch]: https://github.com/djpohly/dwl/tree/wlroots-next
-[patches page on our wiki]: https://github.com/djpohly/dwl/wiki/Patches
-[s6]: https://skarnet.org/software/s6/
-[anopa]: https://jjacky.com/anopa/
-[runit]: http://smarden.org/runit/faq.html#userservices
-[`systemd --user`]: https://wiki.archlinux.org/title/Systemd/User
-[wiki]: https://github.com/djpohly/dwl/wiki#compatible-status-bars
-[list of useful resources on our wiki]:
-    https://github.com/djpohly/dwl/wiki#migrating-from-x
diff --git a/README.org b/README.org
new file mode 100644
index 0000000..998929e
--- /dev/null
+++ b/README.org
@@ -0,0 +1,37 @@
+* =dwl-guile=
+=dwl-guile= allows you to configure and interact with [[https://github.com/djpohly/dwl][ =dwl= ]] using [[https://www.gnu.org/software/guile/][GNU Guile]] through a startup configuration file and/or a REPL.
+
+=dwl-guile= is based on the latest version of =dwl= (v0.4) and will be continuously rebased against new versions.
+
+** Goal
+The main goal of =dwl-guile= is to serve as a minimal =dwm=-like Wayland compositor for those who use [[https://guix.gnu.org/][GNU Guix System]] --- a GNU/Linux distribution in which the user can customize and configure their entire system in GNU Guile.
+
+=dwl-guile= integrates the window manager customization with that of the rest of the system, which allows for a dynamic, programmable and reproducible configuration for our entire computing environment --- all in Guile.
+
+** Features
+*** Scheme/Guile configuration
+The file =./share/default.scm= contains an example configuration. You can script the configuration to your heart's content, since it is written in an actual programming language!
+
+*** Dynamic configuration and interaction...
+ Evaluate expression in real time using =dwl-guile -e "<sexp>"= and change tiling layouts, bind keys and much more on the fly --- there is no need to restart the compositor if you want to try something new!
+
+*** ... also with a REPL!
+  You may also use a REPL client such as [[https://www.nongnu.org/geiser/][Geiser]] to control =dwl-guile= for an even more interactive experience.
+
+** Installation
+The best way to install and configure =dwl-guile= is through the Guix channel [[https://github.com/engstrand-config/home-service-dwl-guile][home-service-dwl-guile]], which (as the name suggests) provides a [[https://guix.gnu.org/manual/devel/en/html_node/Home-Configuration.html][Guix Home]] service for =dwl-guile=.
+Non-Guix System users can download the GNU Guix package manager for their current GNU/Linux distribution in order to use the Guix Home service.
+
+An alternative way (that works without the Guix package manager) would be to
+1. Clone the =dwl-guile= repository
+2. Build a =dwl-guile= binary using the =Makefile=
+3. Supply the produced binary with a Guile configuration file.
+
+** Releases
+The [[https://github.com/engstrand-config/dwl-guile/releases][Releases]] section contains the =dwl-guile= patch for =dwl= and an assortment of useful patches that provide additional functionality.
+
+Some patches are already included in the main =dwl-guile= patch, namely
+- =keycode=,
+- =smartborders=,
+- =vanitygaps=, and
+- =cyclelayout=.
diff --git a/config.def.h b/config.def.h
deleted file mode 100644
index a4f7c13..0000000
--- a/config.def.h
+++ /dev/null
@@ -1,158 +0,0 @@
-/* appearance */
-static const int sloppyfocus               = 1;  /* focus follows mouse */
-static const int bypass_surface_visibility = 0;  /* 1 means idle inhibitors will disable idle tracking even if it's surface isn't visible  */
-static const unsigned int borderpx         = 1;  /* border pixel of windows */
-static const float rootcolor[]             = {0.3, 0.3, 0.3, 1.0};
-static const float bordercolor[]           = {0.5, 0.5, 0.5, 1.0};
-static const float focuscolor[]            = {1.0, 0.0, 0.0, 1.0};
-/* To conform the xdg-protocol, set the alpha to zero to restore the old behavior */
-static const float fullscreen_bg[]         = {0.1, 0.1, 0.1, 1.0};
-
-/* tagging */
-static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
-
-static const Rule rules[] = {
-	/* app_id     title       tags mask     isfloating   monitor */
-	/* examples:
-	{ "Gimp",     NULL,       0,            1,           -1 },
-	*/
-	{ "firefox",  NULL,       1 << 8,       0,           -1 },
-};
-
-/* layout(s) */
-static const Layout layouts[] = {
-	/* symbol     arrange function */
-	{ "[]=",      tile },
-	{ "><>",      NULL },    /* no layout function means floating behavior */
-	{ "[M]",      monocle },
-};
-
-/* monitors */
-static const MonitorRule monrules[] = {
-	/* name       mfact nmaster scale layout       rotate/reflect */
-	/* example of a HiDPI laptop monitor:
-	{ "eDP-1",    0.5,  1,      2,    &layouts[0], WL_OUTPUT_TRANSFORM_NORMAL },
-	*/
-	/* defaults */
-	{ NULL,       0.55, 1,      1,    &layouts[0], WL_OUTPUT_TRANSFORM_NORMAL },
-};
-
-/* keyboard */
-static const struct xkb_rule_names xkb_rules = {
-	/* can specify fields: rules, model, layout, variant, options */
-	/* example:
-	.options = "ctrl:nocaps",
-	*/
-	.options = NULL,
-};
-
-static const int repeat_rate = 25;
-static const int repeat_delay = 600;
-
-/* Trackpad */
-static const int tap_to_click = 1;
-static const int tap_and_drag = 1;
-static const int drag_lock = 1;
-static const int natural_scrolling = 0;
-static const int disable_while_typing = 1;
-static const int left_handed = 0;
-static const int middle_button_emulation = 0;
-/* You can choose between:
-LIBINPUT_CONFIG_SCROLL_NO_SCROLL
-LIBINPUT_CONFIG_SCROLL_2FG
-LIBINPUT_CONFIG_SCROLL_EDGE
-LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN
-*/
-static const enum libinput_config_scroll_method scroll_method = LIBINPUT_CONFIG_SCROLL_2FG;
-
-/* You can choose between:
-LIBINPUT_CONFIG_CLICK_METHOD_NONE       
-LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS       
-LIBINPUT_CONFIG_CLICK_METHOD_CLICKFINGER 
-*/
-static const enum libinput_config_click_method click_method = LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS;
-
-/* You can choose between:
-LIBINPUT_CONFIG_SEND_EVENTS_ENABLED
-LIBINPUT_CONFIG_SEND_EVENTS_DISABLED
-LIBINPUT_CONFIG_SEND_EVENTS_DISABLED_ON_EXTERNAL_MOUSE
-*/
-static const uint32_t send_events_mode = LIBINPUT_CONFIG_SEND_EVENTS_ENABLED;
-
-/* You can choose between:
-LIBINPUT_CONFIG_ACCEL_PROFILE_FLAT
-LIBINPUT_CONFIG_ACCEL_PROFILE_ADAPTIVE
-*/
-static const enum libinput_config_accel_profile accel_profile = LIBINPUT_CONFIG_ACCEL_PROFILE_ADAPTIVE;
-static const double accel_speed = 0.0;
-/* You can choose between:
-LIBINPUT_CONFIG_TAP_MAP_LRM -- 1/2/3 finger tap maps to left/right/middle
-LIBINPUT_CONFIG_TAP_MAP_LMR -- 1/2/3 finger tap maps to left/middle/right
-*/
-static const enum libinput_config_tap_button_map button_map = LIBINPUT_CONFIG_TAP_MAP_LRM;
-
-/* If you want to use the windows key for MODKEY, use WLR_MODIFIER_LOGO */
-#define MODKEY WLR_MODIFIER_ALT
-
-#define TAGKEYS(KEY,SKEY,TAG) \
-	{ MODKEY,                    KEY,            view,            {.ui = 1 << TAG} }, \
-	{ MODKEY|WLR_MODIFIER_CTRL,  KEY,            toggleview,      {.ui = 1 << TAG} }, \
-	{ MODKEY|WLR_MODIFIER_SHIFT, SKEY,           tag,             {.ui = 1 << TAG} }, \
-	{ MODKEY|WLR_MODIFIER_CTRL|WLR_MODIFIER_SHIFT,SKEY,toggletag, {.ui = 1 << TAG} }
-
-/* helper for spawning shell commands in the pre dwm-5.0 fashion */
-#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
-
-/* commands */
-static const char *termcmd[] = { "foot", NULL };
-static const char *menucmd[] = { "bemenu-run", NULL };
-
-static const Key keys[] = {
-	/* Note that Shift changes certain key codes: c -> C, 2 -> at, etc. */
-	/* modifier                  key                 function        argument */
-	{ MODKEY,                    XKB_KEY_p,          spawn,          {.v = menucmd} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Return,     spawn,          {.v = termcmd} },
-	{ MODKEY,                    XKB_KEY_j,          focusstack,     {.i = +1} },
-	{ MODKEY,                    XKB_KEY_k,          focusstack,     {.i = -1} },
-	{ MODKEY,                    XKB_KEY_i,          incnmaster,     {.i = +1} },
-	{ MODKEY,                    XKB_KEY_d,          incnmaster,     {.i = -1} },
-	{ MODKEY,                    XKB_KEY_h,          setmfact,       {.f = -0.05} },
-	{ MODKEY,                    XKB_KEY_l,          setmfact,       {.f = +0.05} },
-	{ MODKEY,                    XKB_KEY_Return,     zoom,           {0} },
-	{ MODKEY,                    XKB_KEY_Tab,        view,           {0} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_C,          killclient,     {0} },
-	{ MODKEY,                    XKB_KEY_t,          setlayout,      {.v = &layouts[0]} },
-	{ MODKEY,                    XKB_KEY_f,          setlayout,      {.v = &layouts[1]} },
-	{ MODKEY,                    XKB_KEY_m,          setlayout,      {.v = &layouts[2]} },
-	{ MODKEY,                    XKB_KEY_space,      setlayout,      {0} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_space,      togglefloating, {0} },
-	{ MODKEY,                    XKB_KEY_e,         togglefullscreen, {0} },
-	{ MODKEY,                    XKB_KEY_0,          view,           {.ui = ~0} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_parenright, tag,            {.ui = ~0} },
-	{ MODKEY,                    XKB_KEY_comma,      focusmon,       {.i = WLR_DIRECTION_LEFT} },
-	{ MODKEY,                    XKB_KEY_period,     focusmon,       {.i = WLR_DIRECTION_RIGHT} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_less,       tagmon,         {.i = WLR_DIRECTION_LEFT} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_greater,    tagmon,         {.i = WLR_DIRECTION_RIGHT} },
-	TAGKEYS(          XKB_KEY_1, XKB_KEY_exclam,                     0),
-	TAGKEYS(          XKB_KEY_2, XKB_KEY_at,                         1),
-	TAGKEYS(          XKB_KEY_3, XKB_KEY_numbersign,                 2),
-	TAGKEYS(          XKB_KEY_4, XKB_KEY_dollar,                     3),
-	TAGKEYS(          XKB_KEY_5, XKB_KEY_percent,                    4),
-	TAGKEYS(          XKB_KEY_6, XKB_KEY_asciicircum,                5),
-	TAGKEYS(          XKB_KEY_7, XKB_KEY_ampersand,                  6),
-	TAGKEYS(          XKB_KEY_8, XKB_KEY_asterisk,                   7),
-	TAGKEYS(          XKB_KEY_9, XKB_KEY_parenleft,                  8),
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Q,          quit,           {0} },
-
-	/* Ctrl-Alt-Backspace and Ctrl-Alt-Fx used to be handled by X server */
-	{ WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_Terminate_Server, quit, {0} },
-#define CHVT(n) { WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_XF86Switch_VT_##n, chvt, {.ui = (n)} }
-	CHVT(1), CHVT(2), CHVT(3), CHVT(4), CHVT(5), CHVT(6),
-	CHVT(7), CHVT(8), CHVT(9), CHVT(10), CHVT(11), CHVT(12),
-};
-
-static const Button buttons[] = {
-	{ MODKEY, BTN_LEFT,   moveresize,     {.ui = CurMove} },
-	{ MODKEY, BTN_MIDDLE, togglefloating, {0} },
-	{ MODKEY, BTN_RIGHT,  moveresize,     {.ui = CurResize} },
-};
diff --git a/config.mk b/config.mk
index f50156f..7669208 100644
--- a/config.mk
+++ b/config.mk
@@ -1,12 +1,13 @@
-_VERSION = 0.4
-VERSION  = `git describe --tags --dirty 2>/dev/null || echo $(_VERSION)`
-
 PKG_CONFIG = pkg-config
 
 # paths
 PREFIX = /usr/local
 MANDIR = $(PREFIX)/share/man
 
+# Default compile flags (overridable by environment)
+CFLAGS ?= -g -Wall -Wextra -Werror -Wno-unused-parameter -Wno-sign-compare -Wno-unused-function -Wno-unused-variable -Wno-unused-result -Wdeclaration-after-statement
+
+DEBUGFLAGS =
 XWAYLAND =
 XLIBS =
 # Uncomment to build XWayland support
diff --git a/doc/dwl-guile.1.man b/doc/dwl-guile.1.man
new file mode 100644
index 0000000..38947fc
--- /dev/null
+++ b/doc/dwl-guile.1.man
@@ -0,0 +1,392 @@
+.TH "dwl-guile" "1" 
+.SH "NAME"
+.PP
+\fBdwl-guile\fP -- dynamic tiling Wayland compositor configurable in Guile Scheme
+.SH "SYNOPSIS"
+.PP
+\fBdwl-guile -c\fP \fICONFIG\fP
+.br
+\fBdwl-guile -e\fP \fISEXP\fP
+.SH "DESCRIPTION"
+.PP
+\fBdwl-guile\fP is a hackable and Guile Scheme-configurable \fBdwm\fP-inspired Wayland compositor that is based on \fBdwl\fP.
+
+.PP
+At startup: \fBdwl-guile\fP loads a Guile Scheme configuration file \fICONFIG\fP.
+
+.PP
+At runtime: the user can evaluate a \fISEXP\fP to interact with \fBdwl-guile\fP. This includes specifying (additional) key bindings, setting client rules, viewing tags etc. A \fISEXP\fP can also be evaluated using a REPL client over a Unix socket.
+.SH "DEFAULT KEY BINDINGS"
+.SS "Modifiers:"
+.PP
+\fBdwl-guile\fP uses the same conventions as \fBemacs\fP for its key bindings:
+ \fBS\fP Shift
+ \fBC\fP Control
+ \fBs\fP Super
+ \fBM\fP Meta/Alt
+
+.SS "Key bindings"
+.PP
+The default key bindings are:
+ \fBs-[1-9]\fP                    Show only all windows with a tag.
+ \fBs-C-[1-9]\fP                  Show all windows with a tag.
+ \fBs-S-[1-9]\fP                  Move window to a single tag.
+ \fBs-C-S-[1-9]\fP                Toggle tag for window.
+ \fBs-0\fP                        Show all windows.
+ \fBs-S-0\fP                      Show window on all tags
+ \fBs-[j/k]\fP                    Move focus down/up the stack.
+ \fBs-[h/l]\fP                    Decrease/increase master area.
+ \fBs-<space>\fP                  Move window on top of stack or switch top of stack with second window.
+ \fBs-<tab>\fP                    Show only all windows with previous tag.
+ \fBs-<page-[up/down]>\fP         Increase/decrease number of clients in master
+ \fBs-t\fP                        Switch to next layout.
+ \fBs-q\fP                        Close window.
+ \fBs-S-<space>\fP                Toggle floating state of window.
+ \fBs-f\fP                        Toggle fullscreen state of window.
+ \fBs-<[left/right/up/down]>\fP   Change monitor focus
+ \fBs-S-<[left/right/up/down]>\fP Move tag to monitor
+ \fBs-d\fP                        Spawn \fBbemenu-run\fP.
+ \fBs-<return>\fP                 Spawn \fBfoot\fP.
+
+.SH "CONFIGURATION"
+.PP
+The configuration file is written in Guile Scheme.
+
+.PP
+\fBdwl-guile\fP applies configuration changes dynamically so that you can see the changes in real-time. A set of default configuration settings (including the key bindings above) will load automatically unless \fBinhibit-defaults?\fP is set to \fB#t\fP.
+
+.PP
+A few of the configuration options are mandatory and cannot be inhibited. You can override these if they do not suit your needs.
+
+.PP
+General options can be set using \fB(set '<option> <value>)\fP or \fB(setq <option> <value>)\fP. For a list of available options, execute \fB(dwl:list-options)\fP using \fBdwl-guile -e\fP or the REPL. The source code also contains a list of all options in the \fBdscm/config.h\fP file.
+
+.SS "Tags"
+.PP
+It is mandatory to set the number of tags.
+The default is to use tags 1-9 as such:
+
+.PP
+.B
+.RS
+.nf
+\fC(setq tags (map number->string (iota 9 1)))
+\fP
+.fi
+.RE
+.SS "Layouts"
+.PP
+At least one layout must be set, which is why \fBdwl-guile\fP will automatically add it for you, even if \fBinhibit-defaults?\fP is \fB#t\fP. The default setting adds only the \fBtile\fP layout:
+
+.PP
+.B
+.RS
+.nf
+\fC(set-layouts 'default "[]=" 'dwl:tile)
+\fP
+.fi
+.RE
+
+.PP
+Including both the \fBtile\fP and \fBmonocle\fP layouts can look like this:
+
+.PP
+.B
+.RS
+.nf
+\fC(set-layouts 'default "[]=" 'dwl:tile
+.B
+             'monocle "|M|" 'dwl:monocle)
+\fP
+.fi
+.RE
+
+.PP
+Note that \fB'default\fP and \fB'monocle\fP are unique identifiers for their respective layouts. A monitor rule can use these identifiers to assign a certain layout to a specific monitor. Adding a new layout with an identifier that already exists will simply override the options of the previous layout.
+
+.SS "Monitor rules"
+.PP
+A valid configuration file should contain at least one monitor rule without a specified \fBname\fP field, e.g.:
+
+.PP
+.B
+.RS
+.nf
+\fC(set-monitor-rules '((masters . 1)
+.B
+                     (master-factor . 0.55)
+.B
+                     (scale . 1)
+.B
+                     (transform . TRANSFORM-NORMAL)
+.B
+                     (layout . default)))
+\fP
+.fi
+.RE
+
+.PP
+To configure a dual-monitor setup with two horizontally adjacent monitors you could write something like this:
+
+.PP
+.B
+.RS
+.nf
+\fC(set-monitor-rules '((name . "HDMI-1") (x . 0) (y . 0))
+.B
+                   '((name . "DP-1") (x . 1920) (y . 0)))
+\fP
+.fi
+.RE
+
+.SS "Client rules"
+.PP
+Windows containing certain clients can be set to spawn in floating mode, be assigned to specific tags and/or monitors.
+
+.PP
+Here, the chosen client \fBemacs\fP is identified by its \fBid\fP and is set to spawn on tag 1 as a tiled window on the current monitor:
+
+.PP
+.B
+.RS
+.nf
+\fC(set-rules '((id . "emacs")
+.B
+             (tags . 1) ;; can also be a list of tags
+.B
+             (floating? . #f)
+.B
+             (monitor . -1))
+\fP
+.fi
+.RE
+
+.PP
+A rule can additionally match a window title with the help of \fBtitle\fP.
+
+.SS "Colors"
+.PP
+Colors can be specified in RGBA format or hex format, i.e. \fB'(1.0 1.0 1.0 1.0)\fP or \fB"#001122FF"\fP (or just \fB"#FFFFFF"\fP if alpha is not needed).
+
+.PP
+The following snippet applies a red color to the border of the window that is in focus:
+
+.PP
+.B
+.RS
+.nf
+\fC(setq focus-color "#ff0000")
+\fP
+.fi
+.RE
+
+.SS "Hooks"
+.PP
+Two 'hooks' exist in \fBdwl-guile\fP, namely \fBdwl:hook-startup\fP and \fBdwl:hook-quit\fP.
+These hooks can run some user-defined code on startup or upon exit, e.g.:
+
+.PP
+.B
+.RS
+.nf
+\fC(add-hook! dwl:hook-quit (lambda () ...))
+\fP
+.fi
+.RE
+
+.PP
+Note that the startup hook will run in its own separate thread, which means that executing blocking, long-running operations is perfectly fine.
+
+.PP
+Additional hooks must be added in the C source code and it is currently not possible to add new hooks through the configuration file.
+
+.SS "XKB rules"
+.PP
+The following syntax is used to specify X keyboard rules in the configuration file:
+
+.PP
+.B
+.RS
+.nf
+\fC(set-xkb-rules '((model . "...")
+.B
+                 (layout . "...")
+.B
+                 (rules . "...")
+.B
+                 (variant . "...")
+.B
+                 (options . "...")
+\fP
+.fi
+.RE
+
+.PP
+Each field accepts a string with comma-separated options for XKB. Refer to the XKB manual for additional details.
+
+.SS "Key bindings"
+.PP
+Keyboard and mouse bindings are added with the \fBset-keys\fP procedure.
+
+.PP
+The following bind \fBs-<return>\fP to spawn a new client with the \fBfoot\fP terminal:
+
+.PP
+.B
+.RS
+.nf
+\fC(set-keys "s-<return>" '(dwl:spawn "foot"))
+\fP
+.fi
+.RE
+
+.PP
+A single \fBset-keys\fP call can set multiple bindings at once -- this applies to most of the other procedures as well.
+
+.PP
+The action of a keybinding can be set in three ways:
+
+.PP
+.B
+.RS
+.nf
+\fC(set-keys "s-<return>" '(dwl:spawn "foot") ;; Expression, no syntax-checking on startup
+.B
+          "s-<space>" 'dwl:zoom)           ;; No arguments allowed
+.B
+          "s-<return>" (lambda (dwl:spawn "foot"))
+\fP
+.fi
+.RE
+
+.PP
+Choose whichever method that is most convenient, but remember that the syntax-checking that comes with using symbols or lambda expressions might be useful if you must debug your configuration for some reason.
+
+.SH "ASYNCHRONOUS KEYBINDINGS"
+.PP
+For actions that does not return immediately, you can use \fBdwl:run-async\fP. This will allow you to specify a procedure that will be executed in a separate thread. If you need to handle the return value of this procedure, you can set the second argument to a callback that accepts this value as an argument, and returns a SEXP to be executed in the main Guile context. The reason for this is \fBthread safety\fP. Anytime you want to execute a longer running task (even if you are not using any \fBdwl:*\fP procedures inside it), you should always use \fBdwl:run-async\fP.
+
+.PP
+Note that you can safely execute long running actions using \fBdwl-guile -e "<sexp>"\fP, and you do not need to worry about thread safety. This is actually how \fBdwl:run-async\fP does it internally.
+
+.PP
+The following example shows how you could use this to spawn bemenu, show a list of tags, and view that tag in dwl-guile:
+
+.PP
+.B
+.RS
+.nf
+\fC(use-modules (ice-9 popen)
+.B
+             (ice-9 rdelim)
+.B
+             (ice-9 match)
+.B
+             (srfi srfi-1))
+.B
+
+;; Convert a list of tags to newline separated list that can be
+.B
+;; sent via stdin to bemenu.
+.B
+(define (serialize-tags)
+.B
+  (fold (lambda (tag acc)
+.B
+          (format #f "~a\n~a" tag acc))
+.B
+        ""
+.B
+        (reverse (iota 9 1))))
+.B
+
+;; Spawn bemenu and read the selected value
+.B
+(define (bemenu-tag-picker)
+.B
+  (call-with-values
+.B
+      (lambda ()
+.B
+        (pipeline `(("bemenu" "-i" "-p" "Go to tag"))))
+.B
+    (lambda (from to pids)
+.B
+      (display (serialize-clients) to)
+.B
+      (close-port to)
+.B
+      (let ((result (read-line from)))
+.B
+        (close-port from)
+.B
+        ;; Might want to check the exit status here as well
+.B
+        (string->number result)))))
+.B
+
+(set-keys "S-s-d"
+.B
+          (lambda ()
+.B
+            (dwl:run-async bemenu-tag-picker
+.B
+                           ;; Must return a SEXP
+.B
+                           (lambda (tag) `(dwl:view ,tag)))))
+\fP
+.fi
+.RE
+
+.SH "REPL SERVER"
+.PP
+\fBdwl-guile\fP can host a REPL server that listens on a Unix socket with default path \fB/tmp/dwl-guile.socket\fP (also available as variable \fBdwl:%repl-socket-path\fP).
+You can connect to the REPL with e.g. the \fBgeiser\fP package for \fBemacs\fP (\fBM-x\fP \fBgeiser-connect-local\fP
+and point it to the aformentioned socket).
+
+.PP
+The REPL is disabled in the default configuration. \fB(dwl:start-repl-server)\fP enables it.
+.SH "EXAMPLES"
+.PP
+Start \fBdwl-guile\fP with a configuration file called \fBinit.scm\fP, found in the directory \fB\fC/home/user/.config/dwl\-guile\fP\fP:
+
+.PP
+.B
+.RS
+.nf
+\fCdwl-guile -c /home/user/.config/dwl-guile/init.scm
+\fP
+.fi
+.RE
+
+.PP
+View clients assigned to tag 2:
+
+.PP
+.B
+.RS
+.nf
+\fCdwl-guile -e "(dwl:view 2)"
+\fP
+.fi
+.RE
+
+.PP
+Bind \fBs-q\fP to kill the current client:
+
+.PP
+.B
+.RS
+.nf
+\fCdwl-guile -e "(set-keys \\"s-q\\" 'dwl:kill-client)"
+\fP
+.fi
+.RE
+
+.SH "SEE ALSO"
+.PP
+\fBguile\fP​(1),
+\fBfoot\fP​(1),
+\fBbemenu\fP​(1),
+\fBdwm\fP​(1),
+\fBxkeyboard-config\fP​(7)
diff --git a/doc/dwl-guile.1.org b/doc/dwl-guile.1.org
new file mode 100644
index 0000000..781f2db
--- /dev/null
+++ b/doc/dwl-guile.1.org
@@ -0,0 +1,294 @@
+#+TITLE: dwl-guile
+#+begin_comment
+TODO: Code in =src= blocks do not show up as bold unless I add =.B= on every other line. Should be fixable?
+#+end_comment
+* NAME
+*dwl-guile* -- dynamic tiling Wayland compositor configurable in Guile Scheme
+* SYNOPSIS
+*dwl-guile -c* _CONFIG_
+.br
+*dwl-guile -e* _SEXP_
+* DESCRIPTION
+*dwl-guile* is a hackable and Guile Scheme-configurable *dwm*-inspired Wayland compositor that is based on *dwl*.
+
+At startup: *dwl-guile* loads a Guile Scheme configuration file _CONFIG_.
+
+At runtime: the user can evaluate a _SEXP_ to interact with *dwl-guile*. This includes specifying (additional) key bindings, setting client rules, viewing tags etc. A _SEXP_ can also be evaluated using a REPL client over a Unix socket.
+* DEFAULT KEY BINDINGS
+** Modifiers:
+*dwl-guile* uses the same conventions as *emacs* for its key bindings:
+ *S* Shift
+ *C* Control
+ *s* Super
+ *M* Meta/Alt
+
+** Key bindings
+The default key bindings are:
+ *s-[1-9]*                    Show only all windows with a tag.
+ *s-C-[1-9]*                  Show all windows with a tag.
+ *s-S-[1-9]*                  Move window to a single tag.
+ *s-C-S-[1-9]*                Toggle tag for window.
+ *s-0*                        Show all windows.
+ *s-S-0*                      Show window on all tags
+ *s-[j/k]*                    Move focus down/up the stack.
+ *s-[h/l]*                    Decrease/increase master area.
+ *s-<space>*                  Move window on top of stack or switch top of stack with second window.
+ *s-<tab>*                    Show only all windows with previous tag.
+ *s-<page-[up/down]>*         Increase/decrease number of clients in master
+ *s-t*                        Switch to next layout.
+ *s-q*                        Close window.
+ *s-S-<space>*                Toggle floating state of window.
+ *s-f*                        Toggle fullscreen state of window.
+ *s-<[left/right/up/down]>*   Change monitor focus
+ *s-S-<[left/right/up/down]>* Move tag to monitor
+ *s-d*                        Spawn *bemenu-run*.
+ *s-<return>*                 Spawn *foot*.
+
+* CONFIGURATION
+The configuration file is written in Guile Scheme.
+
+*dwl-guile* applies configuration changes dynamically so that you can see the changes in real-time. A set of default configuration settings (including the key bindings above) will load automatically unless *inhibit-defaults?* is set to *#t*.
+
+A few of the configuration options are mandatory and cannot be inhibited. You can override these if they do not suit your needs.
+
+General options can be set using *(set '<option> <value>)* or *(setq <option> <value>)*. For a list of available options, execute *(dwl:list-options)* using *dwl-guile -e* or the REPL. The source code also contains a list of all options in the *dscm/config.h* file.
+
+** Tags
+It is mandatory to set the number of tags.
+The default is to use tags 1-9 as such:
+
+.B
+#+begin_src scheme
+(setq tags (map number->string (iota 9 1)))
+#+end_src
+** Layouts
+At least one layout must be set, which is why *dwl-guile* will automatically add it for you, even if *inhibit-defaults?* is *#t*. The default setting adds only the *tile* layout:
+
+.B
+#+begin_src scheme
+(set-layouts 'default "[]=" 'dwl:tile)
+#+end_src
+
+Including both the *tile* and *monocle* layouts can look like this:
+
+.B
+#+begin_src scheme
+(set-layouts 'default "[]=" 'dwl:tile
+.B
+             'monocle "|M|" 'dwl:monocle)
+#+end_src
+
+Note that *'default* and *'monocle* are unique identifiers for their respective layouts. A monitor rule can use these identifiers to assign a certain layout to a specific monitor. Adding a new layout with an identifier that already exists will simply override the options of the previous layout.
+
+** Monitor rules
+A valid configuration file should contain at least one monitor rule without a specified *name* field, e.g.:
+
+.B
+#+begin_src scheme
+(set-monitor-rules '((masters . 1)
+.B
+                     (master-factor . 0.55)
+.B
+                     (scale . 1)
+.B
+                     (transform . TRANSFORM-NORMAL)
+.B
+                     (layout . default)))
+#+end_src
+
+To configure a dual-monitor setup with two horizontally adjacent monitors you could write something like this:
+
+.B
+#+begin_src scheme
+(set-monitor-rules '((name . "HDMI-1") (x . 0) (y . 0))
+.B
+                   '((name . "DP-1") (x . 1920) (y . 0)))
+#+end_src
+
+** Client rules
+Windows containing certain clients can be set to spawn in floating mode, be assigned to specific tags and/or monitors.
+
+Here, the chosen client *emacs* is identified by its *id* and is set to spawn on tag 1 as a tiled window on the current monitor:
+
+.B
+#+begin_src scheme
+(set-rules '((id . "emacs")
+.B
+             (tags . 1) ;; can also be a list of tags
+.B
+             (floating? . #f)
+.B
+             (monitor . -1))
+#+end_src
+
+A rule can additionally match a window title with the help of *title*.
+
+** Colors
+Colors can be specified in RGBA format or hex format, i.e. *'(1.0 1.0 1.0 1.0)* or *"#001122FF"* (or just *"#FFFFFF"* if alpha is not needed).
+
+The following snippet applies a red color to the border of the window that is in focus:
+
+.B
+#+begin_src scheme
+(setq focus-color "#ff0000")
+#+end_src
+
+** Hooks
+Two 'hooks' exist in *dwl-guile*, namely *dwl:hook-startup* and *dwl:hook-quit*.
+These hooks can run some user-defined code on startup or upon exit, e.g.:
+
+.B
+#+begin_src scheme
+(add-hook! dwl:hook-quit (lambda () ...))
+#+end_src
+
+Note that the startup hook will run in its own separate thread, which means that executing blocking, long-running operations is perfectly fine.
+
+Additional hooks must be added in the C source code and it is currently not possible to add new hooks through the configuration file.
+
+** XKB rules
+The following syntax is used to specify X keyboard rules in the configuration file:
+
+.B
+#+begin_src scheme
+(set-xkb-rules '((model . "...")
+.B
+                 (layout . "...")
+.B
+                 (rules . "...")
+.B
+                 (variant . "...")
+.B
+                 (options . "...")
+#+end_src
+
+Each field accepts a string with comma-separated options for XKB. Refer to the XKB manual for additional details.
+
+** Key bindings
+Keyboard and mouse bindings are added with the *set-keys* procedure.
+
+The following bind *s-<return>* to spawn a new client with the *foot* terminal:
+
+.B
+#+begin_src scheme
+(set-keys "s-<return>" '(dwl:spawn "foot"))
+#+end_src
+
+A single *set-keys* call can set multiple bindings at once -- this applies to most of the other procedures as well.
+
+The action of a keybinding can be set in three ways:
+
+.B
+#+begin_src scheme
+(set-keys "s-<return>" '(dwl:spawn "foot") ;; Expression, no syntax-checking on startup
+.B
+          "s-<space>" 'dwl:zoom)           ;; No arguments allowed
+.B
+          "s-<return>" (lambda (dwl:spawn "foot"))
+#+end_src
+
+Choose whichever method that is most convenient, but remember that the syntax-checking that comes with using symbols or lambda expressions might be useful if you must debug your configuration for some reason.
+
+* ASYNCHRONOUS KEYBINDINGS
+For actions that does not return immediately, you can use *dwl:run-async*. This will allow you to specify a procedure that will be executed in a separate thread. If you need to handle the return value of this procedure, you can set the second argument to a callback that accepts this value as an argument, and returns a SEXP to be executed in the main Guile context. The reason for this is *thread safety*. Anytime you want to execute a longer running task (even if you are not using any *dwl:** procedures inside it), you should always use *dwl:run-async*.
+
+Note that you can safely execute long running actions using *dwl-guile -e "<sexp>"*, and you do not need to worry about thread safety. This is actually how *dwl:run-async* does it internally.
+
+The following example shows how you could use this to spawn bemenu, show a list of tags, and view that tag in dwl-guile:
+
+.B
+#+begin_src scheme
+(use-modules (ice-9 popen)
+.B
+             (ice-9 rdelim)
+.B
+             (ice-9 match)
+.B
+             (srfi srfi-1))
+.B
+
+;; Convert a list of tags to newline separated list that can be
+.B
+;; sent via stdin to bemenu.
+.B
+(define (serialize-tags)
+.B
+  (fold (lambda (tag acc)
+.B
+          (format #f "~a\n~a" tag acc))
+.B
+        ""
+.B
+        (reverse (iota 9 1))))
+.B
+
+;; Spawn bemenu and read the selected value
+.B
+(define (bemenu-tag-picker)
+.B
+  (call-with-values
+.B
+      (lambda ()
+.B
+        (pipeline `(("bemenu" "-i" "-p" "Go to tag"))))
+.B
+    (lambda (from to pids)
+.B
+      (display (serialize-clients) to)
+.B
+      (close-port to)
+.B
+      (let ((result (read-line from)))
+.B
+        (close-port from)
+.B
+        ;; Might want to check the exit status here as well
+.B
+        (string->number result)))))
+.B
+
+(set-keys "S-s-d"
+.B
+          (lambda ()
+.B
+            (dwl:run-async bemenu-tag-picker
+.B
+                           ;; Must return a SEXP
+.B
+                           (lambda (tag) `(dwl:view ,tag)))))
+#+end_src
+
+* REPL SERVER
+*dwl-guile* can host a REPL server that listens on a Unix socket with default path */tmp/dwl-guile.socket* (also available as variable *dwl:%repl-socket-path*).
+You can connect to the REPL with e.g. the *geiser* package for *emacs* (*M-x* *geiser-connect-local*
+and point it to the aformentioned socket).
+
+The REPL is disabled in the default configuration. *(dwl:start-repl-server)* enables it.
+* EXAMPLES
+Start *dwl-guile* with a configuration file called *init.scm*, found in the directory *~/home/user/.config/dwl-guile~*:
+
+.B
+#+begin_src sh
+dwl-guile -c /home/user/.config/dwl-guile/init.scm
+#+end_src
+
+View clients assigned to tag 2:
+
+.B
+#+begin_src sh
+dwl-guile -e "(dwl:view 2)"
+#+end_src
+
+Bind *s-q* to kill the current client:
+
+.B
+#+begin_src sh
+dwl-guile -e "(set-keys \\"s-q\\" 'dwl:kill-client)"
+#+end_src
+
+* SEE ALSO
+*guile*​(1),
+*foot*​(1),
+*bemenu*​(1),
+*dwm*​(1),
+*xkeyboard-config*​(7)
diff --git a/dscm/bindings.h b/dscm/bindings.h
new file mode 100644
index 0000000..d3567c6
--- /dev/null
+++ b/dscm/bindings.h
@@ -0,0 +1,445 @@
+static inline SCM
+dscm_binding_monocle(SCM monitor)
+{
+	Monitor *m = (Monitor*)scm_to_pointer(monitor);
+	monocle(m);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_tile(SCM monitor)
+{
+	Monitor *m = (Monitor*)scm_to_pointer(monitor);
+	tile(m);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_spawn(SCM args)
+{
+	if (scm_is_null(args))
+		return SCM_BOOL_F;
+	unsigned int i = 0, length = scm_to_unsigned_integer(
+		scm_length(args), 0, UINT_MAX);
+	char *cmd_args[length + 1];
+	for (; i < length; i++) {
+		SCM arg_exp = scm_list_ref(args, scm_from_unsigned_integer(i));
+		char *arg = scm_to_locale_string(arg_exp);
+		cmd_args[i] = arg;
+	}
+	cmd_args[i] = NULL;
+	Arg a = {.v = cmd_args};
+	spawn(&a);
+	for (char **iter = cmd_args; *iter != NULL; iter++)
+		free(*iter);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_shcmd(SCM args)
+{
+	SCM sh_args = scm_string_join(args, scm_from_utf8_string(" "),
+				      scm_string_to_symbol(scm_from_utf8_string("infix")));
+	SCM extended = scm_list_3(scm_from_utf8_string("/bin/sh"),
+				  scm_from_utf8_string("-c"),
+				  sh_args);
+	return dscm_binding_spawn(extended);
+}
+
+static inline SCM
+dscm_binding_focusstack(SCM value)
+{
+	Arg a = {.i = scm_to_int(value)};
+	focusstack(&a);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_setmfact(SCM value)
+{
+	Arg a = {.f = scm_to_double(value)};
+	setmfact(&a);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_togglefloating()
+{
+	togglefloating(NULL);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_zoom()
+{
+	zoom(NULL);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_setlayout(SCM value)
+{
+	char *id = scm_to_locale_string(value);
+	Layout *l, *layout;
+	wl_list_for_each(l, &layouts, link)
+		if (strcmp(l->id, id) == 0)
+			layout = l;
+	if (layout == NULL)
+		return SCM_BOOL_F;
+	Arg a = {.v = layout};
+	setlayout(&a);
+	free(id);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_togglefullscreen()
+{
+	togglefullscreen(NULL);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_focusmon(SCM value)
+{
+	SCM eval = scm_primitive_eval(value);
+	Arg a = {.i = scm_to_int(eval)};
+	focusmon(&a);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_tagmon(SCM value)
+{
+	SCM eval = scm_primitive_eval(value);
+	Arg a = {.i = scm_to_int(eval)};
+	tagmon(&a);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_chvt(SCM tty)
+{
+	if (!scm_is_number(tty))
+		return SCM_BOOL_F;
+	int target_tty = scm_to_int(tty);
+	if (target_tty <= 0 || target_tty > 12)
+		return SCM_BOOL_F;
+	Arg a = {.ui = (unsigned int)target_tty};
+	chvt(&a);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_changealpha(SCM value)
+{
+	Arg a = {.f = scm_to_double(value)};
+	changealpha(&a);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_view(SCM value)
+{
+	Arg a = {.ui = dscm_get_tag(value, numtags)};
+	view(&a);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_viewprev(SCM value)
+{
+	viewprev(NULL);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_toggleview(SCM value)
+{
+	Arg a = {.ui = dscm_get_tag(value, numtags)};
+	toggleview(&a);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_tag(SCM value)
+{
+	Arg a = {.ui = dscm_get_tag(value, numtags)};
+	tag(&a);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_cyclelayout(SCM direction)
+{
+	Arg a = {.i = 1};
+	if (scm_is_number(direction))
+		a.i = scm_to_int(direction);
+	cyclelayout(&a);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incnmaster(SCM value)
+{
+	Arg a = {.i = scm_to_int(value)};
+	incnmaster(&a);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_toggletag(SCM value)
+{
+	Arg a = {.ui = dscm_get_tag(value, numtags)};
+	toggletag(&a);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_move()
+{
+	Arg a = {.ui = CurMove};
+	moveresize(&a);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_resize()
+{
+	Arg a = {.ui = CurResize};
+	moveresize(&a);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_killclient()
+{
+	killclient(NULL);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_quit()
+{
+	quit(NULL);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incrgaps(SCM value)
+{
+	Arg a = {.i = scm_to_int(value)};
+	incrgaps(&a);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incrigaps(SCM value)
+{
+	Arg a = {.i = scm_to_int(value)};
+	incrigaps(&a);
+	return SCM_BOOL_T;
+}
+static inline SCM
+dscm_binding_incrogaps(SCM value)
+{
+	Arg a = {.i = scm_to_int(value)};
+	incrogaps(&a);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_togglegaps()
+{
+	togglegaps(NULL);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_defaultgaps()
+{
+	defaultgaps(NULL);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_set(SCM rest)
+{
+	DSCM_SET_REST("set", rest, 2) {
+		SCM key = dscm_list_ref(rest, i);
+		SCM meta = scm_hash_ref(metadata, key, SCM_UNDEFINED);
+		DSCM_ASSERT(!scm_is_false(meta), "Invalid key in setter: ~a", key);
+
+		dscm_reloader_t func;
+		void *cvar = scm_to_pointer(scm_car(meta));
+		dscm_setter_t setter = (dscm_setter_t)scm_to_pointer(scm_cadr(meta));
+		(*setter)(cvar, dscm_list_ref(rest, i + 1));
+
+		/* When parsing the config for the first time, there is no need to
+		   manually reload the updated configuration parameter, since this
+		   will be done automatically right after.*/
+		if (!firstload) {
+			SCM reloader = scm_caddr(meta);
+			if (!scm_is_false(reloader)) {
+				func = (dscm_reloader_t)scm_to_pointer(reloader);
+				(*func)();
+			}
+		}
+	}
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_setkeys(SCM rest)
+{
+	DSCM_SET_REST("set-keys", rest, 2)
+		dscm_binding_set(
+			scm_list_2(dscm_string_to_symbol("keys"),
+				   scm_list_2(dscm_list_ref(rest, i),
+					      dscm_list_ref(rest, i + 1))));
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_setlayouts(SCM rest)
+{
+	DSCM_SET_REST("set-layouts", rest, 3)
+		dscm_binding_set(
+			scm_list_2(dscm_string_to_symbol("layouts"),
+				   scm_list_3(dscm_list_ref(rest, i),
+					      dscm_list_ref(rest, i + 1),
+					      dscm_list_ref(rest, i + 2))));
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_setrules(SCM rest)
+{
+	DSCM_SET_REST("set-rules", rest, 1)
+		dscm_binding_set(scm_list_2(dscm_string_to_symbol("rules"),
+					    dscm_list_ref(rest, i)));
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_setmonrules(SCM rest)
+{
+	DSCM_SET_REST("set-monitor-rules", rest, 1)
+		dscm_binding_set(scm_list_2(dscm_string_to_symbol("monrules"),
+					    dscm_list_ref(rest, i)));
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_setxkbrules(SCM xkb)
+{
+	dscm_binding_set(scm_list_2(dscm_string_to_symbol("xkb-rules"), xkb));
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_reloadconfig()
+{
+	dscm_config_load();
+	return SCM_BOOL_T;
+}
+
+static inline void
+dscm_register()
+{
+	scm_c_define("DIRECTION-LEFT", scm_from_int(WLR_DIRECTION_LEFT));
+	scm_c_define("DIRECTION-RIGHT", scm_from_int(WLR_DIRECTION_RIGHT));
+	scm_c_define("DIRECTION-UP", scm_from_int(WLR_DIRECTION_UP));
+	scm_c_define("DIRECTION-DOWN", scm_from_int(WLR_DIRECTION_DOWN));
+	scm_c_define("TRANSFORM-NORMAL",
+		     scm_from_int(WL_OUTPUT_TRANSFORM_NORMAL));
+	scm_c_define("TRANSFORM-ROTATE-90",
+		     scm_from_int(WL_OUTPUT_TRANSFORM_90));
+	scm_c_define("TRANSFORM-ROTATE-180",
+		     scm_from_int(WL_OUTPUT_TRANSFORM_180));
+	scm_c_define("TRANSFORM-ROTATE-270",
+		     scm_from_int(WL_OUTPUT_TRANSFORM_270));
+	scm_c_define("TRANSFORM-FLIPPED",
+		     scm_from_int(WL_OUTPUT_TRANSFORM_FLIPPED));
+	scm_c_define("TRANSFORM-FLIPPED-90",
+		     scm_from_int(WL_OUTPUT_TRANSFORM_FLIPPED_90));
+	scm_c_define("TRANSFORM-FLIPPED-180",
+		     scm_from_int(WL_OUTPUT_TRANSFORM_FLIPPED_180));
+	scm_c_define("TRANSFORM-FLIPPED-270",
+		     scm_from_int(WL_OUTPUT_TRANSFORM_FLIPPED_270));
+
+	/* libinput */
+	scm_c_define("SCROLL-NO-SCROLL",
+		     scm_from_int(LIBINPUT_CONFIG_SCROLL_NO_SCROLL));
+	scm_c_define("SCROLL-2FG",
+		     scm_from_int(LIBINPUT_CONFIG_SCROLL_2FG));
+	scm_c_define("SCROLL-EDGE",
+		     scm_from_int(LIBINPUT_CONFIG_SCROLL_EDGE));
+	scm_c_define("SCROLL-ON-BUTTON-DOWN",
+		     scm_from_int(LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN));
+
+	scm_c_define("CLICK-METHOD-NONE",
+		     scm_from_int(LIBINPUT_CONFIG_CLICK_METHOD_NONE));
+	scm_c_define("CLICK-METHOD-BUTTON-AREAS",
+		     scm_from_int(LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS));
+	scm_c_define("CLICK-METHOD-CLICKFINGER",
+		     scm_from_int(LIBINPUT_CONFIG_CLICK_METHOD_CLICKFINGER));
+
+	scm_c_define("TAP-MAP-LRM",
+		     scm_from_int(LIBINPUT_CONFIG_TAP_MAP_LRM));
+	scm_c_define("TAP-MAP-LMR",
+		     scm_from_int(LIBINPUT_CONFIG_TAP_MAP_LMR));
+
+	scm_c_define("SEND-EVENTS-ENABLED",
+		     scm_from_int(LIBINPUT_CONFIG_SEND_EVENTS_ENABLED));
+	scm_c_define("SEND-EVENTS-DISABLED",
+		     scm_from_int(LIBINPUT_CONFIG_SEND_EVENTS_DISABLED));
+	scm_c_define("SEND-EVENTS-DISABLED-ON-EXTERNAL-MOUSE",
+		     scm_from_int(LIBINPUT_CONFIG_SEND_EVENTS_DISABLED_ON_EXTERNAL_MOUSE));
+
+	scm_c_define("ACCEL-PROFILE-FLAT",
+		     scm_from_int(LIBINPUT_CONFIG_ACCEL_PROFILE_FLAT));
+	scm_c_define("ACCEL-PROFILE-ADAPTIVE",
+		     scm_from_int(LIBINPUT_CONFIG_ACCEL_PROFILE_ADAPTIVE));
+
+	/* dwl bindings */
+	scm_c_define_gsubr("dwl:chvt", 1, 0, 0, &dscm_binding_chvt);
+	scm_c_define_gsubr("dwl:quit", 0, 0, 0, &dscm_binding_quit);
+	scm_c_define_gsubr("dwl:kill-client", 0, 0, 0, &dscm_binding_killclient);
+	scm_c_define_gsubr("dwl:tile", 1, 0, 0, &dscm_binding_tile);
+	scm_c_define_gsubr("dwl:monocle", 1, 0, 0, &dscm_binding_monocle);
+	scm_c_define_gsubr("dwl:spawn", 0, 0, 1, &dscm_binding_spawn);
+	scm_c_define_gsubr("dwl:view", 1, 0, 0, &dscm_binding_view);
+	scm_c_define_gsubr("dwl:view-previous", 0, 0, 0, &dscm_binding_viewprev);
+	scm_c_define_gsubr("dwl:toggle-view", 1, 0, 0, &dscm_binding_toggleview);
+	scm_c_define_gsubr("dwl:tag", 1, 0, 0, &dscm_binding_tag);
+	scm_c_define_gsubr("dwl:cycle-layout", 0, 1, 0, &dscm_binding_cyclelayout);
+	scm_c_define_gsubr("dwl:toggle-tag", 1, 0, 0, &dscm_binding_toggletag);
+	scm_c_define_gsubr("dwl:focus-stack", 1, 0, 0, &dscm_binding_focusstack);
+	scm_c_define_gsubr("dwl:zoom", 0, 0, 0, &dscm_binding_zoom);
+	scm_c_define_gsubr("dwl:set-layout", 1, 0, 0, &dscm_binding_setlayout);
+	scm_c_define_gsubr("dwl:toggle-fullscreen", 0, 0, 0, &dscm_binding_togglefullscreen);
+	scm_c_define_gsubr("dwl:toggle-floating", 0, 0, 0, &dscm_binding_togglefloating);
+	scm_c_define_gsubr("dwl:focus-monitor", 1, 0, 0, &dscm_binding_focusmon);
+	scm_c_define_gsubr("dwl:tag-monitor", 1, 0, 0, &dscm_binding_tagmon);
+	scm_c_define_gsubr("dwl:move", 0, 0, 0, &dscm_binding_move);
+	scm_c_define_gsubr("dwl:resize", 0, 0, 0, &dscm_binding_resize);
+	scm_c_define_gsubr("dwl:change-masters", 1, 0, 0, &dscm_binding_incnmaster);
+	scm_c_define_gsubr("dwl:change-master-factor", 1, 0, 0, &dscm_binding_setmfact);
+	scm_c_define_gsubr("dwl:shcmd", 0, 0, 1, &dscm_binding_shcmd);
+	scm_c_define_gsubr("dwl:change-alpha", 1, 0, 0, &dscm_binding_changealpha);
+	scm_c_define_gsubr("dwl:toggle-gaps", 0, 0, 0, &dscm_binding_togglegaps);
+	scm_c_define_gsubr("dwl:default-gaps", 0, 0, 0, &dscm_binding_defaultgaps);
+	scm_c_define_gsubr("dwl:change-gaps", 1, 0, 0, &dscm_binding_incrgaps);
+	scm_c_define_gsubr("dwl:change-gaps-inner", 1, 0, 0, &dscm_binding_incrigaps);
+	scm_c_define_gsubr("dwl:change-gaps-outer", 1, 0, 0, &dscm_binding_incrogaps);
+
+	/* dwl-guile specific bindings */
+	scm_c_define_gsubr("dwl:reload-config", 0, 0, 0, &dscm_binding_reloadconfig);
+	scm_c_define_gsubr("set", 0, 0, 1, &dscm_binding_set);
+	scm_c_define_gsubr("set-keys", 0, 0, 1, &dscm_binding_setkeys);
+	scm_c_define_gsubr("set-layouts", 0, 0, 1, &dscm_binding_setlayouts);
+	scm_c_define_gsubr("set-rules", 0, 0, 1, &dscm_binding_setrules);
+	scm_c_define_gsubr("set-monitor-rules", 0, 0, 1, &dscm_binding_setmonrules);
+	scm_c_define_gsubr("set-xkb-rules", 1, 0, 0, &dscm_binding_setxkbrules);
+}
diff --git a/dscm/config.h b/dscm/config.h
new file mode 100644
index 0000000..5cc7623
--- /dev/null
+++ b/dscm/config.h
@@ -0,0 +1,756 @@
+#pragma once
+
+#define DSCM_DEFINE_P(CVAR, KEY, SETTER, RELOADER)			\
+	{								\
+		SCM m1 = scm_from_pointer(&(CVAR), NULL);		\
+		SCM m2 = scm_from_pointer(SETTER, NULL);		\
+		SCM m3 = SCM_BOOL_F;					\
+		scm_gc_protect_object(m1);				\
+		scm_gc_protect_object(m2);				\
+		if (RELOADER != NULL) {					\
+			m3 = scm_from_pointer(RELOADER, NULL);		\
+			scm_gc_protect_object(m3);			\
+		}							\
+		scm_hash_set_x(						\
+			metadata,					\
+			scm_string_to_symbol(scm_from_locale_string(KEY)), \
+			scm_list_3(m1, m2, m3));			\
+	}
+
+#define DSCM_DEFINE(CVAR, KEY, DEFVAL, SETTER, RELOADER)	\
+	{							\
+		(CVAR) = DEFVAL;				\
+		DSCM_DEFINE_P(CVAR, KEY, SETTER, RELOADER);	\
+	}
+
+static SCM metadata;
+
+/* Set to 0 after the initial config load */
+static unsigned int firstload = 1;
+static unsigned int inhibdef;
+
+/* Config variable definitions. */
+/* These will be automatically set from the guile config. */
+static double default_alpha;
+static unsigned int repeat_rate;
+static unsigned int repeat_delay;
+static unsigned int sloppyfocus;
+static unsigned int bypass_surface_visibility;
+static unsigned int borderpx;
+static unsigned int gappih;
+static unsigned int gappiv;
+static unsigned int gappoh;
+static unsigned int gappov;
+static unsigned int smartgaps;
+static unsigned int smartborders;
+
+/* No easy way to set these default values in a macro */
+static float rootcolor[4]     = {0.0, 0.0, 0.0, 1.0};
+static float bordercolor[4]   = {0.5, 0.5, 0.5, 1.0};
+static float focuscolor[4]    = {1.0, 0.0, 0.0, 1.0};
+static float fullscreen_bg[4] = {0.1, 0.1, 0.1, 1.0};
+static float lockscreen_bg[4] = {0.1, 0.1, 0.1, 1.0};
+
+static char **tags                      = NULL;
+static struct xkb_rule_names *xkb_rules = NULL;
+
+static struct wl_list keys;
+static struct wl_list buttons;
+static struct wl_list layouts;
+static struct wl_list rules;
+static struct wl_list monrules;
+
+static unsigned int numtags     = 0;
+static unsigned int TAGMASK     = 0;
+
+/* Trackpad and mouse */
+static double accel_speed;
+static unsigned int tap_to_click;
+static unsigned int tap_and_drag;
+static unsigned int drag_lock;
+static unsigned int natural_scrolling;
+static unsigned int disable_while_typing;
+static unsigned int left_handed;
+static unsigned int middle_button_emulation;
+static uint32_t send_events_mode;
+static enum libinput_config_scroll_method scroll_method;
+static enum libinput_config_click_method click_method;
+static enum libinput_config_tap_button_map button_map;
+static enum libinput_config_accel_profile accel_profile;
+
+static inline void
+setter_bool(void *cvar, SCM value)
+{
+	DSCM_ASSERT_TYPE(scm_is_bool(value), value, "set", DSCM_ARG2, "bool");
+	(*((unsigned int*)cvar)) = scm_to_bool(value);
+}
+
+static inline void
+setter_uint(void *cvar, SCM value)
+{
+	DSCM_ASSERT_TYPE(scm_is_integer(value), value, "set", DSCM_ARG2, "unsigned int");
+	(*((unsigned int*)cvar)) = scm_to_unsigned_integer(value, 0, UINT_MAX);
+}
+
+static inline void
+setter_uint32(void *cvar, SCM value)
+{
+	DSCM_ASSERT_TYPE(scm_is_integer(value), value, "set", DSCM_ARG2, "uint32");
+	(*((uint32_t*)cvar)) = scm_to_uint32(value);
+}
+
+static inline void
+setter_double(void *cvar, SCM value)
+{
+	DSCM_ASSERT_TYPE(scm_is_number(value), value, "set", DSCM_ARG2, "double");
+	(*((double*)cvar)) = scm_to_double(value);
+}
+
+static inline void
+setter_accel_speed(void *cvar, SCM value)
+{
+	DSCM_ASSERT_TYPE(scm_is_number(value), value, "set", DSCM_ARG2, "double");
+	double speed = scm_to_double(value);
+	DSCM_ASSERT((speed >= -1 && speed <= 1),
+		    "Acceleration speed should be between -1 and 1: ~s", value);
+	(*((double*)cvar)) = speed;
+}
+
+static inline void
+setter_color(void *cvar, SCM value)
+{
+	DSCM_ASSERT_TYPE((scm_is_true(scm_list_p(value)) || scm_is_string(value)),
+			 value, "set", DSCM_ARG2, "float[4] or string");
+
+	float color[4];
+	if (scm_is_string(value)) {
+		char *str, *ptr, *str_orig = scm_to_locale_string(value);
+		str = str_orig;
+		/* Color parsing logic adapted from [sway] */
+		if (*str == '#')
+			str++;
+		int len = strlen(str);
+
+		scm_dynwind_begin(0);
+		scm_dynwind_free(str_orig);
+
+		/* Disallows "0x" prefix that strtoul would ignore */
+		DSCM_ASSERT(((len == 6 || len == 8) &&
+			     isxdigit(str[0]) && isxdigit(str[1])),
+			    "Invalid hex color: ~s", value);
+
+		uint32_t parsed = strtoul(str, &ptr, 16);
+		DSCM_ASSERT(!(*ptr), "Invalid hex color: ~s", value);
+
+		if (len == 8) {
+			color[3] = ((parsed >> 0) & 0xff) / 255.0;
+			parsed >>= 8;
+		} else {
+			color[3] = 1.0;
+		}
+
+		color[0] = ((parsed >> 16) & 0xff) / 255.0;
+		color[1] = ((parsed >>  8) & 0xff) / 255.0;
+		color[2] = ((parsed >>  0) & 0xff) / 255.0;
+		scm_dynwind_end();
+	} else {
+		int length = scm_to_int(scm_length(value));
+		DSCM_ASSERT(((length >= 3) && (length <= 4)),
+			    "Invalid float color: ~s, expected RGB(A) format", value);
+		color[0] = (float)scm_to_double(scm_car(value));
+		color[1] = (float)scm_to_double(scm_cadr(value));
+		color[2] = (float)scm_to_double(scm_caddr(value));
+		color[3] = length == 4 ? (float)scm_to_double(scm_cadddr(value)) : 1.0;
+	}
+	memcpy(cvar, color, sizeof(color));
+}
+
+static inline void
+setter_tags(void *cvar, SCM value)
+{
+	DSCM_ASSERT_TYPE(scm_is_true(scm_list_p(value)),
+			 value, "set", DSCM_ARG2, "list[string]");
+	DSCM_ASSERT(!scm_is_null(value),
+		    "Invalid tag list, there must be at least one tag: ~a", value);
+	int length = scm_to_int(scm_length(value));
+	char **newtags = calloc(length, sizeof(char*));
+	for (int i = 0; i < length; i++) {
+		SCM ref = scm_list_ref(value, scm_from_int(i));
+		DSCM_ASSERT(scm_is_string(ref),
+			    "Invalid tag ~s, expected string: ~a", ref, value);
+		newtags[i] = scm_to_locale_string(ref);
+	}
+
+	char **tmp = tags, **end = tags + numtags;
+	tags = newtags;
+	numtags = length;
+	TAGMASK = ((1 << numtags) - 1);
+
+	if (tmp != NULL) {
+		for (char **ptr = tmp; ptr < end; ptr++)
+			free(*ptr);
+		free(tmp);
+	}
+}
+
+static inline void
+setter_xkb_rules(void *cvar, SCM value)
+{
+	DSCM_ASSERT_TYPE(scm_is_true(scm_list_p(value)),
+			 value, "set-xkb-rules", DSCM_ARG1, "alist");
+	struct xkb_rule_names *xkb = (*((struct xkb_rule_names**)cvar));
+	if (xkb) {
+		if (xkb->rules) free((char*)xkb->rules);
+		if (xkb->model) free((char*)xkb->model);
+		if (xkb->layout) free((char*)xkb->layout);
+		if (xkb->variant) free((char*)xkb->variant);
+		if (xkb->options) free((char*)xkb->options);
+	} else {
+		xkb = calloc(1, sizeof(struct xkb_rule_names));
+		(*((struct xkb_rule_names**)cvar)) = xkb;
+	}
+
+	xkb->rules = dscm_assoc_ref_string(value, "rules");
+	xkb->model = dscm_assoc_ref_string(value, "model");
+	xkb->layout = dscm_assoc_ref_string(value, "layout");
+	xkb->variant = dscm_assoc_ref_string(value, "variant");
+	xkb->options = dscm_assoc_ref_string(value, "options");
+}
+
+static inline void
+setter_binding(void *cvar, SCM value)
+{
+	Binding tmp, *b;
+	SCM sequence = scm_car(value);
+	SCM action = scm_cadr(value);
+
+	DSCM_ASSERT_TYPE(scm_is_string(sequence),
+			 value, "bind", DSCM_ARG2, "string");
+	DSCM_ASSERT_TYPE(dscm_is_callback(action),
+			 value, "bind", DSCM_ARG3, "symbol, procedure or sexp");
+	tmp.isbutton = 0;
+
+	/* Attempt to parse before any allocation */
+	char *seqstr = scm_to_locale_string(sequence);
+	dscm_parse_layered_binding_sequence(&tmp, seqstr);
+	free(seqstr);
+
+	struct wl_list *lst = tmp.isbutton ? &buttons : &keys;
+	wl_list_for_each(b, lst, link) {
+		if (b->n != tmp.n) continue;
+
+		int match = 0;
+		for (unsigned int i = 0; i < b->n; i++)
+			if (b->keys[i].key == tmp.keys[i].key &&
+			    b->keys[i].mod == tmp.keys[i].mod)
+				match++;
+
+		if (b->n == match) {
+			b->action = dscm_get_pointer(action);
+			return;
+		}
+	}
+
+	b = calloc(1, sizeof(Binding));
+	b->isbutton = tmp.isbutton;
+	b->n = tmp.n;
+	b->action = dscm_get_pointer(action);
+	memcpy(b->keys, tmp.keys, sizeof(tmp.keys));
+	wl_list_insert(lst, &b->link);
+}
+
+static inline void
+setter_layout(void *cvar, SCM value)
+{
+	SCM id = scm_car(value);
+	SCM symbol = scm_cadr(value);
+	SCM arrange = scm_caddr(value);
+
+	DSCM_ASSERT_TYPE(scm_is_symbol(id),
+			 value, "set-layouts", DSCM_ARG1, "symbol");
+	DSCM_ASSERT_TYPE(scm_is_string(symbol),
+			 value, "set-layouts", DSCM_ARG2, "string");
+	DSCM_ASSERT_TYPE(scm_is_symbol(arrange),
+			 value, "set-layouts", DSCM_ARG3, "symbol");
+
+	char *idstr = scm_to_locale_string(scm_symbol_to_string(id));
+	char *symbolstr = scm_to_locale_string(symbol);
+
+	Layout *l;
+	struct wl_list *lst = cvar;
+	wl_list_for_each(l, lst, link) {
+		if (!strcmp(l->id, idstr)) {
+			free(l->symbol);
+			free(idstr);
+			l->symbol = symbolstr;
+			l->arrange = dscm_get_pointer(arrange);
+			return;
+		}
+	}
+
+	/* not found */
+	l = calloc(1, sizeof(Layout));
+	l->id = idstr;
+	l->symbol = symbolstr;
+	l->arrange = dscm_get_pointer(arrange);
+	wl_list_insert(lst, &l->link);
+}
+
+static inline void
+setter_rule(void *cvar, SCM value)
+{
+	DSCM_ASSERT_TYPE(scm_is_true(scm_list_p(value)),
+			 value, "set-rules", DSCM_ARG1, "alist");
+	Rule *r;
+	int found = 0;
+	struct wl_list *lst = cvar;
+
+	char *id = dscm_assoc_ref_string(value, "id");
+	char *title = dscm_assoc_ref_string(value, "title");
+
+	DSCM_ASSERT((id || title), "Missing id and/or title in rule: ~s", value);
+
+	SCM tags = dscm_assoc_ref(value, "tags");
+	SCM floating = dscm_assoc_ref(value, "floating?");
+	SCM monitor = dscm_assoc_ref(value, "monitor");
+	SCM alpha = dscm_assoc_ref(value, "alpha");
+
+	wl_list_for_each(r, lst, link) {
+		if (((!r->id && !id) || (r->id && id && !strcmp(r->id, id))) &&
+		    ((!r->title && !title) || (r->title && title && !strcmp(r->title, title)))) {
+			found = 1;
+			if (id) free(id);
+			if (title) free(title);
+			break;
+		}
+	}
+
+	scm_dynwind_begin(0);
+
+	if (!found) {
+		r = calloc(1, sizeof(Rule));
+		r->id = id;
+		r->title = title;
+		r->monitor = -1;
+
+		scm_dynwind_unwind_handler(free, r, 0);
+		if (id) scm_dynwind_unwind_handler(free, id, 0);
+		if (title) scm_dynwind_unwind_handler(free, title, 0);
+	}
+
+	DSCM_ASSERT_TYPE(scm_is_bool(floating),
+			 value, "set-rules", "floating?", "bool");
+	r->isfloating = scm_to_bool(floating);
+
+	if (!scm_is_false(tags)) {
+		if (scm_is_true(scm_list_p(tags))) {
+			SCM ref;
+			for (int i = 0; i < scm_to_int(scm_length(tags)); i++) {
+				ref = scm_list_ref(tags, scm_from_int(i));
+				DSCM_ASSERT_TYPE(
+					scm_is_unsigned_integer(ref, 0, UINT_MAX),
+					value, "set-rules", "tags",
+					"list[unsigned int]");
+				r->tags |= (1 << dscm_get_tag(ref, numtags));
+			}
+		} else {
+			DSCM_ASSERT_TYPE(scm_is_unsigned_integer(tags, 0, UINT_MAX),
+					 value, "set-rules", "tags", "unsigned int");
+			r->tags = dscm_get_tag(tags, numtags);
+		}
+	}
+	if (!scm_is_false(monitor)) {
+		DSCM_ASSERT_TYPE(scm_is_integer(monitor),
+				 value, "set-rules", "monitor", "int");
+		r->monitor = scm_to_int(monitor);
+	}
+	if (!scm_is_false(alpha)) {
+		DSCM_ASSERT_TYPE(scm_is_number(alpha),
+				 value, "set-rules", "alpha", "double");
+		r->alpha = scm_to_double(alpha);
+	}
+
+	if (!found)
+		wl_list_insert(lst, &r->link);
+
+	scm_dynwind_end();
+}
+
+static inline void
+setter_monrule(void *cvar, SCM value)
+{
+	DSCM_ASSERT_TYPE(scm_is_true(scm_list_p(value)),
+			 value, "set-monitor-rules", DSCM_ARG1, "alist");
+	int found = 0;
+	MonitorRule *r;
+	struct wl_list *lst = cvar;
+
+	char *name = dscm_assoc_ref_string(value, "name");
+	SCM mfact = dscm_assoc_ref(value, "master-factor");
+	SCM nmaster = dscm_assoc_ref(value, "masters");
+	SCM scale = dscm_assoc_ref(value, "scale");
+	SCM rr = dscm_assoc_ref(value, "transform");
+	SCM lt = dscm_assoc_ref(value, "layout");
+
+	wl_list_for_each(r, lst, link) {
+		if ((!r->name && !name) || (r->name && name && !strcmp(r->name, name))) {
+			found = 1;
+			if (name) free(name);
+			break;
+		}
+	}
+
+	scm_dynwind_begin(0);
+
+	if (!found) {
+		r = calloc(1, sizeof(MonitorRule));
+		r->name = name;
+
+		/* Set sensible defaults just in case some parameters are not set */
+		r->scale = 1;
+		r->rr = WL_OUTPUT_TRANSFORM_NORMAL;
+		r->nmaster = 1;
+		r->mfact = 0.55;
+		/* init.scm will always define a layout, so this will always work */
+		r->lt = wl_container_of(layouts.next, r->lt, link);
+
+		scm_dynwind_unwind_handler(free, r, 0);
+		if (name) scm_dynwind_unwind_handler(free, name, 0);
+	}
+
+	if (!scm_is_false(mfact)) {
+		DSCM_ASSERT_TYPE(scm_is_number(mfact),
+				 value, "set-monitor-rules", "master-factor", "float");
+		r->mfact = (float)scm_to_double(mfact);
+	}
+	if (!scm_is_false(scale)) {
+		DSCM_ASSERT_TYPE(scm_is_number(scale),
+				 value, "set-monitor-rules", "scale", "float");
+		r->scale = (float)scm_to_double(scale);
+	}
+	if (!scm_is_false(nmaster)) {
+		DSCM_ASSERT_TYPE(scm_is_integer(nmaster),
+				 value, "set-monitor-rules", "masters", "int");
+		r->nmaster = scm_to_int(nmaster);
+	}
+	if (!scm_is_false(rr)) {
+		DSCM_ASSERT_TYPE(scm_is_symbol(rr),
+				 value, "set-monitor-rules", "transform", "symbol");
+		SCM rreval = scm_primitive_eval(rr);
+		DSCM_ASSERT(scm_is_integer(rreval),
+			    "Unbound transform ~s in monitor rule: ~a", rr, value);
+		r->rr = scm_to_int(rreval);
+	}
+	if (!scm_is_false(lt)) {
+		DSCM_ASSERT_TYPE(scm_is_symbol(lt),
+				 value, "set-monitor-rules", "layout",
+				 "symbol (matching id of defined layouts)");
+		Layout *l;
+		char *id = scm_to_locale_string(scm_symbol_to_string(lt));
+		wl_list_for_each(l, &layouts, link) {
+			if (!strcmp(l->id, id)) {
+				free(id);
+				r->lt = l;
+				break;
+			}
+		}
+	}
+
+	if (!found)
+		wl_list_insert(lst, &r->link);
+
+	scm_dynwind_end();
+}
+
+static inline void
+reload_libinput()
+{
+	Pointer *p;
+	wl_list_for_each(p, &pointers, link)
+		applylibinputrules(p->dev);
+}
+
+static inline void
+reload_borderpx()
+{
+	Client *c;
+	int draw_borders;
+	wl_list_for_each(c, &clients, link) {
+		draw_borders = c->bw;
+		resize(c, c->geom, 0, draw_borders);
+	}
+}
+
+static inline void
+reload_gaps()
+{
+	defaultgaps(NULL);
+}
+
+static inline void
+reload_arrange()
+{
+	Monitor *m;
+	wl_list_for_each(m, &mons, link)
+		arrange(m);
+}
+
+static inline void
+reload_rootcolor()
+{
+	wlr_scene_rect_set_color(root, rootcolor);
+}
+
+static inline void
+reload_bordercolor()
+{
+	Client *c;
+	float *color;
+	wl_list_for_each(c, &clients, link) {
+		color = focustop(selmon) == c ? focuscolor : bordercolor;
+		for (int i = 0; i < 4; i++)
+			wlr_scene_rect_set_color(c->border[i], color);
+	}
+}
+
+static inline void
+reload_fullscreen_bg()
+{
+	Monitor *m;
+	wl_list_for_each(m, &mons, link)
+		wlr_scene_rect_set_color(m->fullscreen_bg, fullscreen_bg);
+}
+
+static inline void
+reload_lockscreen_bg()
+{
+	wlr_scene_rect_set_color(locked_bg, lockscreen_bg);
+}
+
+static inline void
+reload_xkb_rules()
+{
+	Keyboard *kb;
+	struct xkb_keymap *keymap;
+	struct xkb_context *context;
+	wl_list_for_each(kb, &keyboards, link) {
+		context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
+		keymap = xkb_keymap_new_from_names(
+			context, xkb_rules, XKB_KEYMAP_COMPILE_NO_FLAGS);
+		wlr_keyboard_set_keymap(kb->wlr_keyboard, keymap);
+		xkb_keymap_unref(keymap);
+		xkb_context_unref(context);
+	}
+}
+
+static inline void
+reload_kbrepeat()
+{
+	Keyboard *kb;
+	wl_list_for_each(kb, &keyboards, link)
+		wlr_keyboard_set_repeat_info(
+			kb->wlr_keyboard, repeat_rate, repeat_delay);
+}
+
+static inline void
+reload_layouts()
+{
+	Layout *l;
+	DscmClient *c;
+	wl_list_for_each(c, &dscm_clients, link) {
+		wl_list_for_each(l, &layouts, link)
+			dscm_v1_send_layout(c->resource, l->symbol);
+	}
+}
+
+static inline void
+reload_rules()
+{
+	Client *c;
+	Monitor *m;
+	wl_list_for_each(c, &clients, link)
+		applyrules(c);
+	wl_list_for_each(m, &mons, link) {
+		arrangelayers(m);
+		arrange(m);
+	}
+
+	printstatus();
+}
+
+static inline void
+reload_monrules()
+{
+	Monitor *m;
+	wl_list_for_each(m, &mons, link)
+		applymonrules(m);
+}
+
+static inline void
+reload_tags()
+{
+	Client *c;
+	Monitor *m;
+	DscmClient *dc;
+	unsigned int newtags, update = 0;
+	wl_list_for_each(dc, &dscm_clients, link)
+		for (int i = 0; i < numtags; i++)
+			dscm_v1_send_tag(dc->resource, tags[i]);
+	/* TODO: setmon will call printstatus, add flag to disable? */
+	wl_list_for_each(c, &clients, link) {
+		newtags = c->tags & TAGMASK;
+		/* If the client was previosly rendered on a tag outside
+		   of the new tag range, reassign it to the last tag in the
+		   new tag set. */
+		if (c->tags > TAGMASK) {
+			update = 1;
+			c->tags = newtags | (1 << (numtags - 1));
+		}
+	}
+
+	if (update) {
+		wl_list_for_each(m, &mons, link) {
+			newtags = m->tagset[m->seltags] & TAGMASK;
+			if (m->tagset[m->seltags] > TAGMASK)
+				newtags |= (1 << (numtags - 1));
+			m->tagset[m->seltags] = newtags;
+			arrange(m);
+		}
+		printstatus();
+	}
+}
+
+static inline void
+dscm_config_load()
+{
+	/* Allow use of separate socket paths depending on whether
+	   we are using a stable or development build. */
+	scm_c_define("dwl:%repl-socket-path", scm_from_locale_string(REPL_SOCKET_PATH));
+	scm_c_define("dwl:%binary-path", scm_from_locale_string(BINARY_PATH));
+
+	if (firstload) scm_c_primitive_load(PREFIX "/share/dwl-guile/init.scm");
+	scm_c_primitive_load(config_file);
+
+	if (firstload) {
+		if (!inhibdef)
+			scm_c_primitive_load(PREFIX "/share/dwl-guile/defaults.scm");
+		firstload = 0;
+	}
+}
+
+static inline void
+dscm_config_initialize()
+{
+	wl_list_init(&keys);
+	wl_list_init(&buttons);
+	wl_list_init(&layouts);
+	wl_list_init(&rules);
+	wl_list_init(&monrules);
+
+	scm_permanent_object(metadata);
+	metadata = scm_make_hash_table(scm_from_int(1));
+
+	/* Populate keycode hash table */
+	dscm_keycodes_initialize();
+
+	/* Expose configuration option metadata */
+	scm_c_define("dwl:%metadata", metadata);
+
+	DSCM_DEFINE(inhibdef, "inhibit-defaults?", 0, &setter_bool, NULL);
+	DSCM_DEFINE(borderpx, "border-px", 1, &setter_uint, &reload_borderpx);
+	DSCM_DEFINE(gappih, "gaps-ih", 0, &setter_uint, &reload_gaps);
+	DSCM_DEFINE(gappiv, "gaps-iv", 0, &setter_uint, &reload_gaps);
+	DSCM_DEFINE(gappoh, "gaps-oh", 0, &setter_uint, &reload_gaps);
+	DSCM_DEFINE(gappov, "gaps-ov", 0, &setter_uint, &reload_gaps);
+
+	DSCM_DEFINE(default_alpha, "default-alpha", 1.0, &setter_double, NULL);
+	DSCM_DEFINE(bypass_surface_visibility, "bypass-surface-visibility", 1,
+		    &setter_uint, NULL);
+
+	DSCM_DEFINE(repeat_rate, "repeat-rate", 50, &setter_uint, &reload_kbrepeat);
+	DSCM_DEFINE(repeat_delay, "repeat-delay", 300, &setter_uint, &reload_kbrepeat);
+	DSCM_DEFINE(xkb_rules, "xkb-rules", NULL, &setter_xkb_rules, &reload_xkb_rules);
+
+	DSCM_DEFINE(sloppyfocus, "sloppy-focus?", 1, &setter_bool, NULL);
+	DSCM_DEFINE(smartgaps, "smart-gaps?", 0, &setter_bool, &reload_arrange);
+	DSCM_DEFINE(smartborders, "smart-borders?", 0, &setter_bool, &reload_arrange);
+	DSCM_DEFINE(tap_to_click, "tap-to-click?", 1, &setter_bool, &reload_libinput);
+	DSCM_DEFINE(tap_and_drag, "tap-and-drag?", 1, &setter_uint, &reload_libinput);
+	DSCM_DEFINE(drag_lock, "drag-lock?", 1, &setter_bool, &reload_libinput);
+	DSCM_DEFINE(left_handed, "left-handed?", 0, &setter_bool, &reload_libinput);
+	DSCM_DEFINE(natural_scrolling, "natural-scrolling?", 0,
+		    &setter_bool, &reload_libinput);
+	DSCM_DEFINE(disable_while_typing, "disable-while-typing?", 1,
+		    &setter_bool, &reload_libinput);
+	DSCM_DEFINE(middle_button_emulation, "middle-button-emulation?", 0,
+		    &setter_bool, &reload_libinput);
+
+	DSCM_DEFINE(accel_speed, "accel-speed", 0.0,
+		    &setter_accel_speed, &reload_libinput);
+	DSCM_DEFINE(accel_profile, "accel-profile",
+		    LIBINPUT_CONFIG_ACCEL_PROFILE_ADAPTIVE,
+		    &setter_uint32, &reload_libinput);
+	DSCM_DEFINE(send_events_mode, "send-events-mode",
+		    LIBINPUT_CONFIG_SEND_EVENTS_ENABLED,
+		    &setter_uint32, &reload_libinput);
+	DSCM_DEFINE(scroll_method, "scroll-method",
+		    LIBINPUT_CONFIG_SCROLL_2FG,
+		    &setter_uint32, &reload_libinput);
+	DSCM_DEFINE(click_method, "click-method",
+		    LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS,
+		    &setter_uint32, &reload_libinput);
+	DSCM_DEFINE(button_map, "button-map",
+		    LIBINPUT_CONFIG_TAP_MAP_LRM,
+		    &setter_uint32, &reload_libinput);
+
+	DSCM_DEFINE_P(rootcolor, "root-color", &setter_color, &reload_rootcolor);
+	DSCM_DEFINE_P(bordercolor, "border-color", &setter_color, &reload_bordercolor);
+	DSCM_DEFINE_P(focuscolor, "focus-color", &setter_color, &reload_bordercolor);
+	DSCM_DEFINE_P(fullscreen_bg, "fullscreen-color",
+		      &setter_color, &reload_fullscreen_bg);
+	DSCM_DEFINE_P(lockscreen_bg, "lockscreen-color",
+		      &setter_color, &reload_lockscreen_bg);
+
+	DSCM_DEFINE_P(keys, "keys", &setter_binding, NULL);
+	DSCM_DEFINE_P(buttons, "keys", &setter_binding, NULL);
+	DSCM_DEFINE_P(tags, "tags", &setter_tags, &reload_tags);
+	DSCM_DEFINE_P(layouts, "layouts", &setter_layout, &reload_layouts);
+	DSCM_DEFINE_P(rules, "rules", &setter_rule, &reload_rules);
+	DSCM_DEFINE_P(monrules, "monrules", &setter_monrule, &reload_monrules);
+}
+
+static inline void
+dscm_config_cleanup()
+{
+	Rule *r, *rtmp;
+	Layout *l, *ltmp;
+	Binding *b, *btmp;
+	MonitorRule *mr, *mrtmp;
+	wl_list_for_each_safe(r, rtmp, &rules, link) {
+		if (r->id) free(r->id);
+		if (r->title) free(r->title);
+		free(r);
+	}
+	wl_list_for_each_safe(mr, mrtmp, &monrules, link) {
+		if (mr->name) free(mr->name);
+		free(mr);
+	}
+	wl_list_for_each_safe(l, ltmp, &layouts, link) {
+		if (l->id) free(l->id);
+		if (l->symbol) free(l->symbol);
+		free(l);
+	}
+	wl_list_for_each_safe(b, btmp, &keys, link)
+		free(b);
+	wl_list_for_each_safe(b, btmp, &buttons, link)
+		free(b);
+	for (int i = 0; i < numtags; i++) free(tags[i]);
+	if (xkb_rules != NULL) {
+		if (xkb_rules->rules) free((char*)xkb_rules->rules);
+		if (xkb_rules->model) free((char*)xkb_rules->model);
+		if (xkb_rules->layout) free((char*)xkb_rules->layout);
+		if (xkb_rules->variant) free((char*)xkb_rules->variant);
+		if (xkb_rules->options) free((char*)xkb_rules->options);
+		free(xkb_rules);
+	}
+}
diff --git a/dscm/hooks.h b/dscm/hooks.h
new file mode 100644
index 0000000..488e9b5
--- /dev/null
+++ b/dscm/hooks.h
@@ -0,0 +1,34 @@
+static SCM hook_quit;
+static SCM hook_startup;
+
+static inline void
+dscm_hooks_run(SCM hook)
+{
+	scm_c_run_hook(hook, scm_list_n(SCM_UNDEFINED));
+}
+
+static inline SCM
+dscm_hooks_run_async_caller(void *hook)
+{
+	scm_t_bits *ptr = hook;
+	dscm_hooks_run(SCM_PACK_POINTER(ptr));
+	return SCM_BOOL_T;
+}
+
+static inline void
+dscm_hooks_run_async(SCM hook)
+{
+	scm_spawn_thread(dscm_hooks_run_async_caller,
+			 SCM_UNPACK_POINTER(hook), NULL, NULL);
+}
+
+static inline void
+dscm_hooks_initialize()
+{
+	hook_quit = scm_make_hook(scm_from_int(0));
+	hook_startup = scm_make_hook(scm_from_int(0));
+
+	/* Expose to Guile context */
+	scm_c_define("dwl:hook-quit", hook_quit);
+	scm_c_define("dwl:hook-startup", hook_startup);
+}
diff --git a/dscm/ipc.c b/dscm/ipc.c
new file mode 100644
index 0000000..d12f91e
--- /dev/null
+++ b/dscm/ipc.c
@@ -0,0 +1,78 @@
+#include <stdio.h>
+#include <string.h>
+#include <wayland-client.h>
+#include "ipc.h"
+#include "shared.h"
+#include "../util.h"
+#include "../dscm-unstable-v1-protocol-client.h"
+
+static struct dscm_v1 *dscm;
+static struct wl_display *display;
+static unsigned int done = 0;
+static void dscm_layout(void *data, struct dscm_v1 *d, const char *name);
+static void dscm_tag(void *data, struct dscm_v1 *d, const char *name);
+static void dscm_eval_result(void *data, struct dscm_v1 *d, const char *result,
+			uint32_t error);
+static void handle_global(void *data, struct wl_registry *registry,
+			  uint32_t name, const char *interface, uint32_t version);
+
+struct dscm_v1_listener dscm_listener = {
+	.tag = dscm_tag,
+	.layout = dscm_layout,
+	.eval_result = dscm_eval_result,
+};
+
+void
+dscm_tag(void *data, struct dscm_v1 *d, const char *name)
+{}
+
+void
+dscm_layout(void *data, struct dscm_v1 *d, const char *name)
+{}
+
+void
+dscm_eval_result(void *data, struct dscm_v1 *d, const char *result, uint32_t status)
+{
+	FILE *fd = status == DSCM_V1_EVAL_STATUS_SUCCESS ? stdout : stderr;
+	fprintf(fd, "%s\n", result);
+	done = 1;
+}
+
+void
+handle_global(void *data, struct wl_registry *registry,
+	      uint32_t name, const char *interface, uint32_t version)
+{
+	if (strcmp(interface, dscm_v1_interface.name) == 0) {
+		dscm = wl_registry_bind(registry, name, &dscm_v1_interface, 1);
+		dscm_v1_add_listener(dscm, &dscm_listener, NULL);
+	}
+}
+
+int dscm_ipc_evaluate(char *exp)
+{
+	if (!exp)
+		die("missing expression");
+
+	display = wl_display_connect(WAYLAND_SOCKET_PATH);
+	if (!display)
+		die("could not connect to display, is dwl-guile running?");
+
+	struct wl_registry *registry = wl_display_get_registry(display);
+	struct wl_registry_listener registry_listener = {.global = handle_global};
+
+	wl_registry_add_listener(registry, &registry_listener, NULL);
+	wl_display_roundtrip(display);
+
+	if (!dscm)
+		die("compositor does not support the dscm protocol");
+
+	dscm_v1_eval(dscm, exp);
+
+	/* Wait for result */
+	while (wl_display_dispatch(display) != -1 && !done) {}
+
+	dscm_v1_release(dscm);
+	wl_registry_destroy(registry);
+	wl_display_disconnect(display);
+	return 0;
+}
diff --git a/dscm/ipc.h b/dscm/ipc.h
new file mode 100644
index 0000000..0398222
--- /dev/null
+++ b/dscm/ipc.h
@@ -0,0 +1 @@
+int dscm_ipc_evaluate(char *exp);
diff --git a/dscm/keycodes.h b/dscm/keycodes.h
new file mode 100644
index 0000000..99e9de1
--- /dev/null
+++ b/dscm/keycodes.h
@@ -0,0 +1,236 @@
+/* Mapping key names to keycodes. */
+static SCM keycodes;
+static SCM keycodes_mouse;
+
+static inline void
+dscm_keycodes_initialize()
+{
+	scm_permanent_object(keycodes);
+	scm_permanent_object(keycodes_mouse);
+
+	keycodes = scm_make_hash_table(scm_from_int(211));
+	keycodes_mouse = scm_make_hash_table(scm_from_int(3));
+
+	/* Expose keycodes */
+	scm_c_define("dwl:%keycodes", keycodes);
+	scm_c_define("dwl:%keycodes-mouse", keycodes_mouse);
+
+	scm_hash_set_x(keycodes, scm_from_locale_string("<escape>"), scm_from_int(9));
+	scm_hash_set_x(keycodes, scm_from_locale_string("1"), scm_from_int(10));
+	scm_hash_set_x(keycodes, scm_from_locale_string("2"), scm_from_int(11));
+	scm_hash_set_x(keycodes, scm_from_locale_string("3"), scm_from_int(12));
+	scm_hash_set_x(keycodes, scm_from_locale_string("4"), scm_from_int(13));
+	scm_hash_set_x(keycodes, scm_from_locale_string("5"), scm_from_int(14));
+	scm_hash_set_x(keycodes, scm_from_locale_string("6"), scm_from_int(15));
+	scm_hash_set_x(keycodes, scm_from_locale_string("7"), scm_from_int(16));
+	scm_hash_set_x(keycodes, scm_from_locale_string("8"), scm_from_int(17));
+	scm_hash_set_x(keycodes, scm_from_locale_string("9"), scm_from_int(18));
+	scm_hash_set_x(keycodes, scm_from_locale_string("0"), scm_from_int(19));
+	scm_hash_set_x(keycodes, scm_from_locale_string("-"), scm_from_int(20));
+	scm_hash_set_x(keycodes, scm_from_locale_string("="), scm_from_int(21));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<backspace>"), scm_from_int(22));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<tab>"), scm_from_int(23));
+	scm_hash_set_x(keycodes, scm_from_locale_string("q"), scm_from_int(24));
+	scm_hash_set_x(keycodes, scm_from_locale_string("w"), scm_from_int(25));
+	scm_hash_set_x(keycodes, scm_from_locale_string("e"), scm_from_int(26));
+	scm_hash_set_x(keycodes, scm_from_locale_string("r"), scm_from_int(27));
+	scm_hash_set_x(keycodes, scm_from_locale_string("t"), scm_from_int(28));
+	scm_hash_set_x(keycodes, scm_from_locale_string("y"), scm_from_int(29));
+	scm_hash_set_x(keycodes, scm_from_locale_string("u"), scm_from_int(30));
+	scm_hash_set_x(keycodes, scm_from_locale_string("i"), scm_from_int(31));
+	scm_hash_set_x(keycodes, scm_from_locale_string("o"), scm_from_int(32));
+	scm_hash_set_x(keycodes, scm_from_locale_string("p"), scm_from_int(33));
+	scm_hash_set_x(keycodes, scm_from_locale_string("["), scm_from_int(34));
+	scm_hash_set_x(keycodes, scm_from_locale_string("]"), scm_from_int(35));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<return>"), scm_from_int(36));
+	scm_hash_set_x(keycodes, scm_from_locale_string("a"), scm_from_int(38));
+	scm_hash_set_x(keycodes, scm_from_locale_string("s"), scm_from_int(39));
+	scm_hash_set_x(keycodes, scm_from_locale_string("d"), scm_from_int(40));
+	scm_hash_set_x(keycodes, scm_from_locale_string("f"), scm_from_int(41));
+	scm_hash_set_x(keycodes, scm_from_locale_string("g"), scm_from_int(42));
+	scm_hash_set_x(keycodes, scm_from_locale_string("h"), scm_from_int(43));
+	scm_hash_set_x(keycodes, scm_from_locale_string("j"), scm_from_int(44));
+	scm_hash_set_x(keycodes, scm_from_locale_string("k"), scm_from_int(45));
+	scm_hash_set_x(keycodes, scm_from_locale_string("l"), scm_from_int(46));
+	scm_hash_set_x(keycodes, scm_from_locale_string(";"), scm_from_int(47));
+	scm_hash_set_x(keycodes, scm_from_locale_string("'"), scm_from_int(48));
+	scm_hash_set_x(keycodes, scm_from_locale_string("`"), scm_from_int(49));
+	scm_hash_set_x(keycodes, scm_from_locale_string("\\"), scm_from_int(51));
+	scm_hash_set_x(keycodes, scm_from_locale_string("z"), scm_from_int(52));
+	scm_hash_set_x(keycodes, scm_from_locale_string("x"), scm_from_int(53));
+	scm_hash_set_x(keycodes, scm_from_locale_string("c"), scm_from_int(54));
+	scm_hash_set_x(keycodes, scm_from_locale_string("v"), scm_from_int(55));
+	scm_hash_set_x(keycodes, scm_from_locale_string("b"), scm_from_int(56));
+	scm_hash_set_x(keycodes, scm_from_locale_string("n"), scm_from_int(57));
+	scm_hash_set_x(keycodes, scm_from_locale_string("m"), scm_from_int(58));
+	scm_hash_set_x(keycodes, scm_from_locale_string(","), scm_from_int(59));
+	scm_hash_set_x(keycodes, scm_from_locale_string("."), scm_from_int(60));
+	scm_hash_set_x(keycodes, scm_from_locale_string("/"), scm_from_int(61));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-multiply>"), scm_from_int(63));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<space>"), scm_from_int(65));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<caps-lock>"), scm_from_int(66));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<F1>"), scm_from_int(67));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<F2>"), scm_from_int(68));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<F3>"), scm_from_int(69));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<F4>"), scm_from_int(70));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<F5>"), scm_from_int(71));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<F6>"), scm_from_int(72));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<F7>"), scm_from_int(73));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<F8>"), scm_from_int(74));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<F9>"), scm_from_int(75));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<F10>"), scm_from_int(76));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<num-lock>"), scm_from_int(77));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<scroll-lock>"), scm_from_int(78));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-home>"), scm_from_int(79));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-7>"), scm_from_int(79));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-up>"), scm_from_int(80));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-8>"), scm_from_int(80));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-prior>"), scm_from_int(81));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-9>"), scm_from_int(81));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-subtract>"), scm_from_int(82));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-left>"), scm_from_int(83));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-4>"), scm_from_int(83));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-begin>"), scm_from_int(84));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-5>"), scm_from_int(84));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-right>"), scm_from_int(85));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-6>"), scm_from_int(85));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-add>"), scm_from_int(86));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-end>"), scm_from_int(87));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-1>"), scm_from_int(87));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-down>"), scm_from_int(88));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-2>"), scm_from_int(88));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-next>"), scm_from_int(89));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-3>"), scm_from_int(89));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-insert>"), scm_from_int(90));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-0>"), scm_from_int(90));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-delete>"), scm_from_int(91));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-period>"), scm_from_int(91));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<F11>"), scm_from_int(95));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<F12>"), scm_from_int(96));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-enter>"), scm_from_int(104));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-divide>"), scm_from_int(106));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<print>"), scm_from_int(107));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<linefeed>"), scm_from_int(109));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<home>"), scm_from_int(110));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<up>"), scm_from_int(111));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<prior>"), scm_from_int(112));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<page-up>"), scm_from_int(112));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<left>"), scm_from_int(113));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<right>"), scm_from_int(114));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<end>"), scm_from_int(115));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<down>"), scm_from_int(116));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<next>"), scm_from_int(117));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<page-down>"), scm_from_int(117));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<insert>"), scm_from_int(118));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<delete>"), scm_from_int(119));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86AudioMute>"), scm_from_int(121));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86AudioLowerVolume>"), scm_from_int(122));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86AudioRaiseVolume>"), scm_from_int(123));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86PowerOff>"), scm_from_int(124));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-equal>"), scm_from_int(125));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<plusminus>"), scm_from_int(126));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<pause>"), scm_from_int(127));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86LaunchA>"), scm_from_int(128));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<kp-decimal>"), scm_from_int(129));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<menu>"), scm_from_int(135));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<cancel>"), scm_from_int(136));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<redo>"), scm_from_int(137));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<undo>"), scm_from_int(139));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Copy>"), scm_from_int(141));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Open>"), scm_from_int(142));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Paste>"), scm_from_int(143));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<find>"), scm_from_int(144));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Cut>"), scm_from_int(145));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<help>"), scm_from_int(146));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86MenuKB>"), scm_from_int(147));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Calculator>"), scm_from_int(148));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Sleep>"), scm_from_int(150));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86WakeUp>"), scm_from_int(151));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Explorer>"), scm_from_int(152));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Send>"), scm_from_int(153));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Xfer>"), scm_from_int(155));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Launch1>"), scm_from_int(156));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Launch2>"), scm_from_int(157));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86WWW>"), scm_from_int(158));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86DOS>"), scm_from_int(159));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86ScreenSaver>"), scm_from_int(160));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86RotateWindows>"), scm_from_int(161));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86TaskPane>"), scm_from_int(162));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Mail>"), scm_from_int(163));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Favorites>"), scm_from_int(164));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86MyComputer>"), scm_from_int(165));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Back>"), scm_from_int(166));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Forward>"), scm_from_int(167));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Eject1>"), scm_from_int(169));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Eject2>"), scm_from_int(170));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86AudioNext>"), scm_from_int(171));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86AudioPlay>"), scm_from_int(172));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86AudioPrev>"), scm_from_int(173));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86AudioStop>"), scm_from_int(174));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86AudioRecord>"), scm_from_int(175));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86AudioRewind>"), scm_from_int(176));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Phone>"), scm_from_int(177));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Tools>"), scm_from_int(179));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86HomePage>"), scm_from_int(180));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Reload>"), scm_from_int(181));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Close>"), scm_from_int(182));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86ScrollUp>"), scm_from_int(185));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86ScrollDown>"), scm_from_int(186));
+	scm_hash_set_x(keycodes, scm_from_locale_string("("), scm_from_int(187));
+	scm_hash_set_x(keycodes, scm_from_locale_string(")"), scm_from_int(188));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86New>"), scm_from_int(189));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<redo2>"), scm_from_int(190));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Tools2>"), scm_from_int(191));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Launch5>"), scm_from_int(192));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Launch6>"), scm_from_int(193));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Launch7>"), scm_from_int(194));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Launch8>"), scm_from_int(195));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Launch9>"), scm_from_int(196));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86AudioMicMute>"), scm_from_int(198));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86TouchpadToggle>"), scm_from_int(199));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86TouchpadOn>"), scm_from_int(200));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86TouchpadOff>"), scm_from_int(201));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<mode-switch>"), scm_from_int(203));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86AudioPlay2>"), scm_from_int(208));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86AudioPause>"), scm_from_int(209));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Launch3>"), scm_from_int(210));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Launch4>"), scm_from_int(211));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86LaunchB>"), scm_from_int(212));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Suspend>"), scm_from_int(213));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Close2>"), scm_from_int(214));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86AudioPlay3>"), scm_from_int(215));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86AudioForward>"), scm_from_int(216));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<print2>"), scm_from_int(218));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86WebCam>"), scm_from_int(220));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86AudioPreset>"), scm_from_int(221));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Mail2>"), scm_from_int(223));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Messenger>"), scm_from_int(224));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Search>"), scm_from_int(225));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Go>"), scm_from_int(226));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Finance>"), scm_from_int(227));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Game>"), scm_from_int(228));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Shop>"), scm_from_int(229));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<cancel2>"), scm_from_int(231));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86MonBrightnessDown>"), scm_from_int(232));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86MonBrightnessUp>"), scm_from_int(233));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86AudioMedia>"), scm_from_int(234));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Display>"), scm_from_int(235));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86KbdLightOnOff>"), scm_from_int(236));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86KbdBrightnessDown>"), scm_from_int(237));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86KbdBrightnessUp>"), scm_from_int(238));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Send2>"), scm_from_int(239));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Reply>"), scm_from_int(240));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86MailForward>"), scm_from_int(241));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Save>"), scm_from_int(242));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Documents>"), scm_from_int(243));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Battery>"), scm_from_int(244));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86Bluetooth>"), scm_from_int(245));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86WLAN>"), scm_from_int(246));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86MonBrightnessCycle>"), scm_from_int(251));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86WWAN>"), scm_from_int(254));
+	scm_hash_set_x(keycodes, scm_from_locale_string("<XF86RFKill>"), scm_from_int(255));
+
+	scm_hash_set_x(keycodes_mouse, scm_from_locale_string("<mouse-left>"), scm_from_int(BTN_LEFT));
+	scm_hash_set_x(keycodes_mouse, scm_from_locale_string("<mouse-middle>"), scm_from_int(BTN_MIDDLE));
+	scm_hash_set_x(keycodes_mouse, scm_from_locale_string("<mouse-right>"), scm_from_int(BTN_RIGHT));
+}
diff --git a/dscm/shared.h b/dscm/shared.h
new file mode 100644
index 0000000..af256dc
--- /dev/null
+++ b/dscm/shared.h
@@ -0,0 +1,9 @@
+#ifdef DEVELOP
+#define BINARY_PATH PREFIX "/bin/dwl-guile-devel"
+#define REPL_SOCKET_PATH "/tmp/dwl-guile-devel.socket"
+#define WAYLAND_SOCKET_PATH "wayland-dwl-guile-devel"
+#else
+#define BINARY_PATH PREFIX "/bin/dwl-guile"
+#define REPL_SOCKET_PATH "/tmp/dwl-guile.socket"
+#define WAYLAND_SOCKET_PATH NULL
+#endif
diff --git a/dscm/utils.h b/dscm/utils.h
new file mode 100644
index 0000000..7411a8c
--- /dev/null
+++ b/dscm/utils.h
@@ -0,0 +1,266 @@
+#pragma once
+
+#define DSCM_ARG1 "1"
+#define DSCM_ARG2 "1"
+#define DSCM_ARG3 "1"
+#define DSCM_ARG4 "1"
+
+#define DSCM_ASSERT(PRED, MSG, ...)					\
+	if (!PRED) scm_misc_error(					\
+		"", MSG, scm_list_n(__VA_ARGS__, SCM_UNDEFINED))
+
+#define DSCM_ASSERT_TYPE(PRED, VALUE, SUBR, ARG, TYPE)			\
+	DSCM_ASSERT(PRED, SUBR ": Wrong type argument in position " ARG \
+		    " (expected " TYPE "): ~a", VALUE)
+
+#define DSCM_SET_REST(SUBR, REST, NUM)					\
+	int length = scm_to_int(scm_length(REST));			\
+	DSCM_ASSERT((length % NUM == 0),				\
+		    SUBR ": Invalid number of (rest) arguments: ~a", REST); \
+	for (int i = 0; i < length; i += NUM)
+
+enum { DSCM_CALL_ARRANGE, DSCM_CALL_ACTION };
+typedef struct {
+	SCM proc;
+	void *args;
+} dscm_call_data_t;
+
+typedef struct {
+	char *exp;
+	struct wl_resource *resource;
+	void (*callback)(struct wl_resource*, char*, uint32_t);
+} dscm_eval_call_data_t;
+
+typedef void(*dscm_reloader_t)();
+typedef void(*dscm_setter_t)(void*, SCM);
+
+static inline SCM
+dscm_list_ref(SCM list, int index)
+{
+	return scm_list_ref(list, scm_from_int(index));
+}
+
+static inline SCM
+dscm_string_to_symbol(const char *str)
+{
+	return scm_string_to_symbol(scm_from_locale_string(str));
+}
+
+static inline int
+dscm_is_callback(SCM cb)
+{
+	return (scm_is_symbol(cb) ||
+		scm_is_true(scm_procedure_p(cb)) ||
+		/* General quoted expressions are treated as lists */
+		scm_is_true(scm_list_p(cb)));
+}
+
+static inline SCM
+dscm_assoc_ref(SCM alist, const char* symbol)
+{
+	return scm_assoc_ref(alist, scm_string_to_symbol(scm_from_locale_string(symbol)));
+}
+
+static inline char*
+dscm_assoc_ref_string(SCM alist, const char *symbol)
+{
+	SCM value = dscm_assoc_ref(alist, symbol);
+	if (scm_is_string(value))
+		return scm_to_locale_string(value);
+	return NULL;
+}
+
+static inline scm_t_bits *
+dscm_get_pointer(SCM action)
+{
+	SCM actionref = action;
+	if (scm_is_false(scm_list_p(action))) {
+		actionref = scm_primitive_eval(action);
+		DSCM_ASSERT(scm_is_true(scm_procedure_p(actionref)),
+			    "Invalid action callback: ~s", actionref);
+	}
+	scm_gc_protect_object(actionref);
+	return SCM_UNPACK_POINTER(actionref);
+}
+
+static inline unsigned int
+dscm_get_tag(SCM tag, unsigned int max)
+{
+	unsigned int target_tag = scm_to_unsigned_integer(tag, 0, max);
+	if (target_tag == 0)
+		return ~0;
+	else
+		return (1 << (target_tag - 1));
+}
+
+static inline unsigned int
+dscm_parse_binding_sequence(Key *k, char *sequence, char *original)
+{
+	unsigned int isbutton = 0;
+	char *token, *next, *key, *ptr;
+	k->key = 0;
+	if ((key = strpbrk(sequence, "<"))) {
+		SCM sym = scm_from_locale_string(key);
+		SCM keycode = scm_hash_ref(keycodes, sym, SCM_UNDEFINED);
+		if (scm_is_false(keycode)) {
+			isbutton = 1;
+			keycode = scm_hash_ref(keycodes_mouse, sym, SCM_UNDEFINED);
+		}
+		DSCM_ASSERT((!scm_is_false(keycode)),
+			    "Invalid keysym ~s in bind sequence: ~s",
+			    sym, scm_from_locale_string(original));
+		k->key = (xkb_keycode_t)scm_to_uint32(keycode);
+	} else if ((key = strpbrk(sequence, "[")) && key[1] != '\0') {
+		for (ptr = &key[1]; !(*ptr == '\0' || *ptr == ']'); ptr++)
+			DSCM_ASSERT(isdigit(*ptr),
+				    "Invalid keycode in bind sequence: ~s",
+				    scm_from_locale_string(original));
+		DSCM_ASSERT((*ptr == ']'), "Trailing ']' in bind sequence: ~s",
+			    scm_from_locale_string(original));
+		*ptr = '\0';
+		k->key = atoi(&key[1]);
+	}
+
+	if (k->key != 0)
+		/* Replace < or [ with NULL to make sure that it is not included
+		   when parsing the modifiers. */
+		key[0] = '\0';
+	else
+		/* No special key was found, assume that the last token
+		   delimited by '-' is the key. */
+		key = NULL;
+
+	k->mod = 0;
+	token = strtok_r(sequence, "-", &sequence);
+	while (token) {
+		if ((next = strtok_r(NULL, "-", &sequence)) || key != NULL) {
+			if (!strcmp(token, "C"))
+				k->mod |= WLR_MODIFIER_CTRL;
+			else if (!strcmp(token, "M"))
+				k->mod |= WLR_MODIFIER_ALT;
+			else if (!strcmp(token, "S"))
+				k->mod |= WLR_MODIFIER_SHIFT;
+			else if (!strcmp(token, "s"))
+				k->mod |= WLR_MODIFIER_LOGO; // Super (Mod4)
+			else
+				DSCM_ASSERT(0,
+					    "Invalid modifier '~s' in bind sequence: ~s",
+					    scm_from_locale_string(token),
+					    scm_from_locale_string(original));
+		} else {
+			SCM sym = scm_from_locale_string(token);
+			SCM keycode = scm_hash_ref(keycodes, sym, SCM_UNDEFINED);
+			DSCM_ASSERT((!scm_is_false(keycode)),
+				    "Invalid keysym ~s in bind sequence: ~s",
+				    sym, scm_from_locale_string(original));
+			k->key = (xkb_keycode_t)scm_to_uint32(keycode);
+		}
+		token = next;
+	}
+	return isbutton;
+}
+
+static inline void
+dscm_parse_layered_binding_sequence(Binding *b, char *sequence)
+{
+	char *original = strdup(sequence), *token = strtok_r(sequence, " ", &sequence);
+	unsigned int n = 0, isbutton = 0;
+	while (token != NULL) {
+		b->isbutton = dscm_parse_binding_sequence(&b->keys[n], token, original);
+		n++;
+		if (n > 1) {
+			DSCM_ASSERT(!isbutton,
+				    "Mouse bindings can not use layered sequences: ~s",
+				    scm_from_locale_string(original));
+			DSCM_ASSERT((isbutton == b->isbutton),
+				    "Sequences can not contain both keys and mouse buttons: ~s",
+				    scm_from_locale_string(original));
+			DSCM_ASSERT((n <= MAX_KEYCHORD_LAYERS),
+				    "Only ~a sequences allowed per binding, but ~a provided: ~s",
+				    scm_from_int(MAX_KEYCHORD_LAYERS),
+				    scm_from_int(n),
+				    scm_from_locale_string(original));
+		}
+		isbutton = b->isbutton;
+		token = strtok_r(NULL, " ", &sequence);
+	}
+	b->n = n;
+	free(original);
+}
+
+static inline SCM
+dscm_call_eval(void *data)
+{
+	dscm_eval_call_data_t *call_data = data;
+	SCM eval = scm_c_eval_string(call_data->exp);
+	SCM evalstr = scm_object_to_string(eval, SCM_UNDEFINED);
+	char *result = scm_to_locale_string(evalstr);
+	(*(call_data->callback))(call_data->resource, result,
+				 DSCM_V1_EVAL_STATUS_SUCCESS);
+	free(call_data->exp);
+	free(call_data);
+	free(result);
+	return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_call_thread_handler(void *data, SCM key, SCM args)
+{
+	dscm_eval_call_data_t *call_data = data;
+	SCM error = scm_apply_2(
+		scm_c_public_ref("guile", "format"),
+		SCM_BOOL_F,
+		scm_cadr(args),
+		scm_caddr(args));
+	char *errorstr = scm_to_locale_string(error);
+	fprintf(stderr, "dscm: error in eval of %s\n=> %s\n",
+		call_data->exp, errorstr);
+	(*(call_data->callback))(call_data->resource, errorstr,
+				 DSCM_V1_EVAL_STATUS_ERROR);
+	free(errorstr);
+	free(call_data->exp);
+	free(call_data);
+	return SCM_BOOL_T;
+}
+
+static inline void*
+dscm_call_action(void *data)
+{
+	dscm_call_data_t *call_data = data;
+	if (scm_is_true(scm_list_p(call_data->proc)))
+		return scm_primitive_eval(call_data->proc);
+	return scm_call_0(call_data->proc);
+}
+
+static inline void*
+dscm_call_arrange(void *data)
+{
+	dscm_call_data_t *proc_data = (dscm_call_data_t*)data;
+	SCM mon = scm_from_pointer(proc_data->args, NULL);
+	return scm_call_1(proc_data->proc, mon);
+}
+
+static inline void
+dscm_safe_call(unsigned int type, scm_t_bits *proc_ptr, void *data)
+{
+	if (proc_ptr == NULL)
+		die("dscm: could not call proc that is NULL");
+	SCM proc = SCM_PACK_POINTER(proc_ptr);
+	void*(*func)(void*) = type == DSCM_CALL_ARRANGE ?
+		&dscm_call_arrange : &dscm_call_action;
+	scm_c_with_continuation_barrier(
+		func, &((dscm_call_data_t){.proc = proc, .args = data}));
+}
+
+static inline void
+dscm_thread_eval(struct wl_resource *resource,
+		void (*callback)(struct wl_resource*, char*, uint32_t),
+		char *exp)
+{
+	dscm_eval_call_data_t *proc_data = ecalloc(1, sizeof(dscm_eval_call_data_t));
+	proc_data->exp = exp;
+	proc_data->resource = resource;
+	proc_data->callback = callback;
+	scm_spawn_thread(dscm_call_eval, proc_data,
+			 dscm_call_thread_handler, proc_data);
+}
diff --git a/dwl.1 b/dwl.1
deleted file mode 100644
index cae1036..0000000
--- a/dwl.1
+++ /dev/null
@@ -1,151 +0,0 @@
-.Dd January 8, 2021
-.Dt DWL 1
-.Os
-.Sh NAME
-.Nm dwl
-.Nd dwm for Wayland
-.Sh SYNOPSIS
-.Nm
-.Op Fl v
-.Op Fl s Ar startup command
-.Sh DESCRIPTION
-.Nm
-is a Wayland compositor based on wlroots.
-It is intended to fill the same space in the Wayland world that
-.Nm dwm
-does for X11.
-.Pp
-When given the
-.Fl v
-option,
-.Nm
-writes its name and version to standard error and exits unsuccessfully.
-.Pp
-When given the
-.Fl s
-option,
-.Nm
-starts a shell process running
-.Ar command
-when starting.
-When stopping, it sends
-.Dv SIGTERM
-to the child process and waits for it to exit.
-.Pp
-Users are encouraged to customize
-.Nm
-by editing the sources, in particular
-.Pa config.h .
-The default key bindings are as follows:
-.Bl -tag -width 20n -offset indent -compact
-.It Mod-[1-9]
-Show only all windows with a tag.
-.It Mod-Ctrl-[1-9]
-Show all windows with a tag.
-.It Mod-Shift-[1-9]
-Move window to a single tag.
-.It Mod-Ctrl-Shift-[1-9]
-Toggle tag for window.
-.It Mod-p
-Spawn
-.Nm bemenu-run .
-.It Mod-Shift-Return
-Spawn
-.Nm foot .
-.It Mod-[jk]
-Move focus down/up the stack.
-.It Mod-[id]
-Increase/decrease number of windows in master area.
-.It Mod-[hl]
-Decrease/increase master area.
-.It Mod-Return
-Move window on top of stack or switch top of stack with second window.
-.It Mod-Tab
-Show only all windows with previous tag.
-.It Mod-Shift-c
-Close window.
-.It Mod-t
-Switch to tabbed layout.
-.It Mod-f
-Switch to floating layout.
-.It Mod-m
-Switch to monocle layout.
-.It Mod-Space
-Switch to previous layout.
-.It Mod-Shift-Space
-Toggle floating state of window.
-.It Mod-e
-Toggle fullscreen state of window.
-.It Mod-0
-Show all windows.
-.It Mod-Shift-0
-Set all tags for window.
-.It Mod-,
-Move focus to previous monitor.
-.It Mod-.
-Move focus to next monitor.
-.It Mod-Shift-,
-Move window to previous monitor.
-.It Mod-Shift-.
-Move window to next monitor.
-.It Mod-Shift-q
-Quit
-.Nm .
-.El
-These might differ depending on your keyboard layout.
-.Sh ENVIRONMENT
-These environment variables are used by
-.Nm :
-.Bl -tag -width XDG_RUNTIME_DIR
-.It Ev XDG_RUNTIME_DIR
-A directory where temporary user files, such as the Wayland socket,
-are stored.
-.It Ev XDG_CONFIG_DIR
-A directory containung configuration of various programs and
-libraries, including libxkbcommon.
-.It Ev DISPLAY , WAYLAND_DISPLAY , WAYLAND_SOCKET
-Tell how to connect to an underlying X11 or Wayland server.
-.It Ev WLR_*
-Various variables specific to wlroots.
-.It Ev XKB_* , XLOCALEDIR , XCOMPOSEFILE
-Various variables specific to libxkbcommon.
-.It Ev XCURSOR_PATH
-List of directories to search for XCursor themes in.
-.It Ev HOME
-A directory where there are always dear files there for you.
-Waiting for you to clean them up.
-.El
-.Pp
-These are set by
-.Nm :
-.Bl -tag -width WAYLAND_DISPLAY
-.It Ev WAYLAND_DISPLAY
-Tell how to connect to
-.Nm .
-.It Ev DISPLAY
-If using
-.Nm Xwayland ,
-tell how to connect to the
-.Nm Xwayland
-server.
-.El
-.Sh EXAMPLES
-Start
-.Nm
-with s6 in the background:
-.Dl dwl -s 's6-svscan <&-'
-.Sh SEE ALSO
-.Xr foot 1 ,
-.Xr bemenu 1 ,
-.Xr dwm 1 ,
-.Xr xkeyboard-config 7
-.Sh CAVEATS
-The child process's standard input is connected with a pipe to
-.Nm .
-If the child process neither reads from the pipe nor closes its
-standard input,
-.Nm
-will freeze after a while due to it blocking when writing to the full
-pipe buffer.
-.Sh BUGS
-All of them.
diff --git a/dwl.c b/dwl.c
index 19bb6ce..2b75de9 100644
--- a/dwl.c
+++ b/dwl.c
@@ -11,6 +11,7 @@
 #include <sys/wait.h>
 #include <time.h>
 #include <unistd.h>
+#include <ctype.h>
 #include <wayland-server-core.h>
 #include <wlr/backend.h>
 #include <wlr/backend/libinput.h>
@@ -52,6 +53,8 @@
 #include <wlr/types/wlr_xdg_shell.h>
 #include <wlr/util/log.h>
 #include <xkbcommon/xkbcommon.h>
+#include <libguile.h>
+#include "dscm-unstable-v1-protocol.h"
 #ifdef XWAYLAND
 #include <wlr/xwayland.h>
 #include <X11/Xlib.h>
@@ -66,10 +69,11 @@
 #define CLEANMASK(mask)         (mask & ~WLR_MODIFIER_CAPS)
 #define VISIBLEON(C, M)         ((M) && (C)->mon == (M) && ((C)->tags & (M)->tagset[(M)->seltags]))
 #define LENGTH(X)               (sizeof X / sizeof X[0])
+#define ROUND(X)                ((int)((X)+0.5))
 #define END(A)                  ((A) + LENGTH(A))
-#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
 #define LISTEN(E, L, H)         wl_signal_add((E), ((L)->notify = (H), (L)))
 #define IDLE_NOTIFY_ACTIVITY    wlr_idle_notify_activity(idle, seat), wlr_idle_notifier_v1_notify_activity(idle_notifier, seat)
+#define MAX_KEYCHORD_LAYERS     5
 
 /* enums */
 enum { CurNormal, CurPressed, CurMove, CurResize }; /* cursor */
@@ -84,16 +88,9 @@ typedef union {
 	int i;
 	unsigned int ui;
 	float f;
-	const void *v;
+	void *v;
 } Arg;
 
-typedef struct {
-	unsigned int mod;
-	unsigned int button;
-	void (*func)(const Arg *);
-	const Arg arg;
-} Button;
-
 typedef struct Monitor Monitor;
 typedef struct {
 	/* Must keep these three elements in this order */
@@ -126,15 +123,27 @@ typedef struct {
 	unsigned int tags;
 	int isfloating, isurgent, isfullscreen;
 	uint32_t resize; /* configure serial of a pending resize */
+	double alpha;
+	double prevalpha;
+	int prevx;
+	int prevy;
+	int prevwidth;
+	int prevheight;
 } Client;
 
 typedef struct {
-	uint32_t mod;
-	xkb_keysym_t keysym;
-	void (*func)(const Arg *);
-	const Arg arg;
+	unsigned int mod;
+	unsigned int key;
 } Key;
 
+typedef struct {
+	Key keys[MAX_KEYCHORD_LAYERS];
+	unsigned int n;
+	unsigned int isbutton;
+	scm_t_bits *action;
+	struct wl_list link;
+} Binding;
+
 typedef struct {
 	struct wl_list link;
 	struct wlr_keyboard *wlr_keyboard;
@@ -144,6 +153,12 @@ typedef struct {
 	struct wl_listener destroy;
 } Keyboard;
 
+typedef struct {
+	struct wl_list link;
+	struct wlr_input_device *dev;
+	struct wl_listener destroy;
+} Pointer;
+
 typedef struct {
 	/* Must keep these three elements in this order */
 	unsigned int type; /* LayerShell */
@@ -153,8 +168,8 @@ typedef struct {
 	struct wlr_scene_tree *popups;
 	struct wlr_scene_layer_surface_v1 *scene_layer;
 	struct wl_list link;
-	int mapped;
 	struct wlr_layer_surface_v1 *layer_surface;
+	int mapped;
 
 	struct wl_listener destroy;
 	struct wl_listener map;
@@ -163,10 +178,23 @@ typedef struct {
 } LayerSurface;
 
 typedef struct {
-	const char *symbol;
-	void (*arrange)(Monitor *);
+	char *id;
+	char *symbol;
+	scm_t_bits *arrange;
+	struct wl_list link;
 } Layout;
 
+typedef struct {
+	struct wl_list link;
+	struct wl_resource *resource;
+} DscmClient;
+
+typedef struct {
+	struct wl_list link;
+	struct wl_resource *resource;
+	struct Monitor *monitor;
+} DscmMonitor;
+
 struct Monitor {
 	struct wl_list link;
 	struct wlr_output *wlr_output;
@@ -179,49 +207,87 @@ struct Monitor {
 	struct wlr_box m;      /* monitor area, layout-relative */
 	struct wlr_box w;      /* window area, layout-relative */
 	struct wl_list layers[4]; /* LayerSurface::link */
+	struct wl_list dscm;
 	const Layout *lt[2];
 	unsigned int seltags;
 	unsigned int sellt;
 	unsigned int tagset[2];
+	unsigned int prevtagset;
 	double mfact;
+	int gappih;           /* horizontal gap between windows */
+	int gappiv;           /* vertical gap between windows */
+	int gappoh;           /* horizontal outer gaps */
+	int gappov;           /* vertical outer gaps */
 	int nmaster;
 };
 
 typedef struct {
-	const char *name;
+	char *name;
 	float mfact;
 	int nmaster;
 	float scale;
 	const Layout *lt;
 	enum wl_output_transform rr;
+	struct wl_list link;
 } MonitorRule;
 
 typedef struct {
-	const char *id;
-	const char *title;
+	char *id;
+	char *title;
 	unsigned int tags;
 	int isfloating;
+	double alpha;
 	int monitor;
+	struct wl_list link;
 } Rule;
 
 typedef struct {
 	struct wlr_scene_tree *scene;
-
 	struct wlr_session_lock_v1 *lock;
 	struct wl_listener new_surface;
 	struct wl_listener unlock;
 	struct wl_listener destroy;
 } SessionLock;
 
+/* dscm protocol */
+static void dscm_sendevents(void);
+static void dscm_closemon(struct wl_client *client, struct wl_resource *resource);
+static void dscm_destroymon(struct wl_resource *resource);
+static void dscm_printstatusmon(Monitor *m, const DscmMonitor *mon);
+static void dscm_printstatus(Monitor *m);
+static void dscm_settags(struct wl_client *client, struct wl_resource *resource,
+			 uint32_t t, uint32_t toggletagset);
+static void dscm_setlayout(struct wl_client *client, struct wl_resource *resource,
+			   uint32_t layout);
+static void dscm_setclient(struct wl_client *client, struct wl_resource *resource,
+			   uint32_t and, uint32_t xor);
+static void dscm_release(struct wl_client *client, struct wl_resource *resource);
+static void dscm_getmon(struct wl_client *client, struct wl_resource *resource,
+			uint32_t id, struct wl_resource *output);
+static void dscm_eval(struct wl_client *client, struct wl_resource *resource,
+		      const char *exp);
+static void dscm_eval_callback(struct wl_resource *resource, char *result,
+			       uint32_t status);
+static void dscm_destroy(struct wl_resource *resource);
+static void dscm_bind(struct wl_client *client, void *data, uint32_t version,
+		      uint32_t id);
+
 /* function declarations */
 static void applybounds(Client *c, struct wlr_box *bbox);
+static void applyexclusive(struct wlr_box *usable_area, uint32_t anchor,
+			   int32_t exclusive, int32_t margin_top,
+			   int32_t margin_right, int32_t margin_bottom,
+			   int32_t margin_left);
+static void applylibinputrules(struct wlr_input_device *dev);
+static void applymonrules(Monitor *m);
 static void applyrules(Client *c);
 static void arrange(Monitor *m);
 static void arrangelayer(Monitor *m, struct wl_list *list,
-		struct wlr_box *usable_area, int exclusive);
+			 struct wlr_box *usable_area, int exclusive);
 static void arrangelayers(Monitor *m);
 static void axisnotify(struct wl_listener *listener, void *data);
 static void buttonpress(struct wl_listener *listener, void *data);
+static void changealpha(const Arg *arg);
 static void chvt(const Arg *arg);
 static void checkidleinhibitor(struct wlr_surface *exclude);
 static void cleanup(void);
@@ -239,15 +305,18 @@ static void createmon(struct wl_listener *listener, void *data);
 static void createnotify(struct wl_listener *listener, void *data);
 static void createpointer(struct wlr_pointer *pointer);
 static void cursorframe(struct wl_listener *listener, void *data);
+static void cyclelayout(const Arg *arg);
 static void destroydragicon(struct wl_listener *listener, void *data);
 static void destroyidleinhibitor(struct wl_listener *listener, void *data);
 static void destroylayersurfacenotify(struct wl_listener *listener, void *data);
 static void destroylock(SessionLock *lock, int unlocked);
 static void destroylocksurface(struct wl_listener *listener, void *data);
 static void destroynotify(struct wl_listener *listener, void *data);
+static void destroypointer(struct wl_listener *listener, void *data);
 static void destroysessionlock(struct wl_listener *listener, void *data);
 static void destroysessionmgr(struct wl_listener *listener, void *data);
 static Monitor *dirtomon(enum wlr_direction dir);
+static void dragicondestroy(struct wl_listener *listener, void *data);
 static void focusclient(Client *c, int lift);
 static void focusmon(const Arg *arg);
 static void focusstack(const Arg *arg);
@@ -255,7 +324,7 @@ static Client *focustop(Monitor *m);
 static void fullscreennotify(struct wl_listener *listener, void *data);
 static void incnmaster(const Arg *arg);
 static void inputdevice(struct wl_listener *listener, void *data);
-static int keybinding(uint32_t mods, xkb_keysym_t sym);
+static int keybinding(uint32_t mods, xkb_keysym_t keysym);
 static void keypress(struct wl_listener *listener, void *data);
 static void keypressmod(struct wl_listener *listener, void *data);
 static void killclient(const Arg *arg);
@@ -269,16 +338,17 @@ static void motionnotify(uint32_t time);
 static void motionrelative(struct wl_listener *listener, void *data);
 static void moveresize(const Arg *arg);
 static void outputmgrapply(struct wl_listener *listener, void *data);
-static void outputmgrapplyortest(struct wlr_output_configuration_v1 *config, int test);
+static void outputmgrapplyortest(struct wlr_output_configuration_v1 *config,
+				 int test);
 static void outputmgrtest(struct wl_listener *listener, void *data);
 static void pointerfocus(Client *c, struct wlr_surface *surface,
-		double sx, double sy, uint32_t time);
+			 double sx, double sy, uint32_t time);
 static void printstatus(void);
 static void quit(const Arg *arg);
 static void quitsignal(int signo);
 static void rendermon(struct wl_listener *listener, void *data);
 static void requeststartdrag(struct wl_listener *listener, void *data);
-static void resize(Client *c, struct wlr_box geo, int interact);
+static void resize(Client *c, struct wlr_box geo, int interact, int draw_borders);
 static void run(char *startup_cmd);
 static void setcursor(struct wl_listener *listener, void *data);
 static void setfloating(Client *c, int floating);
@@ -286,9 +356,10 @@ static void setfullscreen(Client *c, int fullscreen);
 static void setlayout(const Arg *arg);
 static void setmfact(const Arg *arg);
 static void setmon(Client *c, Monitor *m, unsigned int newtags);
+static void setup();
+static void sigchld(int unused);
 static void setpsel(struct wl_listener *listener, void *data);
 static void setsel(struct wl_listener *listener, void *data);
-static void setup(void);
 static void spawn(const Arg *arg);
 static void startdrag(struct wl_listener *listener, void *data);
 static void tag(const Arg *arg);
@@ -305,11 +376,19 @@ static void updatemons(struct wl_listener *listener, void *data);
 static void updatetitle(struct wl_listener *listener, void *data);
 static void urgent(struct wl_listener *listener, void *data);
 static void view(const Arg *arg);
+static void viewprev(const Arg *arg);
 static void virtualkeyboard(struct wl_listener *listener, void *data);
+static void writepid(const char *runtimedir);
 static Monitor *xytomon(double x, double y);
 static struct wlr_scene_node *xytonode(double x, double y, struct wlr_surface **psurface,
-		Client **pc, LayerSurface **pl, double *nx, double *ny);
+				       Client **pc, LayerSurface **pl, double *nx, double *ny);
 static void zoom(const Arg *arg);
+static void setgaps(int oh, int ov, int ih, int iv);
+static void incrgaps(const Arg *arg);
+static void incrigaps(const Arg *arg);
+static void incrogaps(const Arg *arg);
+static void togglegaps(const Arg *arg);
+static void defaultgaps(const Arg *arg);
 
 /* variables */
 static const char broken[] = "broken";
@@ -317,6 +396,7 @@ static const char *cursor_image = "left_ptr";
 static pid_t child_pid = -1;
 static int locked;
 static void *exclusive_focus;
+static char *config_file = NULL;
 static struct wl_display *dpy;
 static struct wlr_backend *backend;
 static struct wlr_scene *scene;
@@ -324,18 +404,22 @@ static struct wlr_scene_tree *layers[NUM_LAYERS];
 static struct wlr_renderer *drw;
 static struct wlr_allocator *alloc;
 static struct wlr_compositor *compositor;
+static struct wlr_scene_rect *root;
 
 static struct wlr_xdg_shell *xdg_shell;
 static struct wlr_xdg_activation_v1 *activation;
 static struct wlr_xdg_decoration_manager_v1 *xdg_decoration_mgr;
 static struct wl_list clients; /* tiling order */
 static struct wl_list fstack;  /* focus order */
+static struct wl_list pointers;
+static struct wl_list dscm_clients;
 static struct wlr_idle *idle;
 static struct wlr_idle_notifier_v1 *idle_notifier;
 static struct wlr_idle_inhibit_manager_v1 *idle_inhibit_mgr;
 static struct wlr_input_inhibit_manager *input_inhibit_mgr;
 static struct wlr_layer_shell_v1 *layer_shell;
 static struct wlr_output_manager_v1 *output_mgr;
+static struct wlr_presentation *presentation;
 static struct wlr_virtual_keyboard_manager_v1 *virtual_keyboard_mgr;
 
 static struct wlr_cursor *cursor;
@@ -356,6 +440,9 @@ static struct wlr_box sgeom;
 static struct wl_list mons;
 static Monitor *selmon;
 
+static int enablegaps = 1;   /* enables gaps, used by togglegaps */
+static unsigned int currentkey = 0; /* used to keep track of keychord sequences */
+
 /* global event handlers */
 static struct wl_listener cursor_axis = {.notify = axisnotify};
 static struct wl_listener cursor_button = {.notify = buttonpress};
@@ -383,6 +470,19 @@ static struct wl_listener start_drag = {.notify = startdrag};
 static struct wl_listener session_lock_create_lock = {.notify = locksession};
 static struct wl_listener session_lock_mgr_destroy = {.notify = destroysessionmgr};
 
+/* dscm event handlers */
+static struct dscm_monitor_v1_interface dscm_monitor_implementation = {
+	.release = dscm_closemon,
+	.set_tags = dscm_settags,
+	.set_layout = dscm_setlayout,
+	.set_client_tags = dscm_setclient,
+};
+static struct dscm_v1_interface dscm_implementation = {
+	.release = dscm_release,
+	.get_monitor = dscm_getmon,
+	.eval = dscm_eval,
+};
+
 #ifdef XWAYLAND
 static void activatex11(struct wl_listener *listener, void *data);
 static void configurex11(struct wl_listener *listener, void *data);
@@ -397,14 +497,17 @@ static struct wlr_xwayland *xwayland;
 static Atom netatom[NetLast];
 #endif
 
-/* configuration, allows nested code to access above variables */
-#include "config.h"
-
 /* attempt to encapsulate suck into one file */
 #include "client.h"
 
-/* compile-time check if all tags fit into an unsigned int bit array. */
-struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
+/* include guile config and bindings */
+#include "dscm/shared.h"
+#include "dscm/ipc.h"
+#include "dscm/keycodes.h"
+#include "dscm/utils.h"
+#include "dscm/hooks.h"
+#include "dscm/config.h"
+#include "dscm/bindings.h"
 
 /* function implementations */
 void
@@ -434,13 +537,31 @@ applybounds(Client *c, struct wlr_box *bbox)
 		c->geom.y = bbox->y;
 }
 
+void
+applymonrules(Monitor *m)
+{
+	MonitorRule *r;
+	wl_list_for_each(r, &monrules, link) {
+		if (!r->name || strstr(m->wlr_output->name, r->name)) {
+			m->mfact = r->mfact;
+			m->nmaster = r->nmaster;
+			wlr_output_set_scale(m->wlr_output, r->scale);
+			wlr_xcursor_manager_load(cursor_mgr, r->scale);
+			m->lt[0] = m->lt[1] = r->lt;
+			wlr_output_set_transform(m->wlr_output, r->rr);
+			break;
+		}
+	}
+	wlr_output_commit(m->wlr_output);
+}
+
 void
 applyrules(Client *c)
 {
 	/* rule matching */
 	const char *appid, *title;
-	unsigned int i, newtags = 0;
-	const Rule *r;
+	unsigned int j, newtags = 0;
+	Rule *r;
 	Monitor *mon = selmon, *m;
 
 	c->isfloating = client_is_float_type(c);
@@ -449,14 +570,15 @@ applyrules(Client *c)
 	if (!(title = client_get_title(c)))
 		title = broken;
 
-	for (r = rules; r < END(rules); r++) {
+	wl_list_for_each(r, &rules, link) {
 		if ((!r->title || strstr(title, r->title))
-				&& (!r->id || strstr(appid, r->id))) {
+		    && (!r->id || strstr(appid, r->id))) {
 			c->isfloating = r->isfloating;
+			c->alpha = r->alpha;
 			newtags |= r->tags;
-			i = 0;
+			j = 0;
 			wl_list_for_each(m, &mons, link)
-				if (r->monitor == i++)
+				if (r->monitor == j++)
 					mon = m;
 		}
 	}
@@ -473,16 +595,17 @@ arrange(Monitor *m)
 			wlr_scene_node_set_enabled(&c->scene->node, VISIBLEON(c, m));
 
 	wlr_scene_node_set_enabled(&m->fullscreen_bg->node,
-			(c = focustop(m)) && c->isfullscreen);
+				   (c = focustop(m)) && c->isfullscreen);
 
 	if (m && m->lt[m->sellt]->arrange)
-		m->lt[m->sellt]->arrange(m);
+		dscm_safe_call(DSCM_CALL_ARRANGE, m->lt[m->sellt]->arrange, m);
 	motionnotify(0);
 	checkidleinhibitor(NULL);
 }
 
 void
-arrangelayer(Monitor *m, struct wl_list *list, struct wlr_box *usable_area, int exclusive)
+arrangelayer(Monitor *m, struct wl_list *list, struct wlr_box *usable_area,
+	     int exclusive)
 {
 	LayerSurface *layersurface;
 	struct wlr_box full_area = m->m;
@@ -496,7 +619,7 @@ arrangelayer(Monitor *m, struct wl_list *list, struct wlr_box *usable_area, int
 
 		wlr_scene_layer_surface_v1_configure(layersurface->scene_layer, &full_area, usable_area);
 		wlr_scene_node_set_position(&layersurface->popups->node,
-				layersurface->scene->node.x, layersurface->scene->node.y);
+					    layersurface->scene->node.x, layersurface->scene->node.y);
 		layersurface->geom.x = layersurface->scene->node.x;
 		layersurface->geom.y = layersurface->scene->node.y;
 	}
@@ -531,9 +654,9 @@ arrangelayers(Monitor *m)
 	/* Find topmost keyboard interactive layer, if such a layer exists */
 	for (i = 0; i < LENGTH(layers_above_shell); i++) {
 		wl_list_for_each_reverse(layersurface,
-				&m->layers[layers_above_shell[i]], link) {
+					 &m->layers[layers_above_shell[i]], link) {
 			if (!locked && layersurface->layer_surface->current.keyboard_interactive
-					&& layersurface->mapped) {
+			    && layersurface->mapped) {
 				/* Deactivate the focused client. */
 				focusclient(NULL, 0);
 				exclusive_focus = layersurface;
@@ -555,8 +678,8 @@ axisnotify(struct wl_listener *listener, void *data)
 	 * checking the event's orientation and the delta of the event */
 	/* Notify the client with pointer focus of the axis event. */
 	wlr_seat_pointer_notify_axis(seat,
-			event->time_msec, event->orientation, event->delta,
-			event->delta_discrete, event->source);
+				     event->time_msec, event->orientation, event->delta,
+				     event->delta_discrete, event->source);
 }
 
 void
@@ -566,7 +689,7 @@ buttonpress(struct wl_listener *listener, void *data)
 	struct wlr_keyboard *keyboard;
 	uint32_t mods;
 	Client *c;
-	const Button *b;
+	Binding *b;
 
 	IDLE_NOTIFY_ACTIVITY;
 
@@ -583,10 +706,11 @@ buttonpress(struct wl_listener *listener, void *data)
 
 		keyboard = wlr_seat_get_keyboard(seat);
 		mods = keyboard ? wlr_keyboard_get_modifiers(keyboard) : 0;
-		for (b = buttons; b < END(buttons); b++) {
-			if (CLEANMASK(mods) == CLEANMASK(b->mod) &&
-					event->button == b->button && b->func) {
-				b->func(&b->arg);
+		wl_list_for_each(b, &buttons, link) {
+			/* Mouse bindings can only have one key. */
+			if (CLEANMASK(mods) == CLEANMASK(b->keys[0].mod) &&
+			    event->button == b->keys[0].key && b->action) {
+				dscm_safe_call(DSCM_CALL_ACTION, b->action, NULL);
 				return;
 			}
 		}
@@ -612,7 +736,22 @@ buttonpress(struct wl_listener *listener, void *data)
 	/* If the event wasn't handled by the compositor, notify the client with
 	 * pointer focus that a button press has occurred */
 	wlr_seat_pointer_notify_button(seat,
-			event->time_msec, event->button, event->state);
+				       event->time_msec, event->button, event->state);
+}
+
+void
+changealpha(const Arg *arg)
+{
+	Client *sel = focustop(selmon);
+
+	if (sel) {
+		sel->alpha += arg->f;
+		if (sel->alpha > 1.0)
+			sel->alpha = 1.0;
+
+		if (sel->alpha < 0.1)
+			sel->alpha = 0.1;
+	}
 }
 
 void
@@ -629,8 +768,8 @@ checkidleinhibitor(struct wlr_surface *exclude)
 	wl_list_for_each(inhibitor, &idle_inhibit_mgr->inhibitors, link) {
 		struct wlr_surface *surface = wlr_surface_get_root_surface(inhibitor->surface);
 		struct wlr_scene_tree *tree = surface->data;
-		if (exclude != surface && (bypass_surface_visibility || (!tree
-				|| tree->node.enabled))) {
+		if (exclude != surface && (bypass_surface_visibility ||
+					   (!tree || tree->node.enabled))) {
 			inhibited = 1;
 			break;
 		}
@@ -676,6 +815,7 @@ cleanupkeyboard(struct wl_listener *listener, void *data)
 void
 cleanupmon(struct wl_listener *listener, void *data)
 {
+	DscmMonitor *mon, *montmp;
 	Monitor *m = wl_container_of(listener, m, destroy);
 	LayerSurface *l, *tmp;
 	int i;
@@ -692,6 +832,11 @@ cleanupmon(struct wl_listener *listener, void *data)
 	wlr_scene_output_destroy(m->scene_output);
 	wlr_scene_node_destroy(&m->fullscreen_bg->node);
 
+	wl_list_for_each_safe(mon, montmp, &m->dscm, link) {
+		wl_resource_set_user_data(mon->resource, NULL);
+		free(mon);
+	}
+
 	closemon(m);
 	free(m);
 }
@@ -714,7 +859,7 @@ closemon(Monitor *m)
 	wl_list_for_each(c, &clients, link) {
 		if (c->isfloating && c->geom.x > m->m.width)
 			resize(c, (struct wlr_box){.x = c->geom.x - m->w.width, .y = c->geom.y,
-				.width = c->geom.width, .height = c->geom.height}, 0);
+					.width = c->geom.width, .height = c->geom.height}, 0, 1);
 		if (c->mon == m)
 			setmon(c, selmon, c->tags);
 	}
@@ -725,7 +870,8 @@ closemon(Monitor *m)
 void
 commitlayersurfacenotify(struct wl_listener *listener, void *data)
 {
-	LayerSurface *layersurface = wl_container_of(listener, layersurface, surface_commit);
+	LayerSurface *layersurface = wl_container_of(listener, layersurface,
+						     surface_commit);
 	struct wlr_layer_surface_v1 *wlr_layer_surface = layersurface->layer_surface;
 	struct wlr_output *wlr_output = wlr_layer_surface->output;
 
@@ -736,18 +882,18 @@ commitlayersurfacenotify(struct wl_listener *listener, void *data)
 
 	if (layers[wlr_layer_surface->current.layer] != layersurface->scene->node.parent) {
 		wlr_scene_node_reparent(&layersurface->scene->node,
-				layers[wlr_layer_surface->current.layer]);
+					layers[wlr_layer_surface->current.layer]);
 		wlr_scene_node_reparent(&layersurface->popups->node,
-				layers[wlr_layer_surface->current.layer]);
+					layers[wlr_layer_surface->current.layer]);
 		wl_list_remove(&layersurface->link);
 		wl_list_insert(&layersurface->mon->layers[wlr_layer_surface->current.layer],
-				&layersurface->link);
+			       &layersurface->link);
 	}
 	if (wlr_layer_surface->current.layer < ZWLR_LAYER_SHELL_V1_LAYER_TOP)
 		wlr_scene_node_reparent(&layersurface->popups->node, layers[LyrTop]);
 
 	if (wlr_layer_surface->current.committed == 0
-			&& layersurface->mapped == wlr_layer_surface->mapped)
+	    && layersurface->mapped == wlr_layer_surface->mapped)
 		return;
 	layersurface->mapped = wlr_layer_surface->mapped;
 
@@ -762,8 +908,8 @@ commitnotify(struct wl_listener *listener, void *data)
 	client_get_geometry(c, &box);
 
 	if (c->mon && !wlr_box_empty(&box) && (box.width != c->geom.width - 2 * c->bw
-			|| box.height != c->geom.height - 2 * c->bw))
-		c->isfloating ? resize(c, c->geom, 1) : arrange(c->mon);
+					       || box.height != c->geom.height - 2 * c->bw))
+		c->isfloating ? resize(c, c->geom, 1, c->bw) : arrange(c->mon);
 
 	/* mark a pending resize as completed */
 	if (c->resize && c->resize <= c->surface.xdg->current.configure_serial)
@@ -777,6 +923,7 @@ createdecoration(struct wl_listener *listener, void *data)
 	wlr_xdg_toplevel_decoration_v1_set_mode(dec, WLR_XDG_TOPLEVEL_DECORATION_V1_MODE_SERVER_SIDE);
 }
 
+
 void
 createidleinhibitor(struct wl_listener *listener, void *data)
 {
@@ -796,8 +943,8 @@ createkeyboard(struct wlr_keyboard *keyboard)
 
 	/* Prepare an XKB keymap and assign it to the keyboard. */
 	context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
-	keymap = xkb_keymap_new_from_names(context, &xkb_rules,
-		XKB_KEYMAP_COMPILE_NO_FLAGS);
+	keymap = xkb_keymap_new_from_names(context, xkb_rules,
+					   XKB_KEYMAP_COMPILE_NO_FLAGS);
 
 	wlr_keyboard_set_keymap(keyboard, keymap);
 	xkb_keymap_unref(keymap);
@@ -831,28 +978,28 @@ createlayersurface(struct wl_listener *listener, void *data)
 	layersurface = ecalloc(1, sizeof(LayerSurface));
 	layersurface->type = LayerShell;
 	LISTEN(&wlr_layer_surface->surface->events.commit,
-			&layersurface->surface_commit, commitlayersurfacenotify);
+	       &layersurface->surface_commit, commitlayersurfacenotify);
 	LISTEN(&wlr_layer_surface->events.destroy, &layersurface->destroy,
-			destroylayersurfacenotify);
+	       destroylayersurfacenotify);
 	LISTEN(&wlr_layer_surface->events.map, &layersurface->map,
-			maplayersurfacenotify);
+	       maplayersurfacenotify);
 	LISTEN(&wlr_layer_surface->events.unmap, &layersurface->unmap,
-			unmaplayersurfacenotify);
+	       unmaplayersurfacenotify);
 
 	layersurface->layer_surface = wlr_layer_surface;
 	layersurface->mon = wlr_layer_surface->output->data;
 	wlr_layer_surface->data = layersurface;
 
 	layersurface->scene_layer = wlr_scene_layer_surface_v1_create(
-			layers[wlr_layer_surface->pending.layer], wlr_layer_surface);
+		layers[wlr_layer_surface->pending.layer], wlr_layer_surface);
 	layersurface->scene = layersurface->scene_layer->tree;
 	layersurface->popups = wlr_layer_surface->surface->data =
-			wlr_scene_tree_create(layers[wlr_layer_surface->pending.layer]);
+		wlr_scene_tree_create(layers[wlr_layer_surface->pending.layer]);
 
 	layersurface->scene->node.data = layersurface;
 
 	wl_list_insert(&layersurface->mon->layers[wlr_layer_surface->pending.layer],
-			&layersurface->link);
+		       &layersurface->link);
 
 	/* Temporarily set the layer's current state to pending
 	 * so that we can easily arrange it
@@ -889,10 +1036,15 @@ createmon(struct wl_listener *listener, void *data)
 	/* This event is raised by the backend when a new output (aka a display or
 	 * monitor) becomes available. */
 	struct wlr_output *wlr_output = data;
-	const MonitorRule *r;
 	size_t i;
 	Monitor *m = wlr_output->data = ecalloc(1, sizeof(*m));
+	wl_list_init(&m->dscm);
+
 	m->wlr_output = wlr_output;
+	m->gappih = gappih;
+	m->gappiv = gappiv;
+	m->gappoh = gappoh;
+	m->gappov = gappov;
 
 	wlr_output_init_render(wlr_output, alloc, drw);
 
@@ -900,17 +1052,7 @@ createmon(struct wl_listener *listener, void *data)
 	for (i = 0; i < LENGTH(m->layers); i++)
 		wl_list_init(&m->layers[i]);
 	m->tagset[0] = m->tagset[1] = 1;
-	for (r = monrules; r < END(monrules); r++) {
-		if (!r->name || strstr(wlr_output->name, r->name)) {
-			m->mfact = r->mfact;
-			m->nmaster = r->nmaster;
-			wlr_output_set_scale(wlr_output, r->scale);
-			wlr_xcursor_manager_load(cursor_mgr, r->scale);
-			m->lt[0] = m->lt[1] = r->lt;
-			wlr_output_set_transform(wlr_output, r->rr);
-			break;
-		}
-	}
+	applymonrules(m);
 
 	/* The mode is a tuple of (width, height, refresh rate), and each
 	 * monitor supports only a specific set of modes. We just pick the
@@ -974,7 +1116,9 @@ createnotify(struct wl_listener *listener, void *data)
 		if (!xdg_surface->popup->parent || type < 0)
 			return;
 		xdg_surface->surface->data = wlr_scene_xdg_surface_create(
-				xdg_surface->popup->parent->data, xdg_surface);
+			xdg_surface->popup->parent->data, xdg_surface);
+		/* Probably the check of `l` is useless, the only thing that can be NULL
+		 * is its monitor */
 		if ((l && !l->mon) || (c && !c->mon))
 			return;
 		box = type == LayerShell ? l->mon->m : c->mon->w;
@@ -989,58 +1133,79 @@ createnotify(struct wl_listener *listener, void *data)
 	c = xdg_surface->data = ecalloc(1, sizeof(*c));
 	c->surface.xdg = xdg_surface;
 	c->bw = borderpx;
+	c->alpha = default_alpha;
 
 	LISTEN(&xdg_surface->events.map, &c->map, mapnotify);
 	LISTEN(&xdg_surface->events.unmap, &c->unmap, unmapnotify);
 	LISTEN(&xdg_surface->events.destroy, &c->destroy, destroynotify);
 	LISTEN(&xdg_surface->toplevel->events.set_title, &c->set_title, updatetitle);
 	LISTEN(&xdg_surface->toplevel->events.request_fullscreen, &c->fullscreen,
-			fullscreennotify);
+	       fullscreennotify);
 	LISTEN(&xdg_surface->toplevel->events.request_maximize, &c->maximize,
-			maximizenotify);
+	       maximizenotify);
+}
+
+void
+applylibinputrules(struct wlr_input_device *dev)
+{
+	struct libinput_device *libinput_device = (struct libinput_device*)
+		wlr_libinput_get_device_handle(dev);
+
+	if (libinput_device_config_tap_get_finger_count(libinput_device)) {
+		libinput_device_config_tap_set_enabled(libinput_device, tap_to_click);
+		libinput_device_config_tap_set_drag_enabled(
+			libinput_device, tap_and_drag);
+		libinput_device_config_tap_set_drag_lock_enabled(
+			libinput_device, drag_lock);
+		libinput_device_config_tap_set_button_map(libinput_device, button_map);
+	}
+
+	if (libinput_device_config_scroll_has_natural_scroll(libinput_device))
+		libinput_device_config_scroll_set_natural_scroll_enabled(
+			libinput_device,natural_scrolling);
+
+	if (libinput_device_config_dwt_is_available(libinput_device))
+		libinput_device_config_dwt_set_enabled(
+			libinput_device, disable_while_typing);
+
+	if (libinput_device_config_left_handed_is_available(libinput_device))
+		libinput_device_config_left_handed_set(
+			libinput_device, left_handed);
+
+	if (libinput_device_config_middle_emulation_is_available(libinput_device))
+		libinput_device_config_middle_emulation_set_enabled(
+			libinput_device, middle_button_emulation);
+
+	if (libinput_device_config_scroll_get_methods(libinput_device) != LIBINPUT_CONFIG_SCROLL_NO_SCROLL)
+		libinput_device_config_scroll_set_method (
+			libinput_device, scroll_method);
+
+	if (libinput_device_config_click_get_methods(libinput_device) != LIBINPUT_CONFIG_CLICK_METHOD_NONE)
+		libinput_device_config_click_set_method(
+			libinput_device, click_method);
+
+	if (libinput_device_config_send_events_get_modes(libinput_device))
+		libinput_device_config_send_events_set_mode(
+			libinput_device, send_events_mode);
+
+	if (libinput_device_config_accel_is_available(libinput_device)) {
+		libinput_device_config_accel_set_profile(
+			libinput_device, accel_profile);
+		libinput_device_config_accel_set_speed(libinput_device, accel_speed);
+	}
 }
 
 void
 createpointer(struct wlr_pointer *pointer)
 {
+	Pointer *p;
 	if (wlr_input_device_is_libinput(&pointer->base)) {
-		struct libinput_device *libinput_device =  (struct libinput_device*)
-			wlr_libinput_get_device_handle(&pointer->base);
-
-		if (libinput_device_config_tap_get_finger_count(libinput_device)) {
-			libinput_device_config_tap_set_enabled(libinput_device, tap_to_click);
-			libinput_device_config_tap_set_drag_enabled(libinput_device, tap_and_drag);
-			libinput_device_config_tap_set_drag_lock_enabled(libinput_device, drag_lock);
-			libinput_device_config_tap_set_button_map(libinput_device, button_map);
-		}
-
-		if (libinput_device_config_scroll_has_natural_scroll(libinput_device))
-			libinput_device_config_scroll_set_natural_scroll_enabled(libinput_device, natural_scrolling);
-
-		if (libinput_device_config_dwt_is_available(libinput_device))
-			libinput_device_config_dwt_set_enabled(libinput_device, disable_while_typing);
-
-		if (libinput_device_config_left_handed_is_available(libinput_device))
-			libinput_device_config_left_handed_set(libinput_device, left_handed);
-
-		if (libinput_device_config_middle_emulation_is_available(libinput_device))
-			libinput_device_config_middle_emulation_set_enabled(libinput_device, middle_button_emulation);
-
-		if (libinput_device_config_scroll_get_methods(libinput_device) != LIBINPUT_CONFIG_SCROLL_NO_SCROLL)
-			libinput_device_config_scroll_set_method (libinput_device, scroll_method);
-		
-		if (libinput_device_config_click_get_methods(libinput_device) != LIBINPUT_CONFIG_CLICK_METHOD_NONE)
-			libinput_device_config_click_set_method (libinput_device, click_method);
-
-		if (libinput_device_config_send_events_get_modes(libinput_device))
-			libinput_device_config_send_events_set_mode(libinput_device, send_events_mode);
-
-		if (libinput_device_config_accel_is_available(libinput_device)) {
-			libinput_device_config_accel_set_profile(libinput_device, accel_profile);
-			libinput_device_config_accel_set_speed(libinput_device, accel_speed);
-		}
+		applylibinputrules(&pointer->base);
+		p = ecalloc(1, sizeof(Pointer));
+		p->dev = &pointer->base;
+		LISTEN(&p->dev->events.destroy, &p->destroy, destroypointer);
+		wl_list_insert(&pointers, &p->link);
 	}
-
 	wlr_cursor_attach_input_device(cursor, &pointer->base);
 }
 
@@ -1055,6 +1220,19 @@ cursorframe(struct wl_listener *listener, void *data)
 	wlr_seat_pointer_notify_frame(seat);
 }
 
+void
+cyclelayout(const Arg *arg)
+{
+	Layout *l;
+	if (!selmon || !(l = (Layout*)selmon->lt[selmon->sellt]))
+	    return;
+	struct wl_list *next = arg->i > 0 ? l->link.next : l->link.prev;
+	/* Do not include sentinel nodes */
+	if (next == &layouts)
+		next = arg->i > 0 ? layouts.next : layouts.prev;
+	setlayout(&((Arg) {.v = wl_container_of(next, l, link)}));
+}
+
 void
 destroydragicon(struct wl_listener *listener, void *data)
 {
@@ -1150,6 +1328,15 @@ destroynotify(struct wl_listener *listener, void *data)
 	free(c);
 }
 
+void
+destroypointer(struct wl_listener *listener, void *data)
+{
+	Pointer *p = wl_container_of(listener, p, destroy);
+	wl_list_remove(&p->destroy.link);
+	wl_list_remove(&p->link);
+	free(p);
+}
+
 void
 destroysessionlock(struct wl_listener *listener, void *data)
 {
@@ -1170,16 +1357,26 @@ dirtomon(enum wlr_direction dir)
 	struct wlr_output *next;
 	if (!wlr_output_layout_get(output_layout, selmon->wlr_output))
 		return selmon;
-	if ((next = wlr_output_layout_adjacent_output(output_layout,
-			dir, selmon->wlr_output, selmon->m.x, selmon->m.y)))
+	if ((next = wlr_output_layout_adjacent_output(
+		     output_layout, dir, selmon->wlr_output, selmon->m.x, selmon->m.y)))
 		return next->data;
-	if ((next = wlr_output_layout_farthest_output(output_layout,
-			dir ^ (WLR_DIRECTION_LEFT|WLR_DIRECTION_RIGHT),
-			selmon->wlr_output, selmon->m.x, selmon->m.y)))
+	if ((next = wlr_output_layout_farthest_output(
+		     output_layout, dir ^ (WLR_DIRECTION_LEFT|WLR_DIRECTION_RIGHT|WLR_DIRECTION_UP|WLR_DIRECTION_DOWN),
+		     selmon->wlr_output, selmon->m.x, selmon->m.y)))
 		return next->data;
 	return selmon;
 }
 
+void
+dragicondestroy(struct wl_listener *listener, void *data)
+{
+	struct wlr_drag_icon *icon = data;
+	wlr_scene_node_destroy(icon->data);
+	// Focus enter isn't sent during drag, so refocus the focused node.
+	focusclient(focustop(selmon), 1);
+	motionnotify(0);
+}
+
 void
 focusclient(Client *c, int lift)
 {
@@ -1220,12 +1417,12 @@ focusclient(Client *c, int lift)
 		LayerSurface *l = NULL;
 		int type = toplevel_from_wlr_surface(old, &w, &l);
 		if (type == LayerShell && l->scene->node.enabled
-				&& l->layer_surface->current.layer >= ZWLR_LAYER_SHELL_V1_LAYER_TOP) {
+		    && l->layer_surface->current.layer >= ZWLR_LAYER_SHELL_V1_LAYER_TOP) {
 			return;
 		} else if (w && w == exclusive_focus && client_wants_focus(w)) {
 			return;
-		/* Don't deactivate old client if the new one wants focus, as this causes issues with winecfg
-		 * and probably other clients */
+			/* Don't deactivate old client if the new one wants focus, as this causes issues with winecfg
+			 * and probably other clients */
 		} else if (w && !client_is_unmanaged(w) && (!c || !client_wants_focus(c))) {
 			for (i = 0; i < 4; i++)
 				wlr_scene_rect_set_color(w->border[i], bordercolor);
@@ -1233,6 +1430,7 @@ focusclient(Client *c, int lift)
 			client_activate_surface(old, 0);
 		}
 	}
+
 	printstatus();
 
 	if (!c) {
@@ -1348,41 +1546,42 @@ inputdevice(struct wl_listener *listener, void *data)
 }
 
 int
-keybinding(uint32_t mods, xkb_keysym_t sym)
+keybinding(uint32_t mods, xkb_keycode_t keycode)
 {
 	/*
 	 * Here we handle compositor keybindings. This is when the compositor is
 	 * processing keys, rather than passing them on to the client for its own
 	 * processing.
 	 */
-	int handled = 0;
-	const Key *k;
-	for (k = keys; k < END(keys); k++) {
-		if (CLEANMASK(mods) == CLEANMASK(k->mod) &&
-				sym == k->keysym && k->func) {
-			k->func(&k->arg);
+	int handled = 0, done = 0;
+	Binding *k;
+	wl_list_for_each(k, &keys, link) {
+		if (k->n <= currentkey) continue;
+		if (CLEANMASK(mods) == CLEANMASK(k->keys[currentkey].mod) &&
+		    keycode == (xkb_keycode_t)k->keys[currentkey].key) {
 			handled = 1;
+			if (currentkey == k->n - 1 && k->action) {
+				dscm_safe_call(DSCM_CALL_ACTION, k->action, NULL);
+				done = 1;
+			}
+			/* TODO: Keep break? Was not needed before. */
+			break;
 		}
 	}
+	currentkey = (!handled || done == 1) ? 0 : currentkey + 1;
 	return handled;
 }
 
 void
 keypress(struct wl_listener *listener, void *data)
 {
-	int i;
+	int i, handled = 0;
 	/* This event is raised when a key is pressed or released. */
 	Keyboard *kb = wl_container_of(listener, kb, key);
 	struct wlr_keyboard_key_event *event = data;
 
 	/* Translate libinput keycode -> xkbcommon */
 	uint32_t keycode = event->keycode + 8;
-	/* Get a list of keysyms based on the keymap for this keyboard */
-	const xkb_keysym_t *syms;
-	int nsyms = xkb_state_key_get_syms(
-			kb->wlr_keyboard->xkb_state, keycode, &syms);
-
-	int handled = 0;
 	uint32_t mods = wlr_keyboard_get_modifiers(kb->wlr_keyboard);
 
 	IDLE_NOTIFY_ACTIVITY;
@@ -1390,15 +1589,14 @@ keypress(struct wl_listener *listener, void *data)
 	/* On _press_ if there is no active screen locker,
 	 * attempt to process a compositor keybinding. */
 	if (!locked && !input_inhibit_mgr->active_inhibitor
-			&& event->state == WL_KEYBOARD_KEY_STATE_PRESSED)
-		for (i = 0; i < nsyms; i++)
-			handled = keybinding(mods, syms[i]) || handled;
+	    && event->state == WL_KEYBOARD_KEY_STATE_PRESSED)
+		handled = keybinding(mods, keycode) || handled;
 
 	if (!handled) {
 		/* Pass unhandled keycodes along to the client. */
 		wlr_seat_set_keyboard(seat, kb->wlr_keyboard);
 		wlr_seat_keyboard_notify_key(seat, event->time_msec,
-			event->keycode, event->state);
+					     event->keycode, event->state);
 	}
 }
 
@@ -1417,7 +1615,7 @@ keypressmod(struct wl_listener *listener, void *data)
 	wlr_seat_set_keyboard(seat, kb->wlr_keyboard);
 	/* Send modifiers to the client. */
 	wlr_seat_keyboard_notify_modifiers(seat,
-		&kb->wlr_keyboard->modifiers);
+					   &kb->wlr_keyboard->modifiers);
 }
 
 void
@@ -1473,12 +1671,12 @@ mapnotify(struct wl_listener *listener, void *data)
 	c->scene = wlr_scene_tree_create(layers[LyrTile]);
 	wlr_scene_node_set_enabled(&c->scene->node, c->type != XDGShell);
 	c->scene_surface = c->type == XDGShell
-			? wlr_scene_xdg_surface_create(c->scene, c->surface.xdg)
-			: wlr_scene_subsurface_tree_create(c->scene, client_surface(c));
+		? wlr_scene_xdg_surface_create(c->scene, c->surface.xdg)
+		: wlr_scene_subsurface_tree_create(c->scene, client_surface(c));
 	if (client_surface(c)) {
 		client_surface(c)->data = c->scene;
 		/* Ideally we should do this in createnotify{,x11} but at that moment
-		* wlr_xwayland_surface doesn't have wlr_surface yet. */
+		 * wlr_xwayland_surface doesn't have wlr_surface yet. */
 		LISTEN(&client_surface(c)->events.commit, &c->commit, commitnotify);
 	}
 	c->scene->node.data = c->scene_surface->node.data = c;
@@ -1490,7 +1688,7 @@ mapnotify(struct wl_listener *listener, void *data)
 		/* Unmanaged clients always are floating */
 		wlr_scene_node_reparent(&c->scene->node, layers[LyrFloat]);
 		wlr_scene_node_set_position(&c->scene->node, c->geom.x + borderpx,
-			c->geom.y + borderpx);
+					    c->geom.y + borderpx);
 		if (client_wants_focus(c)) {
 			focusclient(c, 1);
 			exclusive_focus = c;
@@ -1518,7 +1716,7 @@ mapnotify(struct wl_listener *listener, void *data)
 	 * we always consider floating, clients that have parent and thus
 	 * we set the same tags and monitor than its parent, if not
 	 * try to apply rules for them */
-	 /* TODO: https://github.com/djpohly/dwl/pull/334#issuecomment-1330166324 */
+	/* TODO: https://github.com/djpohly/dwl/pull/334#issuecomment-1330166324 */
 	if (c->type == XDGShell && (p = client_get_parent(c))) {
 		c->isfloating = 1;
 		wlr_scene_node_reparent(&c->scene->node, layers[LyrFloat]);
@@ -1555,7 +1753,7 @@ monocle(Monitor *m)
 	wl_list_for_each(c, &clients, link) {
 		if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
 			continue;
-		resize(c, m->w, 0);
+		resize(c, m->w, 0, !smartborders);
 	}
 	if ((c = focustop(m)))
 		wlr_scene_node_raise_to_top(&c->scene->node);
@@ -1597,16 +1795,16 @@ motionnotify(uint32_t time)
 	/* Update drag icon's position if any */
 	if (seat->drag && (icon = seat->drag->icon))
 		wlr_scene_node_set_position(icon->data, cursor->x + icon->surface->sx,
-				cursor->y + icon->surface->sy);
+					    cursor->y + icon->surface->sy);
 	/* If we are currently grabbing the mouse, handle and return */
 	if (cursor_mode == CurMove) {
 		/* Move the grabbed client to the new position. */
 		resize(grabc, (struct wlr_box){.x = cursor->x - grabcx, .y = cursor->y - grabcy,
-			.width = grabc->geom.width, .height = grabc->geom.height}, 1);
+				.width = grabc->geom.width, .height = grabc->geom.height}, 1, 1);
 		return;
 	} else if (cursor_mode == CurResize) {
 		resize(grabc, (struct wlr_box){.x = grabc->geom.x, .y = grabc->geom.y,
-			.width = cursor->x - grabc->geom.x, .height = cursor->y - grabc->geom.y}, 1);
+				.width = cursor->x - grabc->geom.x, .height = cursor->y - grabc->geom.y}, 1, 1);
 		return;
 	}
 
@@ -1668,10 +1866,10 @@ moveresize(const Arg *arg)
 		/* Doesn't work for X11 output - the next absolute motion event
 		 * returns the cursor to where it started */
 		wlr_cursor_warp_closest(cursor, NULL,
-				grabc->geom.x + grabc->geom.width,
-				grabc->geom.y + grabc->geom.height);
+					grabc->geom.x + grabc->geom.width,
+					grabc->geom.y + grabc->geom.height);
 		wlr_xcursor_manager_set_cursor_image(cursor_mgr,
-				(cursor_image = "bottom_right_corner"), cursor);
+						     (cursor_image = "bottom_right_corner"), cursor);
 		break;
 	}
 }
@@ -1706,21 +1904,21 @@ outputmgrapplyortest(struct wlr_output_configuration_v1 *config, int test)
 			wlr_output_set_mode(wlr_output, config_head->state.mode);
 		else
 			wlr_output_set_custom_mode(wlr_output,
-					config_head->state.custom_mode.width,
-					config_head->state.custom_mode.height,
-					config_head->state.custom_mode.refresh);
+						   config_head->state.custom_mode.width,
+						   config_head->state.custom_mode.height,
+						   config_head->state.custom_mode.refresh);
 
 		/* Don't move monitors if position wouldn't change, this to avoid
 		 * wlroots marking the output as manually configured */
 		if (m->m.x != config_head->state.x || m->m.y != config_head->state.y)
 			wlr_output_layout_move(output_layout, wlr_output,
-					config_head->state.x, config_head->state.y);
+					       config_head->state.x, config_head->state.y);
 		wlr_output_set_transform(wlr_output, config_head->state.transform);
 		wlr_output_set_scale(wlr_output, config_head->state.scale);
 		wlr_output_enable_adaptive_sync(wlr_output,
-				config_head->state.adaptive_sync_enabled);
+						config_head->state.adaptive_sync_enabled);
 
-apply_or_test:
+	apply_or_test:
 		if (test) {
 			ok &= wlr_output_test(wlr_output);
 			wlr_output_rollback(wlr_output);
@@ -1748,7 +1946,7 @@ outputmgrtest(struct wl_listener *listener, void *data)
 
 void
 pointerfocus(Client *c, struct wlr_surface *surface, double sx, double sy,
-		uint32_t time)
+	     uint32_t time)
 {
 	struct timespec now;
 	int internal_call = !time;
@@ -1804,8 +2002,9 @@ printstatus(void)
 
 		printf("%s selmon %u\n", m->wlr_output->name, m == selmon);
 		printf("%s tags %u %u %u %u\n", m->wlr_output->name, occ, m->tagset[m->seltags],
-				sel, urg);
+		       sel, urg);
 		printf("%s layout %s\n", m->wlr_output->name, m->lt[m->sellt]->symbol);
+		dscm_printstatus(m);
 	}
 	fflush(stdout);
 }
@@ -1834,7 +2033,7 @@ rendermon(struct wl_listener *listener, void *data)
 	/* Render if no XDG clients have an outstanding resize and are visible on
 	 * this monitor. */
 	wl_list_for_each(c, &clients, link)
-		if (c->resize && !c->isfloating && client_is_rendered_on_mon(c, m) && !client_is_stopped(c))
+		if (c->resize && !c->isfloating && client_is_rendered_on_mon(c, m))
 			goto skip;
 	if (!wlr_scene_output_commit(m->scene_output))
 		return;
@@ -1850,18 +2049,19 @@ requeststartdrag(struct wl_listener *listener, void *data)
 	struct wlr_seat_request_start_drag_event *event = data;
 
 	if (wlr_seat_validate_pointer_grab_serial(seat, event->origin,
-			event->serial))
+						  event->serial))
 		wlr_seat_start_pointer_drag(seat, event->drag, event->serial);
 	else
 		wlr_data_source_destroy(event->drag->source);
 }
 
 void
-resize(Client *c, struct wlr_box geo, int interact)
+resize(Client *c, struct wlr_box geo, int interact, int draw_borders)
 {
 	struct wlr_box *bbox = interact ? &sgeom : &c->mon->w;
 	client_set_bounds(c, geo.width, geo.height);
 	c->geom = geo;
+	c->bw = (1 - !draw_borders) * borderpx;
 	applybounds(c, bbox);
 
 	/* Update scene-graph, including borders */
@@ -1877,17 +2077,23 @@ resize(Client *c, struct wlr_box geo, int interact)
 
 	/* this is a no-op if size hasn't changed */
 	c->resize = client_set_size(c, c->geom.width - 2 * c->bw,
-			c->geom.height - 2 * c->bw);
+				    c->geom.height - 2 * c->bw);
 }
 
 void
 run(char *startup_cmd)
 {
 	/* Add a Unix socket to the Wayland display. */
+#ifdef DEVELOP
+	if ((wl_display_add_socket(dpy, WAYLAND_SOCKET_PATH)) == -1)
+		die("startup: display_add_socket");
+	setenv("WAYLAND_DISPLAY", WAYLAND_SOCKET_PATH, 1);
+#else
 	const char *socket = wl_display_add_socket_auto(dpy);
 	if (!socket)
 		die("startup: display_add_socket_auto");
 	setenv("WAYLAND_DISPLAY", socket, 1);
+#endif
 
 	/* Start the backend. This will enumerate outputs and inputs, become the DRM
 	 * master, etc */
@@ -1916,6 +2122,9 @@ run(char *startup_cmd)
 	signal(SIGPIPE, SIG_IGN);
 	printstatus();
 
+	/* Run startup hooks in new thread to prevent blocking of dwl startup */
+	dscm_hooks_run_async(hook_startup);
+
 	/* At this point the outputs are initialized, choose initial selmon based on
 	 * cursor position, and set default cursor image */
 	selmon = xytomon(cursor->x, cursor->y);
@@ -1952,7 +2161,67 @@ setcursor(struct wl_listener *listener, void *data)
 	 * do so as the cursor moves between outputs. */
 	if (event->seat_client == seat->pointer_state.focused_client)
 		wlr_cursor_set_surface(cursor, event->surface,
-				event->hotspot_x, event->hotspot_y);
+				       event->hotspot_x, event->hotspot_y);
+}
+
+void
+setgaps(int oh, int ov, int ih, int iv)
+{
+	if (oh < 0) oh = 0;
+	if (ov < 0) ov = 0;
+	if (ih < 0) ih = 0;
+	if (iv < 0) iv = 0;
+
+	Monitor *m;
+	wl_list_for_each(m, &mons, link) {
+		m->gappoh = oh;
+		m->gappov = ov;
+		m->gappih = ih;
+		m->gappiv = iv;
+		arrange(selmon);
+	}
+}
+
+void
+togglegaps(const Arg *arg)
+{
+	enablegaps = !enablegaps;
+	Monitor *m;
+	wl_list_for_each(m, &mons, link)
+		arrange(m);
+}
+
+void
+defaultgaps(const Arg *arg)
+{
+	setgaps(gappoh, gappov, gappih, gappiv);
+}
+
+void
+incrgaps(const Arg *arg)
+{
+	setgaps(selmon->gappoh + arg->i,
+		selmon->gappov + arg->i,
+		selmon->gappih + arg->i,
+		selmon->gappiv + arg->i);
+}
+
+void
+incrigaps(const Arg *arg)
+{
+	setgaps(selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih + arg->i,
+		selmon->gappiv + arg->i);
+}
+
+void
+incrogaps(const Arg *arg)
+{
+	setgaps(selmon->gappoh + arg->i,
+		selmon->gappov + arg->i,
+		selmon->gappih,
+		selmon->gappiv);
 }
 
 void
@@ -1973,15 +2242,15 @@ setfullscreen(Client *c, int fullscreen)
 	c->bw = fullscreen ? 0 : borderpx;
 	client_set_fullscreen(c, fullscreen);
 	wlr_scene_node_reparent(&c->scene->node, layers[fullscreen
-			? LyrFS : c->isfloating ? LyrFloat : LyrTile]);
+							? LyrFS : c->isfloating ? LyrFloat : LyrTile]);
 
 	if (fullscreen) {
 		c->prev = c->geom;
-		resize(c, c->mon->m, 0);
+		resize(c, c->mon->m, 0, c->bw);
 	} else {
 		/* restore previous size instead of arrange for floating windows since
 		 * client positions are set by the user and cannot be recalculated */
-		resize(c, c->prev, 0);
+		resize(c, c->prev, 0, c->bw);
 	}
 	arrange(c->mon);
 	printstatus();
@@ -1996,6 +2265,15 @@ setlayout(const Arg *arg)
 		selmon->sellt ^= 1;
 	if (arg && arg->v)
 		selmon->lt[selmon->sellt] = (Layout *)arg->v;
+	if (!selmon->lt[selmon->sellt]->arrange) {
+		/* floating layout, draw borders around all clients */
+		Client *c;
+		wl_list_for_each(c, &clients, link) {
+			if (c->bw)
+				continue;
+			resize(c, c->geom, 0, 1);
+		}
+	}
 	/* TODO change layout symbol? */
 	arrange(selmon);
 	printstatus();
@@ -2033,7 +2311,7 @@ setmon(Client *c, Monitor *m, unsigned int newtags)
 	}
 	if (m) {
 		/* Make sure window actually overlaps with the monitor */
-		resize(c, c->geom, 0);
+		resize(c, c->geom, 0, 1);
 		wlr_surface_send_enter(client_surface(c), m->wlr_output);
 		c->tags = newtags ? newtags : m->tagset[m->seltags]; /* assign tags of target monitor */
 		setfullscreen(c, c->isfullscreen); /* This will call arrange(c->mon) */
@@ -2064,7 +2342,7 @@ setsel(struct wl_listener *listener, void *data)
 }
 
 void
-setup(void)
+setup()
 {
 	/* The Wayland display is managed by libwayland. It handles accepting
 	 * clients from the Unix socket, manging Wayland globals, and so on. */
@@ -2092,6 +2370,7 @@ setup(void)
 
 	/* Initialize the scene graph used to lay out windows */
 	scene = wlr_scene_create();
+	root = wlr_scene_rect_create(&scene->tree, 0, 0, rootcolor);
 	layers[LyrBg] = wlr_scene_tree_create(&scene->tree);
 	layers[LyrBottom] = wlr_scene_tree_create(&scene->tree);
 	layers[LyrTile] = wlr_scene_tree_create(&scene->tree);
@@ -2132,6 +2411,10 @@ setup(void)
 	activation = wlr_xdg_activation_v1_create(dpy);
 	wl_signal_add(&activation->events.request_activate, &request_activate);
 
+	/* Initializes the interface used to implement urgency hints */
+	activation = wlr_xdg_activation_v1_create(dpy);
+	wl_signal_add(&activation->events.request_activate, &request_activate);
+
 	/* Creates an output layout, which a wlroots utility for working with an
 	 * arrangement of screens in a physical layout. */
 	output_layout = wlr_output_layout_create();
@@ -2151,6 +2434,8 @@ setup(void)
 	 */
 	wl_list_init(&clients);
 	wl_list_init(&fstack);
+	wl_list_init(&pointers);
+	wl_list_init(&dscm_clients);
 
 	idle = wlr_idle_create(dpy);
 	idle_notifier = wlr_idle_notifier_v1_create(dpy);
@@ -2158,6 +2443,9 @@ setup(void)
 	idle_inhibit_mgr = wlr_idle_inhibit_v1_create(dpy);
 	wl_signal_add(&idle_inhibit_mgr->events.new_inhibitor, &idle_inhibitor_create);
 
+	idle_inhibit_mgr = wlr_idle_inhibit_v1_create(dpy);
+	wl_signal_add(&idle_inhibit_mgr->events.new_inhibitor, &idle_inhibitor_create);
+
 	layer_shell = wlr_layer_shell_v1_create(dpy);
 	wl_signal_add(&layer_shell->events.new_surface, &new_layer_shell_surface);
 
@@ -2169,13 +2457,13 @@ setup(void)
 	wl_signal_add(&session_lock_mgr->events.new_lock, &session_lock_create_lock);
 	wl_signal_add(&session_lock_mgr->events.destroy, &session_lock_mgr_destroy);
 	locked_bg = wlr_scene_rect_create(layers[LyrBlock], sgeom.width, sgeom.height,
-			(float [4]){0.1, 0.1, 0.1, 1.0});
+					  lockscreen_bg);
 	wlr_scene_node_set_enabled(&locked_bg->node, 0);
 
 	/* Use decoration protocols to negotiate server-side decorations */
 	wlr_server_decoration_manager_set_default_mode(
-			wlr_server_decoration_manager_create(dpy),
-			WLR_SERVER_DECORATION_MANAGER_MODE_SERVER);
+		wlr_server_decoration_manager_create(dpy),
+		WLR_SERVER_DECORATION_MANAGER_MODE_SERVER);
 	xdg_decoration_mgr = wlr_xdg_decoration_manager_v1_create(dpy);
 	wl_signal_add(&xdg_decoration_mgr->events.new_toplevel_decoration, &new_xdg_decoration);
 
@@ -2220,7 +2508,7 @@ setup(void)
 	wl_signal_add(&backend->events.new_input, &new_input);
 	virtual_keyboard_mgr = wlr_virtual_keyboard_manager_v1_create(dpy);
 	wl_signal_add(&virtual_keyboard_mgr->events.new_virtual_keyboard,
-			&new_virtual_keyboard);
+		      &new_virtual_keyboard);
 	seat = wlr_seat_create(dpy, "seat0");
 	wl_signal_add(&seat->events.request_set_cursor, &request_cursor);
 	wl_signal_add(&seat->events.request_set_selection, &request_set_sel);
@@ -2233,7 +2521,7 @@ setup(void)
 	wl_signal_add(&output_mgr->events.test, &output_mgr_test);
 
 	wlr_scene_set_presentation(scene, wlr_presentation_create(dpy, backend));
-
+	wl_global_create(dpy, &dscm_v1_interface, 1, NULL, dscm_bind);
 #ifdef XWAYLAND
 	/*
 	 * Initialise the XWayland X server.
@@ -2298,7 +2586,8 @@ tagmon(const Arg *arg)
 void
 tile(Monitor *m)
 {
-	unsigned int i, n = 0, mw, my, ty;
+	unsigned int i, n = 0, h, r, oe = enablegaps, ie = enablegaps, mw, my, ty,
+		enableborders = 1;
 	Client *c;
 
 	wl_list_for_each(c, &clients, link)
@@ -2307,22 +2596,32 @@ tile(Monitor *m)
 	if (n == 0)
 		return;
 
+	if (smartgaps == n)
+		oe = 0; // outer gaps disabled
+	if (smartborders == n && oe == 0)
+		enableborders = 0;
+
 	if (n > m->nmaster)
-		mw = m->nmaster ? m->w.width * m->mfact : 0;
+		mw = m->nmaster ? (m->w.width + m->gappih*ie) * m->mfact : 0;
 	else
-		mw = m->w.width;
-	i = my = ty = 0;
+		mw = m->w.width - 2*m->gappoh*oe + m->gappih*ie;
+	i = 0;
+	my = ty = m->gappov*oe;
 	wl_list_for_each(c, &clients, link) {
 		if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
 			continue;
 		if (i < m->nmaster) {
-			resize(c, (struct wlr_box){.x = m->w.x, .y = m->w.y + my, .width = mw,
-				.height = (m->w.height - my) / (MIN(n, m->nmaster) - i)}, 0);
-			my += c->geom.height;
+			r = MIN(n, m->nmaster) - i;
+			h = (m->w.height - my - m->gappov*oe - m->gappiv*ie * (r - 1)) / r;
+			resize(c, (struct wlr_box){.x = m->w.x + m->gappoh*oe, .y = m->w.y + my, .width = mw - m->gappih*ie,
+					.height = h}, 0, enableborders);
+			my += c->geom.height + m->gappiv*ie;
 		} else {
-			resize(c, (struct wlr_box){.x = m->w.x + mw, .y = m->w.y + ty,
-				.width = m->w.width - mw, .height = (m->w.height - ty) / (n - i)}, 0);
-			ty += c->geom.height;
+			r = n - i;
+			h = (m->w.height - ty - m->gappov*oe - m->gappiv*ie * (r - 1)) / r;
+			resize(c, (struct wlr_box){.x = m->w.x + mw + m->gappoh*oe, .y = m->w.y + ty,
+					.width = m->w.width - mw - 2*m->gappoh*oe, .height = h}, 0, enableborders);
+			ty += c->geom.height + m->gappiv*ie;
 		}
 		i++;
 	}
@@ -2391,10 +2690,10 @@ unmaplayersurfacenotify(struct wl_listener *listener, void *data)
 	if (layersurface == exclusive_focus)
 		exclusive_focus = NULL;
 	if (layersurface->layer_surface->output
-			&& (layersurface->mon = layersurface->layer_surface->output->data))
+	    && (layersurface->mon = layersurface->layer_surface->output->data))
 		arrangelayers(layersurface->mon);
 	if (layersurface->layer_surface->surface ==
-			seat->keyboard_state.focused_surface)
+	    seat->keyboard_state.focused_surface)
 		focusclient(focustop(selmon), 1);
 	motionnotify(0);
 }
@@ -2457,14 +2756,14 @@ updatemons(struct wl_listener *listener, void *data)
 	/* Insert outputs that need to */
 	wl_list_for_each(m, &mons, link)
 		if (m->wlr_output->enabled
-				&& !wlr_output_layout_get(output_layout, m->wlr_output))
+		    && !wlr_output_layout_get(output_layout, m->wlr_output))
 			wlr_output_layout_add_auto(output_layout, m->wlr_output);
 
 	/* Now that we update the output layout we can get its box */
 	wlr_output_layout_get_box(output_layout, NULL, &sgeom);
+	wlr_scene_rect_set_size(root, sgeom.width, sgeom.height);
 
 	/* Make sure the clients are hidden when dwl is locked */
-	wlr_scene_node_set_position(&locked_bg->node, sgeom.x, sgeom.y);
 	wlr_scene_rect_set_size(locked_bg, sgeom.width, sgeom.height);
 
 	wl_list_for_each(m, &mons, link) {
@@ -2533,8 +2832,10 @@ urgent(struct wl_listener *listener, void *data)
 void
 view(const Arg *arg)
 {
-	if (!selmon || (arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
+	unsigned int currtagset = selmon->tagset[selmon->seltags];
+	if (!selmon || (arg->ui & TAGMASK) == currtagset)
 		return;
+	selmon->prevtagset = currtagset;
 	selmon->seltags ^= 1; /* toggle sel tagset */
 	if (arg->ui & TAGMASK)
 		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
@@ -2543,6 +2844,31 @@ view(const Arg *arg)
 	printstatus();
 }
 
+void
+viewprev(const Arg *arg)
+{
+	unsigned int tagset = selmon->tagset[selmon->seltags];
+	selmon->tagset[selmon->seltags] = selmon->prevtagset;
+	selmon->prevtagset = tagset;
+	focusclient(focustop(selmon), 1);
+	arrange(selmon);
+	printstatus();
+}
+
+void
+writepid(const char *runtimedir)
+{
+	/* Writes a pid file so that services managers like Shepherd
+	 * can provision dwl-guile correcly to other services that
+	 * depend on an existing wayland display. */
+	char buf[128];
+	FILE *pidfile;
+	snprintf(buf, 128, "%s/dwl-guile.pid", runtimedir);
+	pidfile = fopen(buf, "w");
+	fprintf(pidfile, "%d", getpid());
+	fclose(pidfile);
+}
+
 void
 virtualkeyboard(struct wl_listener *listener, void *data)
 {
@@ -2559,7 +2885,7 @@ xytomon(double x, double y)
 
 struct wlr_scene_node *
 xytonode(double x, double y, struct wlr_surface **psurface,
-		Client **pc, LayerSurface **pl, double *nx, double *ny)
+	 Client **pc, LayerSurface **pl, double *nx, double *ny)
 {
 	struct wlr_scene_node *node, *pnode;
 	struct wlr_surface *surface = NULL;
@@ -2572,7 +2898,7 @@ xytonode(double x, double y, struct wlr_surface **psurface,
 		if ((node = wlr_scene_node_at(&layers[*layer]->node, x, y, nx, ny))) {
 			if (node->type == WLR_SCENE_NODE_BUFFER)
 				surface = wlr_scene_surface_from_buffer(
-						wlr_scene_buffer_from_node(node))->surface;
+					wlr_scene_buffer_from_node(node))->surface;
 			/* Walk the tree to find a node that knows the client */
 			for (pnode = node; pnode && !c; pnode = &pnode->parent->node)
 				c = pnode->data;
@@ -2643,7 +2969,7 @@ configurex11(struct wl_listener *listener, void *data)
 		return;
 	if (c->isfloating || c->type == X11Unmanaged)
 		resize(c, (struct wlr_box){.x = event->x, .y = event->y,
-				.width = event->width, .height = event->height}, 0);
+				.width = event->width, .height = event->height}, 0, 1);
 	else
 		arrange(c->mon);
 }
@@ -2659,6 +2985,7 @@ createnotifyx11(struct wl_listener *listener, void *data)
 	c->surface.xwayland = xsurface;
 	c->type = xsurface->override_redirect ? X11Unmanaged : X11Managed;
 	c->bw = borderpx;
+	c->alpha = default_alpha;
 
 	/* Listen to the various events it can emit */
 	LISTEN(&xsurface->events.map, &c->map, mapnotify);
@@ -2709,7 +3036,7 @@ sigchld(int unused)
 	 * XWayland process
 	 */
 	while (!waitid(P_ALL, 0, &in, WEXITED|WNOHANG|WNOWAIT) && in.si_pid
-			&& (!xwayland || in.si_pid != xwayland->server->pid))
+	       && (!xwayland || in.si_pid != xwayland->server->pid))
 		waitpid(in.si_pid, NULL, 0);
 }
 
@@ -2720,7 +3047,8 @@ xwaylandready(struct wl_listener *listener, void *data)
 	xcb_connection_t *xc = xcb_connect(xwayland->display_name, NULL);
 	int err = xcb_connection_has_error(xc);
 	if (err) {
-		fprintf(stderr, "xcb_connect to X server failed with code %d\n. Continuing with degraded functionality.\n", err);
+		fprintf(stderr, "xcb_connect to X server failed with code %d\n. \
+			Continuing with degraded functionality.\n", err);
 		return;
 	}
 
@@ -2737,39 +3065,279 @@ xwaylandready(struct wl_listener *listener, void *data)
 	/* Set the default XWayland cursor to match the rest of dwl. */
 	if ((xcursor = wlr_xcursor_manager_get_xcursor(cursor_mgr, "left_ptr", 1)))
 		wlr_xwayland_set_cursor(xwayland,
-				xcursor->images[0]->buffer, xcursor->images[0]->width * 4,
-				xcursor->images[0]->width, xcursor->images[0]->height,
-				xcursor->images[0]->hotspot_x, xcursor->images[0]->hotspot_y);
+					xcursor->images[0]->buffer,
+					xcursor->images[0]->width * 4,
+					xcursor->images[0]->width,
+					xcursor->images[0]->height,
+					xcursor->images[0]->hotspot_x,
+					xcursor->images[0]->hotspot_y);
 
 	xcb_disconnect(xc);
 }
 #endif
 
+void
+dscm_sendevents(void)
+{
+	Layout *l;
+	DscmClient *c;
+	wl_list_for_each(c, &dscm_clients, link) {
+	    for (int i = 0; i < numtags; i++)
+		    dscm_v1_send_tag(c->resource, tags[i]);
+	    wl_list_for_each(l, &layouts, link)
+		    dscm_v1_send_layout(c->resource, l->symbol);
+	}
+}
+
+void
+dscm_closemon(struct wl_client *client, struct wl_resource *resource)
+{
+	wl_resource_destroy(resource);
+}
+
+void
+dscm_destroymon(struct wl_resource *resource) {
+	DscmMonitor *mon = wl_resource_get_user_data(resource);
+	if (mon) {
+		wl_list_remove(&mon->link);
+		free(mon);
+	}
+}
+
+void
+dscm_printstatusmon(Monitor *m, const DscmMonitor *mon)
+{
+	Client *c, *focused;
+	int tagmask, state, numclients, focusedclient;
+	focused = focustop(m);
+	dscm_monitor_v1_send_selected(mon->resource, m == selmon);
+
+	for (int tag = 0; tag < numtags; tag++) {
+		numclients = state = 0;
+		focusedclient = -1;
+		tagmask = 1 << tag;
+		if ((tagmask & m->tagset[m->seltags]) != 0)
+			state = state | DSCM_MONITOR_V1_TAG_STATE_ACTIVE;
+		wl_list_for_each(c, &clients, link) {
+			if (c->mon != m)
+				continue;
+			if (!(c->tags & tagmask))
+				continue;
+			if (c == focused)
+				focusedclient = numclients;
+			numclients++;
+			if (c->isurgent)
+				state = state | DSCM_MONITOR_V1_TAG_STATE_URGENT;
+		}
+		dscm_monitor_v1_send_tag(mon->resource, tag, state,
+					 numclients, focusedclient);
+	}
+
+	Layout *l;
+	unsigned int index = 0;
+	wl_list_for_each(l, &layouts, link)
+		if (l == m->lt[m->sellt])
+			break;
+		else
+			index++;
+
+	dscm_monitor_v1_send_layout(mon->resource, index);
+	dscm_monitor_v1_send_title(mon->resource, focused ?
+				   client_get_title(focused) : "");
+	dscm_monitor_v1_send_frame(mon->resource);
+}
+
+void
+dscm_printstatus(Monitor *m)
+{
+	DscmMonitor *mon;
+	wl_list_for_each(mon, &m->dscm, link)
+		dscm_printstatusmon(m, mon);
+}
+
+void dscm_settags(struct wl_client *client, struct wl_resource *resource,
+		  uint32_t t, uint32_t toggletagset)
+{
+	DscmMonitor *mon;
+	Monitor *m;
+	mon = wl_resource_get_user_data(resource);
+	if (!mon)
+		return;
+	m = mon->monitor;
+	if ((t & TAGMASK) == m->tagset[m->seltags])
+		return;
+	if (toggletagset)
+		m->seltags ^= 1;
+	if (t & TAGMASK)
+		m->tagset[m->seltags] = t & TAGMASK;
+
+	focusclient(focustop(m), 1);
+	arrange(m);
+	printstatus();
+}
+
+void
+dscm_setlayout(struct wl_client *client, struct wl_resource *resource,
+	       uint32_t layout)
+{
+	Layout *l;
+	Monitor *m;
+	DscmMonitor *mon;
+	uint32_t index = 0;
+	mon = wl_resource_get_user_data(resource);
+	if (!mon)
+		return;
+	m = mon->monitor;
+	wl_list_for_each(l, &layouts, link) {
+		if (index == layout) {
+			if (l != m->lt[m->sellt])
+				m->sellt ^= 1;
+
+			m->lt[m->sellt] = l;
+			arrange(m);
+			printstatus();
+			return;
+		}
+		index++;
+	}
+}
+
+void
+dscm_setclient(struct wl_client *client, struct wl_resource *resource,
+	       uint32_t and, uint32_t xor)
+{
+	DscmMonitor *mon;
+	Client *sel;
+	unsigned int newtags;
+	mon = wl_resource_get_user_data(resource);
+	if (!mon)
+		return;
+	sel = focustop(mon->monitor);
+	if (!sel)
+		return;
+	newtags = (sel->tags & and) ^ xor;
+	if (newtags) {
+		sel->tags = newtags;
+		focusclient(focustop(selmon), 1);
+		arrange(selmon);
+		printstatus();
+	}
+}
+
+void
+dscm_release(struct wl_client *client, struct wl_resource *resource)
+{
+	wl_resource_destroy(resource);
+}
+
+void
+dscm_getmon(struct wl_client *client, struct wl_resource *resource,
+	    uint32_t id, struct wl_resource *output)
+{
+	DscmMonitor *mon;
+	struct wlr_output *wlr_output = wlr_output_from_resource(output);
+	struct Monitor *m = wlr_output->data;
+	struct wl_resource *dscm_monitor_resource = wl_resource_create(
+		client,
+		&dscm_monitor_v1_interface, wl_resource_get_version(resource), id);
+	if (!resource) {
+		wl_client_post_no_memory(client);
+		return;
+	}
+	mon = calloc(1, sizeof(DscmMonitor));
+	mon->resource = dscm_monitor_resource;
+	mon->monitor = m;
+	wl_resource_set_implementation(dscm_monitor_resource,
+				       &dscm_monitor_implementation,
+				       mon, dscm_destroymon);
+	wl_list_insert(&m->dscm, &mon->link);
+	dscm_printstatusmon(m, mon);
+}
+
+void
+dscm_eval_callback(struct wl_resource *resource, char *result, uint32_t status)
+{
+	dscm_v1_send_eval_result(resource, result, status);
+}
+
+void
+dscm_eval(struct wl_client *client, struct wl_resource *resource, const char *exp)
+{
+	size_t len = strlen(exp);
+	/* Free'd automatically once the call handler has executed. */
+	char* expcpy = ecalloc(len + 1, sizeof(char));
+	/* len + 1 to automatically pad with NULL */
+	strncpy(expcpy, exp, len + 1);
+	DscmClient *c = wl_resource_get_user_data(resource);
+	dscm_thread_eval(c->resource, &dscm_eval_callback, (void*)expcpy);
+}
+
+void
+dscm_destroy(struct wl_resource *resource)
+{
+	DscmClient *c = wl_resource_get_user_data(resource);
+	if (c) {
+		wl_list_remove(&c->link);
+		free(c);
+	}
+}
+
+void
+dscm_bind(struct wl_client *client, void *data, uint32_t version, uint32_t id)
+{
+	DscmClient *c;
+	struct wl_resource *resource = wl_resource_create(
+		client,
+		&dscm_v1_interface, version, id);
+	if (!resource) {
+		wl_client_post_no_memory(client);
+		return;
+	}
+
+	c = calloc(1, sizeof(DscmClient));
+	c->resource = resource;
+	wl_resource_set_implementation(resource, &dscm_implementation, c, dscm_destroy);
+	wl_list_insert(&dscm_clients, &c->link);
+	dscm_sendevents();
+}
+
 int
 main(int argc, char *argv[])
 {
-	char *startup_cmd = NULL;
 	int c;
+	char *startup_cmd = NULL, *runtimedir = NULL, *exp = NULL;
 
-	while ((c = getopt(argc, argv, "s:hv")) != -1) {
+	while ((c = getopt(argc, argv, "s:c:e:hv")) != -1) {
 		if (c == 's')
 			startup_cmd = optarg;
+		else if (c == 'c')
+			config_file = optarg;
+		else if (c == 'e')
+			return dscm_ipc_evaluate(optarg);
 		else if (c == 'v')
-			die("dwl " VERSION);
+			die("dwl v2.0.2");
 		else
 			goto usage;
 	}
-	if (optind < argc)
-		goto usage;
 
-	/* Wayland requires XDG_RUNTIME_DIR for creating its communications socket */
-	if (!getenv("XDG_RUNTIME_DIR"))
+	// Wayland requires XDG_RUNTIME_DIR for creating its communications
+	// socket
+	if (!(runtimedir = getenv("XDG_RUNTIME_DIR")))
 		die("XDG_RUNTIME_DIR must be set");
+	if (!config_file)
+		die("error: config path must be set using '-c'");
+	scm_init_guile();
+	dscm_register();
+	dscm_hooks_initialize();
+	dscm_config_initialize();
+	dscm_config_load();
 	setup();
+	writepid(runtimedir);
 	run(startup_cmd);
+	dscm_hooks_run(hook_quit);
+	dscm_config_cleanup();
 	cleanup();
 	return EXIT_SUCCESS;
-
 usage:
-	die("Usage: %s [-v] [-s startup command]", argv[0]);
+	die("Usage: %s [-c path to config.scm] [-s startup command] [-e expression to evaluate]", argv[0]);
 }
diff --git a/guix.scm b/guix.scm
new file mode 100644
index 0000000..6835cb6
--- /dev/null
+++ b/guix.scm
@@ -0,0 +1,150 @@
+(use-modules (guix gexp)
+             (guix utils)
+             (guix packages)
+             (guix download)
+             (guix git-download)
+             (gnu packages wm)
+             (gnu packages gl)
+             (gnu packages xorg)
+             (gnu packages admin)
+             (gnu packages linux)
+             (gnu packages guile)
+             (gnu packages libffi)
+             (gnu packages libbsd)
+             (gnu packages xdisorg)
+             (gnu packages pciutils)
+             (gnu packages freedesktop))
+
+(define this-directory
+  (dirname (current-filename)))
+
+(define source
+  (local-file this-directory
+              #:recursive? #t
+              #:select? (git-predicate this-directory)))
+
+(define libdrm-2.4.113
+  (package
+   (inherit libdrm)
+   (name "libdrm")
+   (version "2.4.113")
+   (source (origin
+            (method url-fetch)
+            (uri (string-append
+                  "https://dri.freedesktop.org/libdrm/libdrm-"
+                  version ".tar.xz"))
+            (sha256
+             (base32
+              "1qg54drng3mxm64dsxgg0l6li4yrfzi50bgj0r3fnfzncwlypmvz"))))))
+
+(define wayland-1.21.0
+  (package
+   (inherit wayland)
+   (name "wayland")
+   (version "1.21.0")
+   (source (origin
+            (method url-fetch)
+            (uri (string-append "https://gitlab.freedesktop.org/wayland/wayland/-/releases/"
+                                version "/downloads/" name "-" version ".tar.xz"))
+            (sha256
+             (base32
+              "1b0ixya9bfw5c9jx8mzlr7yqnlyvd3jv5z8wln9scdv8q5zlvikd"))))
+   (propagated-inputs
+    (list libffi))))
+
+(define wayland-protocols-1.27
+  (package
+   (inherit wayland-protocols)
+   (name "wayland-protocols")
+   (version "1.27")
+   (source (origin
+            (method url-fetch)
+            (uri (string-append
+                  "https://gitlab.freedesktop.org/wayland/wayland-protocols/-/releases/"
+                  version "/downloads/" name "-" version ".tar.xz"))
+            (sha256
+             (base32
+              "0p1pafbcc8b8p3175b03cnjpbd9zdgxsq0ssjq02lkjx885g2ilh"))))
+   (inputs
+    (modify-inputs (package-inputs wayland-protocols)
+                   (replace "wayland" wayland-1.21.0)))))
+
+(define xorg-server-xwayland-22.1.5
+  (package
+   (inherit xorg-server-xwayland)
+   (name "xorg-server-xwayland")
+   (version "22.1.5")
+   (source
+    (origin
+     (method url-fetch)
+     (uri (string-append "https://xorg.freedesktop.org/archive/individual"
+                         "/xserver/xwayland-" version ".tar.xz"))
+     (sha256
+      (base32
+       "0whnmi2v1wvaw8y7d32sb2avsjhyj0h18xi195jj30wz24gsq5z3"))))
+   (inputs
+    (modify-inputs (package-inputs xorg-server-xwayland)
+                   (prepend libbsd libxcvt)
+                   (replace "wayland" wayland-1.21.0)
+                   (replace "wayland-protocols" wayland-protocols-1.27)))))
+
+(define wlroots-0.16.0
+  (package
+   (inherit wlroots)
+   (name "wlroots")
+   (version "0.16.0")
+   (source
+    (origin
+     (method git-fetch)
+     (uri (git-reference
+           (url "https://gitlab.freedesktop.org/wlroots/wlroots")
+           (commit version)))
+     (file-name (git-file-name name version))
+     (sha256
+      (base32 "18rfr3wfm61dv9w8m4xjz4gzq2v3k5vx35ymbi1cggkgbk3lbc4k"))))
+   (inputs
+    (modify-inputs (package-inputs wlroots)
+                   (prepend `(,hwdata "pnp"))))
+   (propagated-inputs
+    (modify-inputs (package-propagated-inputs wlroots)
+                   (prepend libdrm-2.4.113)
+                   (replace "wayland" wayland-1.21.0)
+                   (replace "wayland-protocols" wayland-protocols-1.27)
+                   (replace "xorg-server-xwayland" xorg-server-xwayland-22.1.5)))
+   (arguments
+    (substitute-keyword-arguments
+     (package-arguments wlroots)
+     ((#:phases phases)
+      #~(modify-phases
+         #$phases
+         (add-after 'unpack 'patch-hwdata-path
+                    (lambda* (#:key inputs #:allow-other-keys)
+                      (substitute* "backend/drm/meson.build"
+                                   (("/usr/share/hwdata/pnp.ids")
+                                    (search-input-file inputs "share/hwdata/pnp.ids")))))))))))
+
+(package
+  (inherit dwl)
+  (source source)
+  (name "dwl-guile-devel")
+  (version "2.0.2")
+  (inputs
+   (modify-inputs (package-inputs dwl)
+                  (prepend guile-3.0
+                           wayland-1.21.0)
+                  (replace "wlroots" wlroots-0.16.0)))
+  (arguments
+    (substitute-keyword-arguments
+      (package-arguments dwl)
+      ((#:phases phases)
+       `(modify-phases
+          ,phases
+            (add-after 'install 'rename-dwl-guile-to-dwl-guile-devel
+              (lambda* (#:key inputs outputs #:allow-other-keys)
+                (let ((bin (string-append (assoc-ref outputs "out") "/bin")))
+                  (rename-file (string-append bin "/dwl-guile")
+                               (string-append bin "/dwl-guile-devel"))
+                  #t)))))
+      ;; Enable development mode.
+      ((#:make-flags make-flags ''())
+       #~(cons "DEBUGFLAGS=-DDEVELOP" #$make-flags)))))
diff --git a/protocols/dscm-unstable-v1.xml b/protocols/dscm-unstable-v1.xml
new file mode 100644
index 0000000..b5a7cc7
--- /dev/null
+++ b/protocols/dscm-unstable-v1.xml
@@ -0,0 +1,190 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="dscm_unstable_v1">
+    <copyright>
+        Copyright (c) 2021 Raphael Robatsch
+        Copyright (c) 2022 Fredrik Engstrand
+
+        Permission is hereby granted, free of charge, to any person obtaining a
+        copy of this software and associated documentation files (the
+        "Software"), to deal in the Software without restriction, including
+        without limitation the rights to use, copy, modify, merge, publish,
+        distribute, sublicense, and/or sell copies of the Software, and to
+        permit persons to whom the Software is furnished to do so, subject to
+        the following conditions:
+
+        The above copyright notice and this permission notice (including the
+        next paragraph) shall be included in all copies or substantial portions
+        of the Software.
+
+        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+    </copyright>
+
+    <interface name="dscm_v1" version="1">
+        <description summary="control the dwl state">
+            This interface is exposed as a global in the wl_registry.
+
+            Clients can use this protocol to receive updates of the window manager
+            state (active tags, active layout, and focused window).
+            Clients can also control this state.
+
+            After binding, the client will receive the available tags and layouts
+            with the 'tag' and 'layout' events. These can be used in subsequent
+            dscm_monitor_v1.set_tags/set_layout requests, and to interpret the
+            dscm_monitor_v1.layout/tag events.
+        </description>
+
+        <enum name="eval_status">
+            <entry name="success" value="0" summary="evaluation succeeded"/>
+            <entry name="error" value="1" summary="evauluation failed"/>
+        </enum>
+
+        <request name="release" type="destructor">
+            <description summary="release dscm">
+                This request indicates that the client will not use the dscm
+                object any more. Objects that have been created through this instance
+                are not affected.
+            </description>
+        </request>
+
+        <request name="get_monitor">
+            <description summary="gets a dwl monitor from an output">
+                Gets a dscm monitor for the specified output. The window manager
+                state on the output can be controlled using the monitor.
+            </description>
+            <arg name="id" type="new_id" interface="dscm_monitor_v1" />
+            <arg name="output" type="object" interface="wl_output" />
+        </request>
+
+        <request name="eval">
+            <description summary="evaluate scheme expression">
+                Evaluate custom Scheme/Guile expression(s) in the dwl-guile
+                context. All dwl-guile bindings will be available during
+                the evaluation, including configuration options.
+            </description>
+            <arg name="exp" type="string" summary="scheme expression to evaluate" />
+        </request>
+
+        <event name="eval_result">
+            <description summary="announces the result of a previous evaluation">
+                Sends out the result of a Guile expression evaluation in
+                the form of a string. The status argument tells you whether the
+                evaluation was successful or not. If an error occured, the error
+                message will be available in the result string.
+            </description>
+            <arg name="result" type="string"/>
+            <arg name="status" type="uint" enum="eval_status"/>
+        </event>
+
+        <event name="tag">
+            <description summary="announces the presence of a tag">
+                This event is sent immediately after binding.
+                A roundtrip after binding guarantees that the client has received all tags.
+            </description>
+            <arg name="name" type="string"/>
+        </event>
+
+        <event name="layout">
+            <description summary="announces the presence of a layout">
+                This event is sent immediately after binding.
+                A roundtrip after binding guarantees that the client has received all layouts.
+            </description>
+            <arg name="name" type="string"/>
+        </event>
+    </interface>
+
+    <interface name="dscm_monitor_v1" version="1">
+        <description summary="control one monitor">
+            Observes and controls one monitor.
+
+            Events are double-buffered: Clients should cache all events and only
+            redraw themselves once the 'frame' event is sent.
+
+            Requests are not double-buffered: The compositor will update itself
+            immediately.
+        </description>
+
+        <enum name="tag_state">
+            <entry name="none" value="0" summary="no state"/>
+            <entry name="active" value="1" summary="tag is active"/>
+            <entry name="urgent" value="2" summary="tag has at least one urgent client"/>
+        </enum>
+
+        <request name="release" type="destructor">
+            <description summary="release dscm_monitor">
+                This request indicates that the client is done with this dscm_monitor.
+                All further requests are ignored.
+            </description>
+        </request>
+
+        <event name="selected">
+            <description summary="updates the selected state of the monitor">
+                If 'selected' is nonzero, this monitor is the currently selected one.
+            </description>
+            <arg name="selected" type="uint"/>
+        </event>
+
+        <event name="tag">
+            <description summary="updates the state of one tag">
+                Announces the update of a tag. num_clients and focused_client can be
+                used to draw client indicators.
+            </description>
+            <arg name="tag" type="uint" summary="index of a tag received by the dscm_v1.tag event." />
+            <arg name="state" type="uint" enum="tag_state"/>
+            <arg name="num_clients" type="uint" summary="number of clients on this tag"/>
+            <arg name="focused_client" type="int" summary="out of num_clients. -1 if there is no focused client"/>
+        </event>
+
+        <event name="layout">
+            <description summary="updates the selected layout">
+                Announces the update of the selected layout.
+            </description>
+            <arg name="layout" type="uint" summary="index of a layout received by the dscm_v1.layout event."/>
+        </event>
+
+        <event name="title">
+            <description summary="updates the focused client">
+                Announces the update of the selected client.
+            </description>
+            <arg name="title" type="string"/>
+        </event>
+
+        <event name="frame">
+            <description summary="end of status update sequence">
+                Sent after all other events belonging to the status update has been sent.
+                Clients should redraw themselves now.
+            </description>
+        </event>
+
+        <request name="set_tags">
+            <description summary="sets the active tags on this monitor.">
+                Changes are applied immediately.
+            </description>
+            <arg name="tagmask" type="uint" summary="bitmask of the tags that should be set."/>
+            <arg name="toggle_tagset" type="uint"/>
+        </request>
+
+        <request name="set_client_tags">
+            <description summary="updates the tags of the focused client.">
+                tags are updated as follows:
+                new_tags = (current_tags AND and_tags) XOR xor_tags
+
+                Changes are applied immediately.
+            </description>
+            <arg name="and_tags" type="uint"/>
+            <arg name="xor_tags" type="uint"/>
+        </request>
+
+        <request name="set_layout">
+            <description summary="sets the active layout on this monitor.">
+                Changes are applied immediately.
+            </description>
+            <arg name="layout" type="uint" summary="index of a layout received by the dscm_v1.layout event."/>
+        </request>
+    </interface>
+</protocol>
diff --git a/scripts/create-patches.sh b/scripts/create-patches.sh
new file mode 100755
index 0000000..09660fe
--- /dev/null
+++ b/scripts/create-patches.sh
@@ -0,0 +1,26 @@
+#!/bin/sh
+# $1 = dwl-guile patch tag to diff patches to
+
+git fetch --all
+rm -rf patches
+mkdir -p patches
+
+# Make sure we always have a branch/tag to diff against,
+# otherwise, the patch output will be inverted.
+DIFF_ORIGIN=$1
+[ -z $DIFF_ORIGIN ] && DIFF_ORIGIN="main"
+
+for patch in xwayland attachabove \
+    monitor-config focusmonpointer swallow movestack
+do
+    git fetch origin patch/$patch
+    git diff $DIFF_ORIGIN patch/$patch \
+        ':(exclude)README.md' \
+        ':(exclude)README.org' \
+        ':(exclude)patches' \
+        ':(exclude)scripts/create-patches.sh' \
+        ':(exclude).gitignore' > patches/$patch.patch
+done
+
+# Create dwl-guile patch based on dwl v0.4
+git diff v0.4 > patches/dwl-guile.patch
diff --git a/share/defaults.scm b/share/defaults.scm
new file mode 100644
index 0000000..75fb88e
--- /dev/null
+++ b/share/defaults.scm
@@ -0,0 +1,34 @@
+;; Default bindings.
+;; This file will only be loaded if 'inhibit-defaults? is #f.
+
+(dwl:set-tty-keys "C-M")
+(dwl:set-tag-keys "s" "s-S")
+
+(set-keys "s-d" '(dwl:spawn "bemenu-run")
+          "s-<return>" '(dwl:spawn "foot")
+          "s-j" '(dwl:focus-stack 1)
+          "s-k" '(dwl:focus-stack -1)
+          "s-l" '(dwl:change-master-factor 0.05)
+          "s-h" '(dwl:change-master-factor -0.05)
+          "s-<page-up>" '(dwl:change-masters 1)
+          "s-<page-down>" '(dwl:change-masters -1)
+          "s-t" '(dwl:cycle-layout 1)
+          "s-<left>" '(dwl:focus-monitor 'DIRECTION-LEFT)
+          "s-<right>" '(dwl:focus-monitor 'DIRECTION-RIGHT)
+          "s-<up>" '(dwl:focus-monitor 'DIRECTION-UP)
+          "s-<down>" '(dwl:focus-monitor 'DIRECTION-DOWN)
+          "s-S-<left>" '(dwl:tag-monitor 'DIRECTION-LEFT)
+          "s-S-<right>" '(dwl:tag-monitor 'DIRECTION-RIGHT)
+          "s-S-<up>" '(dwl:tag-monitor 'DIRECTION-UP)
+          "s-S-<down>" '(dwl:tag-monitor 'DIRECTION-DOWN)
+          "s-q" 'dwl:kill-client
+          "s-<space>" 'dwl:zoom
+          "s-<tab>" 'dwl:view
+          "s-S-0" '(dwl:view 0) ;; 0 will show all tags
+          "s-f" 'dwl:toggle-fullscreen
+          "S-s-<space>" 'dwl:toggle-floating
+          "S-s-<escape>" 'dwl:quit
+          "<XF86PowerOff>" 'dwl:quit
+          "s-<mouse-left>" 'dwl:move
+          "s-<mouse-middle>" 'dwl:toggle-floating
+          "s-<mouse-right>" 'dwl:resize)
diff --git a/share/init.scm b/share/init.scm
new file mode 100644
index 0000000..feb4aac
--- /dev/null
+++ b/share/init.scm
@@ -0,0 +1,143 @@
+;; Sets a list of options and their corresponding values,
+;; automatically quoting each option, transforming it into a symbol.
+;; In other words, this can be used just like @code{set}, but without
+;; needing to quote each option manually.
+
+;; @example
+;; (setq border-px 10
+;;       border-color \"#00FF00\")
+;; @end example
+(define-syntax setq-args
+  (syntax-rules ()
+    ((setq-args)
+     (syntax-error "Missing arguments to setq"))
+    ((setq-args option)
+     (syntax-error "Missing value to option in setq"))
+    ((setq-args option exp)
+     `(option ,exp))
+    ((setq-args option exp rest ...)
+     (append `(option ,exp) (setq-args rest ...)))))
+
+(define-syntax setq
+  (syntax-rules ()
+    ((setq)
+     (syntax-error "Missing arguments to setq"))
+    ((setq option)
+     (syntax-error "Missing value to option in setq"))
+    ((setq rest ...)
+     (apply set (setq-args rest ...)))))
+
+(define* (dwl:run-async fn #:optional (callback #f))
+  "Evalutes FN asynchronously, without blocking the main thread.
+CALLBACK will be executed once FN has finished its execution, being
+passed the potential return value from FN. If no callback is provided,
+the return value will be ignored.
+
+For thread safety, FN should not make use of dwl-guile bindings, although
+some bindings can be used without issue, such as @code{dwl:spawn}. Instead,
+try to move dwl-guile calls to the callback."
+  ((@ (ice-9 futures) make-future)
+   (lambda ()
+     ;; This is a really hacky (but easy) solution for ensuring thread safety
+     ;; while still allowing for dwl-guile bindings to be called asynchronously.
+     ;; Essentially, we are executing a shell command from the Guile context
+     ;; in order to send a command to the main thread Guile context, via
+     ;; the Wayland socket. A lot of overhead, but speed is not of great concern
+     ;; when doing async calls (it is still quite fast).
+     (dwl:spawn dwl:%binary-path "-e" (object->string (callback (fn)))))))
+
+(define* (dwl:start-repl-server)
+  "Starts a local Guile REPL server, listening on a UNIX socket at path
+@path{/tmp/dwl-guile.socket}. This REPL allows you to execute expressions
+in the dwl-guile context, just like @code{dwl-guile -e \"<exp\"}, but with
+a more user-friendly interface.
+
+The preferred way of connecting to the REPL server is using Geiser in Emacs.
+You can connect to the server by calling @code{geiser-connect-local}, and
+specifying the UNIX-socket path.
+
+Note that this needs to be explicitly called in order for the REPL server to
+be started!
+"
+  (use-modules (system repl server))
+
+  ;; REPL socket path is dependent on the type of build, i.e. stable or devel.
+  ;; Therefore, this variable is set during the initial configuration load in C.
+  (define (kill-server)
+    (when (file-exists? dwl:%repl-socket-path)
+      (delete-file dwl:%repl-socket-path)
+      (stop-server-and-clients!)))
+
+  (unless (file-exists? dwl:%repl-socket-path)
+    (begin
+      (spawn-server (make-unix-domain-server-socket #:path dwl:%repl-socket-path))
+      (add-hook! dwl:hook-quit kill-server))))
+
+(define* (dwl:list-options)
+  "Lists all available options that can be configured using the @code{set}
+procedure."
+  (hash-fold
+   (lambda (key value acc)
+     ;; Discard value since it just contains C-related metadata
+     (cons key acc))
+   '()
+   dwl:%metadata))
+
+(define* (dwl:list-keysyms)
+  "Lists all available keysyms and their respective keycode that can be used
+when binding keys and buttons using the @code{bind} procedure."
+  (define (iterator key value acc)
+     (cons `(,key ,value) acc))
+
+  (hash-fold iterator
+             (hash-fold iterator '() dwl:%keycodes)
+             dwl:%keycodes-mouse))
+
+(define* (dwl:show-options)
+  "Same as @code{dwl:list-options}, but the list of options are printed
+in a readable format."
+  (for-each
+   (lambda (option) (display (string-append (symbol->string option) "\n")))
+   (sort-list (dwl:list-options)
+              (lambda (x y) (string< (symbol->string x)
+                                     (symbol->string y))))))
+
+(define* (dwl:show-keysyms)
+  "Same as @code{dwl:list-keysyms}, but the list of keysyms are printed
+in a readable format."
+  (for-each
+   (lambda (pair)
+     (display (string-append (car pair) " = " (number->string (cadr pair)) "\n")))
+   (sort-list (dwl:list-keysyms)
+              (lambda (x y) (< (cadr x) (cadr y))))))
+
+(define* (dwl:set-tty-keys modifiers #:optional (ttys 12))
+  "Helper procedure for binding all ttys to MODIFIERS + F[1-TTYS]."
+  (for-each
+   (lambda (v)
+     (set-keys (string-append modifiers "-<F" (number->string v) ">") `(dwl:chvt ,v)))
+   (iota ttys 1)))
+
+(define* (dwl:set-tag-keys view-modifiers move-modifiers #:optional (tags 9))
+  "Helper procedure for adding bindings for viewing and moving clients to
+tags 1-TAGS. The key modifiers used for viewing and moving can be set by
+VIEW-MODIFIERS, and MOVE-MODIFIERS, respectively."
+  (for-each
+   (lambda (t)
+     (set-keys (string-append view-modifiers "-" (number->string t)) `(dwl:view ,t)
+               (string-append move-modifiers "-" (number->string t)) `(dwl:tag ,t)))
+   (iota tags 1)))
+
+;; Set required options.
+;; These can not be inhibited, but they can easily be overridden if needed.
+(setq tags (map number->string (iota 9 1)))
+
+;; Define layouts before monitor rules to make sure layout is available.
+(set-layouts 'default "[]=" 'dwl:tile)
+
+;; There must be a default monitor rule (i.e. with name == NULL)
+(set-monitor-rules '((masters . 1)
+                     (master-factor . 0.55)
+                     (scale . 1)
+                     (transform . TRANSFORM-NORMAL)
+                     (layout . default)))
