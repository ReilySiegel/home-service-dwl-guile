diff --git a/.gitignore b/.gitignore
index 0dde90e..b261fc3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,3 +4,7 @@ dwl
 *-protocol.h
 .ccls-cache
 config.h
+config.scm
+dwl.log
+*.patch
+patches
diff --git a/Makefile b/Makefile
index a0d1cc3..99d36a0 100644
--- a/Makefile
+++ b/Makefile
@@ -1,16 +1,27 @@
 include config.mk
 
-CFLAGS += -I. -DWLR_USE_UNSTABLE -std=c99
+CFLAGS += -I. -DWLR_USE_UNSTABLE -std=c99 -Wno-declaration-after-statement
 
 WAYLAND_PROTOCOLS=$(shell pkg-config --variable=pkgdatadir wayland-protocols)
 WAYLAND_SCANNER=$(shell pkg-config --variable=wayland_scanner wayland-scanner)
 
-PKGS = wlroots wayland-server xcb xkbcommon libinput
-CFLAGS += $(foreach p,$(PKGS),$(shell pkg-config --cflags $(p)))
+PKGS = wlroots wayland-server xcb xkbcommon libinput guile-3.0 pixman-1
+CFLAGS += $(foreach p,$(PKGS),$(shell pkg-config --cflags $(p))) -DWLR_USE_UNSTABLE -Wno-error=implicit-function-declaration
 LDLIBS += $(foreach p,$(PKGS),$(shell pkg-config --libs $(p)))
 
 all: dwl
 
+clean:
+	rm -f dwl *.o *-protocol.h *-protocol.c
+
+install: dwl
+	install -D dwl $(PREFIX)/bin/dwl
+
+uninstall:
+	rm -f $(PREFIX)/bin/dwl
+
+.PHONY: all clean install uninstall
+
 # wayland-scanner is a tool which generates C headers and rigging for Wayland
 # protocols, which are specified in XML. wlroots requires you to rig these up
 # to your build system yourself and provide them in the include path.
@@ -44,18 +55,16 @@ idle-protocol.c:
 
 idle-protocol.o: idle-protocol.h
 
-config.h: | config.def.h
-	cp config.def.h $@
+dscm-unstable-v1-protocol.h:
+	$(WAYLAND_SCANNER) server-header \
+		protocols/dscm-unstable-v1.xml $@
 
-dwl.o: config.h client.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h idle-protocol.h
+dscm-unstable-v1-protocol.c:
+	$(WAYLAND_SCANNER) private-code \
+		protocols/dscm-unstable-v1.xml $@
 
-dwl: xdg-shell-protocol.o wlr-layer-shell-unstable-v1-protocol.o idle-protocol.o
+dscm-unstable-v1-protocol.o: dscm-unstable-v1-protocol.h
 
-clean:
-	rm -f dwl *.o *-protocol.h *-protocol.c
-
-install: dwl
-	install -D dwl $(PREFIX)/bin/dwl
+dwl.o: dscm-utils.h dscm-bindings.h dscm-config.h client.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h idle-protocol.h dscm-unstable-v1-protocol.h
 
-.DEFAULT_GOAL=dwl
-.PHONY: clean
+dwl: xdg-shell-protocol.o wlr-layer-shell-unstable-v1-protocol.o idle-protocol.o dscm-unstable-v1-protocol.o
diff --git a/README.md b/README.md
index 22dfa07..43346d1 100644
--- a/README.md
+++ b/README.md
@@ -1,77 +1,4 @@
-# dwl - dwm for Wayland
-
-Join us on our [Discord server](https://discord.gg/jJxZnrGPWN)!
-
-dwl is a compact, hackable compositor for Wayland based on [wlroots](https://github.com/swaywm/wlroots). It is intended to fill the same space in the Wayland world that dwm does in X11, primarily in terms of philosophy, and secondarily in terms of functionality. Like dwm, dwl is:
-
-- Easy to understand, hack on, and extend with patches
-- One C source file (or a very small number) configurable via `config.h`
-- Limited to 2000 SLOC to promote hackability
-- Tied to as few external dependencies as possible
-
-dwl is not meant to provide every feature under the sun. Instead, like dwm, it sticks to features which are necessary, simple, and straightforward to implement given the base on which it is built. Implemented default features are:
-
-- Any features provided by dwm/Xlib: simple window borders, tags, keybindings, client rules, mouse move/resize. Providing a built-in status bar is an exception to this goal, to avoid dependencies on font rendering and/or drawing libraries when an external bar could work well.
-- Configurable multi-monitor layout support, including position and rotation
-- Configurable HiDPI/multi-DPI support
-- Various Wayland protocols
-- XWayland support as provided by wlroots
-- Zero flickering - Wayland users naturally expect that "every frame is perfect"
-
-Features under consideration (possibly as patches) are:
-
-- Protocols made trivial by wlroots
-- Provide information to external status bars via stdout or another file descriptor
-- Implement the input-inhibitor protocol to support screen lockers
-- Implement the idle-inhibit protocol which lets applications such as mpv disable idle monitoring
-- Layer shell popups (used by Waybar)
-- Basic yes/no damage tracking to avoid needless redraws
-- More in-depth damage region tracking ([which may improve power usage](https://mozillagfx.wordpress.com/2019/10/22/dramatically-reduced-power-usage-in-firefox-70-on-macos-with-core-animation/))
-- Implement the text-input and input-method protocols to support IME once ibus implements input-method v2 (see https://github.com/ibus/ibus/pull/2256 and https://github.com/djpohly/dwl/pull/12)
-- Implement urgent/attention/focus-request once it's part of the xdg-shell protocol (https://gitlab.freedesktop.org/wayland/wayland-protocols/-/merge_requests/9)
-
-Feature *non-goals* include:
-
-- Client-side decoration (any more than is necessary to tell the clients not to)
-- Client-initiated window management, such as move, resize, and close, which can be done through the compositor
-
-## Building dwl
-
-dwl has only two dependencies: wlroots 0.13 and wayland-protocols. Simply install these and run `make`.  If you wish to build against a Git version of wlroots, check out the [wlroots-next branch](https://github.com/djpohly/dwl/tree/wlroots-next).
-
-To enable XWayland, you should also install xorg-xwayland and uncomment its flag in `config.mk`.
-
-## Configuration
-
-All configuration is done by editing `config.h` and recompiling, in the same manner as dwm. There is no way to separately restart the window manager in Wayland without restarting the entire display server, so any changes will take effect the next time dwl is executed.
-
-As in the dwm community, we encourage users to share patches they have created.  Check out the [patches page on our wiki](https://github.com/djpohly/dwl/wiki/Patches)!
-
-## Running dwl
-
-dwl can be run as-is, with no arguments. In an existing Wayland or X11 session, this will open a window to act as a virtual display. When run from a TTY, the Wayland server will take over the entire virtual terminal. Clients started by dwl will have `WAYLAND_DISPLAY` set in their environment, and other clients can be started from outside the session by setting this variable accordingly.
-
-You can also specify a startup program using the `-s` option. The argument to this option will be run at startup as a shell command (using `sh -c`) and can serve a similar function to `.xinitrc`: starting a service manager or other startup applications. Unlike `.xinitrc`, the display server will not shut down when this process terminates. Instead, as dwl is shutting down, it will send this process a SIGTERM and wait for it to terminate (if it hasn't already). This makes it ideal not only for initialization but also for execing into a user-level service manager like s6 or `systemd --user`.
-
-Note: Wayland requires a valid `XDG_RUNTIME_DIR`, which is usually set up by a session manager such as `elogind` or `systemd-logind`.  If your system doesn't do this automatically, you will need to configure it prior to launching `dwl`, e.g.:
-
-    export XDG_RUNTIME_DIR=/tmp/xdg-runtime-$(id -u)
-    mkdir -p $XDG_RUNTIME_DIR
-
-## Replacements for X applications
-
-You can find a [list of Wayland applications on the sway wiki](https://github.com/swaywm/sway/wiki/i3-Migration-Guide).
-
-## IRC channel
-
-dwl's IRC channel is #dwl on irc.freenode.net.
-
-## Acknowledgements
-
-dwl began by extending the TinyWL example provided (CC0) by the sway/wlroots developers. This was made possible in many cases by looking at how sway accomplished something, then trying to do the same in as suckless a way as possible.
-
-Many thanks to suckless.org and the dwm developers and community for the inspiration, and to the various contributors to the project, including:
-
-- Alexander Courtis for the XWayland implementation
-- Guido Cella for the layer-shell protocol implementation, patch maintenance, and for helping to keep the project running
-- Stivvo for output management and fullscreen support, and patch maintenance
+# dwl-guile
+dwl-guile is a patch to dwl that adds dynamic configuration using Guile. It
+integrates with GNU Guix as a home service (see
+[home-service-dwl-guile](https://github.com/engstrand-config/home-service-dwl-guile)).
diff --git a/client.h b/client.h
index f4735c2..56e3089 100644
--- a/client.h
+++ b/client.h
@@ -141,6 +141,17 @@ client_set_size(Client *c, uint32_t width, uint32_t height)
 	return wlr_xdg_toplevel_set_size(c->surface.xdg, width, height);
 }
 
+static inline void
+client_set_tiled(Client *c, uint32_t edges)
+{
+#ifdef XWAYLAND
+	if (client_is_x11(c))
+		return;
+#endif
+	wlr_xdg_toplevel_set_tiled(c->surface.xdg, WLR_EDGE_TOP |
+			WLR_EDGE_BOTTOM | WLR_EDGE_LEFT | WLR_EDGE_RIGHT);
+}
+
 static inline struct wlr_surface *
 client_surface(Client *c)
 {
diff --git a/config.def.h b/config.def.h
deleted file mode 100644
index 089aa37..0000000
--- a/config.def.h
+++ /dev/null
@@ -1,116 +0,0 @@
-/* appearance */
-static const int sloppyfocus        = 1;  /* focus follows mouse */
-static const unsigned int borderpx  = 1;  /* border pixel of windows */
-static const float rootcolor[]      = {0.3, 0.3, 0.3, 1.0};
-static const float bordercolor[]    = {0.5, 0.5, 0.5, 1.0};
-static const float focuscolor[]     = {1.0, 0.0, 0.0, 1.0};
-
-/* tagging */
-static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
-
-static const Rule rules[] = {
-	/* app_id     title       tags mask     isfloating   monitor */
-	/* examples:
-	{ "Gimp",     NULL,       0,            1,           -1 },
-	{ "firefox",  NULL,       1 << 8,       0,           -1 },
-	*/
-};
-
-/* layout(s) */
-static const Layout layouts[] = {
-	/* symbol     arrange function */
-	{ "[]=",      tile },
-	{ "><>",      NULL },    /* no layout function means floating behavior */
-	{ "[M]",      monocle },
-};
-
-/* monitors
- * The order in which monitors are defined determines their position.
- * Non-configured monitors are always added to the left. */
-static const MonitorRule monrules[] = {
-	/* name       mfact nmaster scale layout       rotate/reflect x y */
-	/* example of a HiDPI laptop monitor:
-	{ "eDP-1",    0.5,  1,      2,    &layouts[0], WL_OUTPUT_TRANSFORM_NORMAL, 0, 0 },
-	*/
-	/* defaults */
-	{ NULL,       0.55, 1,      1,    &layouts[0], WL_OUTPUT_TRANSFORM_NORMAL, 0, 0 },
-};
-
-/* keyboard */
-static const struct xkb_rule_names xkb_rules = {
-	/* can specify fields: rules, model, layout, variant, options */
-	/* example:
-	.options = "ctrl:nocaps",
-	*/
-};
-
-static const int repeat_rate = 25;
-static const int repeat_delay = 600;
-
-/* Trackpad */
-static const int tap_to_click = 1;
-static const int natural_scrolling = 0;
-
-#define MODKEY WLR_MODIFIER_ALT
-#define TAGKEYS(KEY,SKEY,TAG) \
-	{ MODKEY,                    KEY,            view,            {.ui = 1 << TAG} }, \
-	{ MODKEY|WLR_MODIFIER_CTRL,  KEY,            toggleview,      {.ui = 1 << TAG} }, \
-	{ MODKEY|WLR_MODIFIER_SHIFT, SKEY,           tag,             {.ui = 1 << TAG} }, \
-	{ MODKEY|WLR_MODIFIER_CTRL|WLR_MODIFIER_SHIFT,SKEY,toggletag, {.ui = 1 << TAG} }
-
-/* helper for spawning shell commands in the pre dwm-5.0 fashion */
-#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
-
-/* commands */
-static const char *termcmd[] = { "alacritty", NULL };
-static const char *menucmd[] = { "bemenu-run", NULL };
-
-static const Key keys[] = {
-	/* Note that Shift changes certain key codes: c -> C, 2 -> at, etc. */
-	/* modifier                  key                 function        argument */
-	{ MODKEY,                    XKB_KEY_p,          spawn,          {.v = menucmd} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Return,     spawn,          {.v = termcmd} },
-	{ MODKEY,                    XKB_KEY_j,          focusstack,     {.i = +1} },
-	{ MODKEY,                    XKB_KEY_k,          focusstack,     {.i = -1} },
-	{ MODKEY,                    XKB_KEY_i,          incnmaster,     {.i = +1} },
-	{ MODKEY,                    XKB_KEY_d,          incnmaster,     {.i = -1} },
-	{ MODKEY,                    XKB_KEY_h,          setmfact,       {.f = -0.05} },
-	{ MODKEY,                    XKB_KEY_l,          setmfact,       {.f = +0.05} },
-	{ MODKEY,                    XKB_KEY_Return,     zoom,           {0} },
-	{ MODKEY,                    XKB_KEY_Tab,        view,           {0} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_C,          killclient,     {0} },
-	{ MODKEY,                    XKB_KEY_t,          setlayout,      {.v = &layouts[0]} },
-	{ MODKEY,                    XKB_KEY_f,          setlayout,      {.v = &layouts[1]} },
-	{ MODKEY,                    XKB_KEY_m,          setlayout,      {.v = &layouts[2]} },
-	{ MODKEY,                    XKB_KEY_space,      setlayout,      {0} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_space,      togglefloating, {0} },
-	{ MODKEY, 					 XKB_KEY_e,    		togglefullscreen, {0} },
-	{ MODKEY,                    XKB_KEY_0,          view,           {.ui = ~0} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_parenright, tag,            {.ui = ~0} },
-	{ MODKEY,                    XKB_KEY_comma,      focusmon,       {.i = WLR_DIRECTION_LEFT} },
-	{ MODKEY,                    XKB_KEY_period,     focusmon,       {.i = WLR_DIRECTION_RIGHT} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_less,       tagmon,         {.i = WLR_DIRECTION_LEFT} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_greater,    tagmon,         {.i = WLR_DIRECTION_RIGHT} },
-	TAGKEYS(          XKB_KEY_1, XKB_KEY_exclam,                     0),
-	TAGKEYS(          XKB_KEY_2, XKB_KEY_at,                         1),
-	TAGKEYS(          XKB_KEY_3, XKB_KEY_numbersign,                 2),
-	TAGKEYS(          XKB_KEY_4, XKB_KEY_dollar,                     3),
-	TAGKEYS(          XKB_KEY_5, XKB_KEY_percent,                    4),
-	TAGKEYS(          XKB_KEY_6, XKB_KEY_caret,                      5),
-	TAGKEYS(          XKB_KEY_7, XKB_KEY_ampersand,                  6),
-	TAGKEYS(          XKB_KEY_8, XKB_KEY_asterisk,                   7),
-	TAGKEYS(          XKB_KEY_9, XKB_KEY_parenleft,                  8),
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Q,          quit,           {0} },
-
-	/* Ctrl-Alt-Backspace and Ctrl-Alt-Fx used to be handled by X server */
-	{ WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_Terminate_Server, quit, {0} },
-#define CHVT(n) { WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_XF86Switch_VT_##n, chvt, {.ui = (n)} }
-	CHVT(1), CHVT(2), CHVT(3), CHVT(4), CHVT(5), CHVT(6),
-	CHVT(7), CHVT(8), CHVT(9), CHVT(10), CHVT(11), CHVT(12),
-};
-
-static const Button buttons[] = {
-	{ MODKEY, BTN_LEFT,   moveresize,     {.ui = CurMove} },
-	{ MODKEY, BTN_MIDDLE, togglefloating, {0} },
-	{ MODKEY, BTN_RIGHT,  moveresize,     {.ui = CurResize} },
-};
diff --git a/dscm-bindings.h b/dscm-bindings.h
new file mode 100644
index 0000000..3bc0379
--- /dev/null
+++ b/dscm-bindings.h
@@ -0,0 +1,374 @@
+static inline SCM
+dscm_binding_monocle(SCM monitor)
+{
+        Monitor *m = (Monitor*)scm_to_pointer(monitor);
+        monocle(m);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_tile(SCM monitor)
+{
+        Monitor *m = (Monitor*)scm_to_pointer(monitor);
+        tile(m);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_spawn(SCM args)
+{
+        if (scm_is_null(args))
+                return SCM_BOOL_F;
+        unsigned int i = 0, length = dscm_get_list_length(args);
+        char *cmd_args[length + 1];
+        for (; i < length; i++) {
+                SCM arg_exp = dscm_get_list_item(args, i);
+                char *arg = scm_to_locale_string(arg_exp);
+                cmd_args[i] = arg;
+        }
+        cmd_args[i] = NULL;
+        Arg a = {.v = cmd_args};
+        spawn(&a);
+        for (char **iter = cmd_args; *iter != NULL; iter++)
+                free(*iter);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_shcmd(SCM args)
+{
+        SCM extended = scm_list_3(scm_from_utf8_string("/bin/sh"),
+                scm_from_utf8_string("-c"), args);
+        return dscm_binding_spawn(extended);
+}
+
+static inline SCM
+dscm_binding_spawn_menu()
+{
+        Arg a = {.v = menucmd};
+        spawn(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_spawn_terminal()
+{
+        Arg a = {.v = termcmd};
+        spawn(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_focusstack(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        focusstack(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_setmfact(SCM value)
+{
+        Arg a = {.f = scm_to_double(value)};
+        setmfact(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_togglefloating()
+{
+        togglefloating(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_zoom()
+{
+        zoom(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_setlayout(SCM value)
+{
+        char *id = scm_to_locale_string(value);
+        Layout *layout = NULL;
+        for (int i = 0; i < numlayouts; i++) {
+                if (strcmp(layouts[i].id, id) == 0)
+                        layout = &layouts[i];
+        }
+        if (layout == NULL)
+                return SCM_BOOL_F;
+        Arg a = {.v = layout};
+        setlayout(&a);
+        free(id);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_togglefullscreen()
+{
+        togglefullscreen(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_focusmon(SCM value)
+{
+        SCM eval = scm_primitive_eval(value);
+        Arg a = {.i = scm_to_int(eval)};
+        focusmon(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_tagmon(SCM value)
+{
+        SCM eval = scm_primitive_eval(value);
+        Arg a = {.i = scm_to_int(eval)};
+        tagmon(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_chvt(SCM tty)
+{
+        if (!scm_is_number(tty))
+                return SCM_BOOL_F;
+        int target_tty = scm_to_int(tty);
+        if (target_tty <= 0 || target_tty > 12)
+                return SCM_BOOL_F;
+        Arg a = {.ui = (unsigned int)target_tty};
+        chvt(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_changealpha(SCM value)
+{
+        Arg a = {.f = scm_to_double(value)};
+        changealpha(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_view(SCM value)
+{
+        Arg a = {.ui = dscm_get_tag(value, numtags)};
+        view(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_viewprev(SCM value)
+{
+        viewprev(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_toggleview(SCM value)
+{
+        Arg a = {.ui = dscm_get_tag(value, numtags)};
+        toggleview(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_tag(SCM value)
+{
+        Arg a = {.ui = dscm_get_tag(value, numtags)};
+        tag(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_cyclelayout(SCM direction)
+{
+        Arg a = {.i = 1};
+        if (scm_is_number(direction))
+                a.i = scm_to_int(direction);
+        cyclelayout(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incnmaster(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incnmaster(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_toggletag(SCM value)
+{
+        Arg a = {.ui = dscm_get_tag(value, numtags)};
+        toggletag(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_moveresize(SCM cursor)
+{
+        Arg a = {.ui = scm_to_unsigned_integer(cursor, 0, CurResize)};
+        moveresize(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_killclient()
+{
+        killclient(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_quit()
+{
+        quit(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incrgaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrgaps(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incrigaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrigaps(&a);
+        return SCM_BOOL_T;
+}
+static inline SCM
+dscm_binding_incrogaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrogaps(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incrohgaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrohgaps(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incrovgaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrovgaps(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incrihgaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrihgaps(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incrivgaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrivgaps(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_togglegaps()
+{
+        togglegaps(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_defaultgaps()
+{
+        defaultgaps(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline void
+dscm_register()
+{
+        scm_c_define("SHIFT", scm_from_int(WLR_MODIFIER_SHIFT));
+        scm_c_define("CAPS", scm_from_int(WLR_MODIFIER_CAPS));
+        scm_c_define("CTRL", scm_from_int(WLR_MODIFIER_CTRL));
+        scm_c_define("ALT", scm_from_int(WLR_MODIFIER_ALT));
+        scm_c_define("MOD2", scm_from_int(WLR_MODIFIER_MOD2));
+        scm_c_define("MOD3", scm_from_int(WLR_MODIFIER_MOD3));
+        scm_c_define("SUPER", scm_from_int(WLR_MODIFIER_LOGO));
+        scm_c_define("MOD5", scm_from_int(WLR_MODIFIER_MOD5));
+        /* TODO: add bindings for other mouse buttons */
+        scm_c_define("DIRECTION-LEFT", scm_from_int(WLR_DIRECTION_LEFT));
+        scm_c_define("DIRECTION-RIGHT", scm_from_int(WLR_DIRECTION_RIGHT));
+        scm_c_define("MOUSE-LEFT", scm_from_int(BTN_LEFT));
+        scm_c_define("MOUSE-MIDDLE", scm_from_int(BTN_MIDDLE));
+        scm_c_define("MOUSE-RIGHT", scm_from_int(BTN_RIGHT));
+        scm_c_define("CURSOR-NORMAL", scm_from_int(CurNormal));
+        scm_c_define("CURSOR-MOVE", scm_from_int(CurMove));
+        scm_c_define("CURSOR-RESIZE", scm_from_int(CurResize));
+        scm_c_define("TRANSFORM-NORMAL",
+                scm_from_int(WL_OUTPUT_TRANSFORM_NORMAL));
+        scm_c_define("TRANSFORM-ROTATE-90",
+                scm_from_int(WL_OUTPUT_TRANSFORM_90));
+        scm_c_define("TRANSFORM-ROTATE-180",
+                scm_from_int(WL_OUTPUT_TRANSFORM_180));
+        scm_c_define("TRANSFORM-ROTATE-270",
+                scm_from_int(WL_OUTPUT_TRANSFORM_270));
+        scm_c_define("TRANSFORM-FLIPPED",
+                scm_from_int(WL_OUTPUT_TRANSFORM_FLIPPED));
+        scm_c_define("TRANSFORM-FLIPPED-90",
+                scm_from_int(WL_OUTPUT_TRANSFORM_FLIPPED_90));
+        scm_c_define("TRANSFORM-FLIPPED-180",
+                scm_from_int(WL_OUTPUT_TRANSFORM_FLIPPED_180));
+        scm_c_define("TRANSFORM-FLIPPED-270",
+                scm_from_int(WL_OUTPUT_TRANSFORM_FLIPPED_270));
+
+        scm_c_define_gsubr("dwl:chvt", 1, 0, 0, &dscm_binding_chvt);
+        scm_c_define_gsubr("dwl:quit", 0, 0, 0, &dscm_binding_quit);
+        scm_c_define_gsubr("dwl:killclient", 0, 0, 0, &dscm_binding_killclient);
+        scm_c_define_gsubr("dwl:tile", 1, 0, 0, &dscm_binding_tile);
+        scm_c_define_gsubr("dwl:monocle", 1, 0, 0, &dscm_binding_monocle);
+        scm_c_define_gsubr("dwl:spawn", 0, 0, 1, &dscm_binding_spawn);
+        scm_c_define_gsubr("dwl:view", 1, 0, 0, &dscm_binding_view);
+        scm_c_define_gsubr("dwl:view-previous", 0, 0, 0, &dscm_binding_viewprev);
+        scm_c_define_gsubr("dwl:toggle-view", 1, 0, 0, &dscm_binding_toggleview);
+        scm_c_define_gsubr("dwl:tag", 1, 0, 0, &dscm_binding_tag);
+        scm_c_define_gsubr("dwl:cycle-layout", 0, 1, 0, &dscm_binding_cyclelayout);
+        scm_c_define_gsubr("dwl:toggle-tag", 1, 0, 0, &dscm_binding_toggletag);
+        scm_c_define_gsubr("dwl:focus-stack", 1, 0, 0, &dscm_binding_focusstack);
+        scm_c_define_gsubr("dwl:set-master-factor", 1, 0, 0, &dscm_binding_setmfact);
+        scm_c_define_gsubr("dwl:zoom", 0, 0, 0, &dscm_binding_zoom);
+        scm_c_define_gsubr("dwl:set-layout", 1, 0, 0, &dscm_binding_setlayout);
+        scm_c_define_gsubr("dwl:toggle-fullscreen", 0, 0, 0, &dscm_binding_togglefullscreen);
+        scm_c_define_gsubr("dwl:toggle-floating", 0, 0, 0, &dscm_binding_togglefloating);
+        scm_c_define_gsubr("dwl:focus-monitor", 1, 0, 0, &dscm_binding_focusmon);
+        scm_c_define_gsubr("dwl:tag-monitor", 1, 0, 0, &dscm_binding_tagmon);
+        scm_c_define_gsubr("dwl:move-resize", 1, 0, 0, &dscm_binding_moveresize);
+        scm_c_define_gsubr("dwl:set-masters", 1, 0, 0, &dscm_binding_incnmaster);
+        scm_c_define_gsubr("dwl:shcmd", 1, 0, 0, &dscm_binding_shcmd);
+        scm_c_define_gsubr("dwl:change-alpha", 1, 0, 0, &dscm_binding_changealpha);
+        scm_c_define_gsubr("dwl:spawn-menu", 0, 0, 0, &dscm_binding_spawn_menu);
+        scm_c_define_gsubr("dwl:spawn-terminal", 0, 0, 0, &dscm_binding_spawn_terminal);
+        scm_c_define_gsubr("dwl:toggle-gaps", 0, 0, 0, &dscm_binding_togglegaps);
+        scm_c_define_gsubr("dwl:default-gaps", 0, 0, 0, &dscm_binding_defaultgaps);
+        scm_c_define_gsubr("dwl:gaps", 1, 0, 0, &dscm_binding_incrgaps);
+        scm_c_define_gsubr("dwl:gaps-inner", 1, 0, 0, &dscm_binding_incrigaps);
+        scm_c_define_gsubr("dwl:gaps-outer", 1, 0, 0, &dscm_binding_incrogaps);
+        scm_c_define_gsubr("dwl:gaps-inner-horizontal", 1, 0, 0, &dscm_binding_incrihgaps);
+        scm_c_define_gsubr("dwl:gaps-inner-vertical", 1, 0, 0, &dscm_binding_incrivgaps);
+        scm_c_define_gsubr("dwl:gaps-outer-horizontal", 1, 0, 0, &dscm_binding_incrohgaps);
+        scm_c_define_gsubr("dwl:gaps-outer-vertical", 1, 0, 0, &dscm_binding_incrovgaps);
+}
diff --git a/dscm-config.h b/dscm-config.h
new file mode 100644
index 0000000..fc00a3f
--- /dev/null
+++ b/dscm-config.h
@@ -0,0 +1,213 @@
+#pragma once
+
+SCM config;
+
+/* Config variable definitions. */
+/* These will be automatically set from the guile config. */
+static int repeat_rate          = 25;
+static int repeat_delay         = 600;
+static int sloppyfocus          = 1;
+static int tap_to_click         = 1;
+static int natural_scrolling    = 1;
+static unsigned int borderpx    = 1;
+static double default_alpha     = 1.0;
+static unsigned int gappih      = 0;
+static unsigned int gappiv      = 0;
+static unsigned int gappoh      = 0;
+static unsigned int gappov      = 0;
+static int smartgaps            = 0;
+static float *rootcolor         = NULL;
+static float *bordercolor       = NULL;
+static float *focuscolor        = NULL;
+static float *textcolor         = NULL;
+static char **tags              = NULL;
+static char **termcmd           = NULL;
+static char **menucmd           = NULL;
+static Layout *layouts          = NULL;
+static MonitorRule *monrules    = NULL;
+static Rule *rules              = NULL;
+static Key *keys                = NULL;
+static Button *buttons          = NULL;
+static struct xkb_rule_names *xkb_rules = NULL;
+
+static unsigned int numtags     = 0;
+static unsigned int numkeys     = 0;
+static unsigned int numrules    = 0;
+static unsigned int numlayouts  = 0;
+static unsigned int nummonrules = 0;
+static unsigned int numbuttons  = 0;
+static unsigned int TAGMASK     = 0;
+
+static inline void
+dscm_parse_color(unsigned int index, SCM value, void *data)
+{
+        ((float*)data)[index] = (float)scm_to_double(value);
+}
+
+static inline void
+dscm_parse_string(unsigned int index, SCM str, void *data)
+{
+        ((char**)data)[index] = scm_to_locale_string(str);
+}
+
+static inline void
+dscm_parse_layout(unsigned int index, SCM layout, void *data)
+{
+        ((Layout*)data)[index] = (Layout){
+                .id = dscm_alist_get_string(layout, "id"),
+                .symbol = dscm_alist_get_string(layout, "symbol"),
+                .arrange = dscm_alist_get_proc_pointer(layout, "arrange")
+        };
+}
+
+static inline void
+dscm_parse_monitor_rule(unsigned int index, SCM rule, void *data)
+{
+        SCM transform = dscm_alist_get(rule, "transform");
+        SCM eval = scm_primitive_eval(transform);
+        ((MonitorRule*)data)[index] = (MonitorRule){
+                .name = dscm_alist_get_string(rule, "name"),
+                .mfact = dscm_alist_get_float(rule, "master-factor"),
+                .nmaster = dscm_alist_get_int(rule, "masters"),
+                .scale = dscm_alist_get_float(rule, "scale"),
+                .lt = &layouts[dscm_alist_get_int(rule, "layout")],
+                .rr = (enum wl_output_transform)scm_to_int(eval),
+                .x = dscm_alist_get_int(rule, "x"),
+                .y = dscm_alist_get_int(rule, "y"),
+        };
+}
+
+static inline void
+dscm_parse_rule(unsigned int index, SCM rule, void *data)
+{
+         ((Rule*)data)[index] = (Rule){
+                .id = dscm_alist_get_string(rule, "id"),
+                .title = dscm_alist_get_string(rule, "title"),
+                .tags = dscm_alist_get_unsigned_int(rule, "tag", -1),
+                .isfloating = dscm_alist_get_int(rule, "floating"),
+                .monitor = dscm_alist_get_int(rule, "monitor"),
+                .alpha = dscm_alist_get_double(rule, "alpha")
+         };
+}
+
+static inline void
+dscm_parse_key(unsigned int index, SCM key, void *data)
+{
+        xkb_keycode_t keycode = dscm_alist_get_unsigned_int(key, "key", -1);
+        /* Should we use `xkb_keycode_is_legal_x11`? */
+        if (!xkb_keycode_is_legal_x11(keycode)
+                || !xkb_keycode_is_legal_ext(keycode))
+                BARF("dscm: keycode '%d' is not a legal keycode\n", keycode);
+        ((Key*)data)[index] = (Key){
+                .mod = dscm_alist_get_modifiers(key, "modifiers"),
+                .keycode = keycode,
+                .func = dscm_alist_get_proc_pointer(key, "action")
+        };
+}
+
+static inline void
+dscm_parse_button(unsigned int index, SCM button, void *data)
+{
+        SCM symbol = dscm_alist_get(button, "button");
+        SCM eval = scm_primitive_eval(symbol);
+        ((Button*)data)[index] = (Button){
+                .mod = (unsigned int)dscm_alist_get_modifiers(button, "modifiers"),
+                .button = scm_to_unsigned_integer(eval, 0, -1),
+                .func = dscm_alist_get_proc_pointer(button, "action")
+        };
+}
+
+static inline struct xkb_rule_names *
+dscm_parse_xkb_rules(SCM config)
+{
+        SCM xkb = dscm_alist_get(config, "xkb-rules");
+        struct xkb_rule_names *dest = calloc(1, sizeof(struct xkb_rule_names));
+        *dest = (struct xkb_rule_names){
+                .rules = dscm_alist_get_string(xkb, "rules"),
+                .model = dscm_alist_get_string(xkb, "model"),
+                .layout = dscm_alist_get_string(xkb, "layouts"),
+                .variant = dscm_alist_get_string(xkb, "variants"),
+                .options = dscm_alist_get_string(xkb, "options"),
+        };
+        return dest;
+}
+
+static inline void
+dscm_config_parse(char *config_file)
+{
+        scm_c_primitive_load(config_file);
+        config = dscm_get_variable("config");
+
+        sloppyfocus = dscm_alist_get_int(config, "sloppy-focus");
+        tap_to_click = dscm_alist_get_int(config, "tap-to-click");
+        natural_scrolling = dscm_alist_get_int(config, "natural-scrolling");
+        borderpx = dscm_alist_get_unsigned_int(config, "border-px", 25);
+        repeat_rate = dscm_alist_get_unsigned_int(config, "repeat-rate", 5000);
+        repeat_delay = dscm_alist_get_unsigned_int(config, "repeat-delay", 5000);
+        default_alpha = dscm_alist_get_double(config, "default-alpha");
+        gappih = dscm_alist_get_unsigned_int(config, "gaps-horizontal-inner", -1);
+        gappiv = dscm_alist_get_unsigned_int(config, "gaps-vertical-inner", -1);
+        gappoh = dscm_alist_get_unsigned_int(config, "gaps-horizontal-outer", -1);
+        gappov = dscm_alist_get_unsigned_int(config, "gaps-vertical-outer", -1);
+        smartgaps = dscm_alist_get_int(config, "smart-gaps");
+
+        SCM colors = dscm_alist_get(config, "colors");
+        rootcolor = dscm_iterate_list(dscm_alist_get(colors, "root"),
+                sizeof(float), 0, &dscm_parse_color, NULL);
+        bordercolor = dscm_iterate_list(dscm_alist_get(colors, "border"),
+                sizeof(float), 0, &dscm_parse_color, NULL);
+        focuscolor = dscm_iterate_list(dscm_alist_get(colors, "focus"),
+                sizeof(float), 0, &dscm_parse_color, NULL);
+        textcolor = dscm_iterate_list(dscm_alist_get(colors, "text"),
+                sizeof(float), 0, &dscm_parse_color, NULL);
+        tags = dscm_iterate_list(dscm_alist_get(config, "tags"),
+                sizeof(char*), 0, &dscm_parse_string, &numtags);
+        termcmd = dscm_iterate_list(dscm_alist_get(config, "terminal"),
+                sizeof(char*), 1, &dscm_parse_string, NULL);
+        menucmd = dscm_iterate_list(dscm_alist_get(config, "menu"),
+                sizeof(char*), 1, &dscm_parse_string, NULL);
+        layouts = dscm_iterate_list(dscm_alist_get(config, "layouts"),
+                sizeof(Layout), 0, &dscm_parse_layout, &numlayouts);
+        rules = dscm_iterate_list(dscm_alist_get(config, "rules"),
+                sizeof(Rule), 0, &dscm_parse_rule, &numrules);
+        monrules = dscm_iterate_list(dscm_alist_get(config, "monitor-rules"),
+                sizeof(MonitorRule), 0, &dscm_parse_monitor_rule, &nummonrules);
+        keys = dscm_iterate_list(dscm_alist_get(config, "keys"),
+                sizeof(Key), 0, &dscm_parse_key, &numkeys);
+        buttons = dscm_iterate_list(dscm_alist_get(config, "buttons"),
+                sizeof(Button), 0, &dscm_parse_button, &numbuttons);
+        xkb_rules = dscm_parse_xkb_rules(config);
+        TAGMASK = ((1 << numtags) - 1);
+}
+
+static inline void
+dscm_config_cleanup()
+{
+        fprintf(stdout, "dscm: starting cleanup\n");
+        int i;
+        char **str;
+        for (i = 0; i < numtags; i++) free(tags[i]);
+        for (str = termcmd; *str != NULL; str++) free(*str);
+        for (str = menucmd; *str != NULL; str++) free(*str);
+        for (i = 0; i < numlayouts; i++) free(layouts[i].symbol);
+        for (i = 0; i < nummonrules; i++) free(monrules[i].name);
+        for (i = 0; i < numrules; i++) {
+                Rule r = rules[i];
+                free(r.id);
+                free(r.title);
+        }
+        free(layouts);
+        free(monrules);
+        free(keys);
+        free(buttons);
+        free(rootcolor);
+        free(bordercolor);
+        free(focuscolor);
+        free(textcolor);
+        free((char*)xkb_rules->rules);
+        free((char*)xkb_rules->model);
+        free((char*)xkb_rules->layout);
+        free((char*)xkb_rules->variant);
+        free((char*)xkb_rules->options);
+        free(xkb_rules);
+}
diff --git a/dscm-utils.h b/dscm-utils.h
new file mode 100644
index 0000000..6c246ae
--- /dev/null
+++ b/dscm-utils.h
@@ -0,0 +1,174 @@
+#pragma once
+
+enum { DSCM_CALL_ARRANGE, DSCM_CALL_ACTION };
+typedef struct {
+        SCM proc;
+        void *args;
+} dscm_call_data_t;
+
+static inline SCM
+dscm_alist_get(SCM alist, const char* key)
+{
+        return scm_assoc_ref(alist, scm_from_utf8_string(key));
+}
+
+static inline char*
+dscm_alist_get_string(SCM alist, const char* key)
+{
+        SCM value = dscm_alist_get(alist, key);
+        if (scm_is_string(value))
+                return scm_to_locale_string(value);
+        return NULL;
+}
+
+static inline int
+dscm_alist_get_int(SCM alist, const char* key)
+{
+        SCM value = dscm_alist_get(alist, key);
+        if (scm_is_bool(value))
+                return scm_is_true(value) ? 1 : 0;
+        return scm_to_int(value);
+}
+
+static inline unsigned int
+dscm_alist_get_unsigned_int(SCM alist, const char* key, int max)
+{
+        return scm_to_unsigned_integer(dscm_alist_get(alist, key), 0, max);
+}
+
+static inline double
+dscm_alist_get_double(SCM alist, const char* key)
+{
+        SCM value = dscm_alist_get(alist, key);
+        if (scm_is_bool(value))
+                return scm_is_true(value) ? 1 : 0;
+        return scm_to_double(value);
+}
+
+static inline float
+dscm_alist_get_float(SCM alist, const char* key)
+{
+        return (float)dscm_alist_get_double(alist, key);
+}
+
+static inline scm_t_bits *
+dscm_alist_get_proc_pointer(SCM alist, const char *key)
+{
+        scm_t_bits *proc = NULL;
+        SCM value = dscm_alist_get(alist, key);
+        if (scm_is_false(value))
+                return proc;
+        SCM eval = scm_primitive_eval(value);
+        /* SCM_UNPACK_POINTER is only allowed on expressions where SCM_IMP is 0 */
+        if (SCM_IMP(eval) == 1)
+                BARF("dscm: invalid callback procedure. SCM_IMP(proc) = 1");
+        if (scm_procedure_p(eval) == SCM_BOOL_T) {
+                proc = SCM_UNPACK_POINTER(eval);
+                scm_gc_protect_object(eval);
+        }
+        return proc;
+}
+
+static inline SCM
+dscm_get_variable(const char *name)
+{
+        return scm_variable_ref(scm_c_lookup(name));
+}
+
+static inline unsigned int
+dscm_get_list_length(SCM list)
+{
+        return scm_to_unsigned_integer(scm_length(list), 0, -1);
+}
+
+static inline SCM
+dscm_get_list_item(SCM list, unsigned int index)
+{
+        return scm_list_ref(list, scm_from_unsigned_integer(index));
+}
+
+static inline uint32_t
+dscm_alist_get_modifiers(SCM alist, const char *key)
+{
+        SCM modifiers = dscm_alist_get(alist, key);
+        uint32_t mod = 0;
+        unsigned int i = 0, length = dscm_get_list_length(modifiers);
+        for (; i < length; i++) {
+                SCM item = dscm_get_list_item(modifiers, i);
+                SCM eval = scm_primitive_eval(item);
+                mod |= scm_to_uint32(eval);
+        }
+        return mod;
+}
+
+static inline unsigned int
+dscm_get_tag(SCM tag, unsigned int tags)
+{
+        unsigned int target_tag = scm_to_unsigned_integer(tag, 1, tags) - 1;
+        return (1 << (target_tag));
+}
+
+static inline void *
+dscm_iterate_list(SCM list, size_t elem_size, int append_null,
+        void (*iterator)(unsigned int, SCM, void*), unsigned int *length_var)
+{
+        SCM item;
+        unsigned int i = 0, length = 0;
+        length = dscm_get_list_length(list);
+        void *allocated = calloc(append_null ? length + 1 : length, elem_size);
+        for (; i < length; i++) {
+                item = dscm_get_list_item(list, i);
+                (*iterator)(i, item, allocated);
+        }
+        if (append_null)
+                ((void**)allocated)[i] = NULL;
+        if (length_var)
+                *length_var = length;
+        return allocated;
+}
+
+static inline void
+dscm_modify_list(SCM list, void *target, void (*iterator)(unsigned int, SCM, void*))
+{
+        SCM item;
+        unsigned int length = dscm_get_list_length(list);
+        for (unsigned int i = 0; i < length; i++) {
+                item = dscm_get_list_item(list, i);
+                (*iterator)(i, item, target);
+        }
+}
+
+static inline void*
+dscm_call_action(void *data)
+{
+        return scm_call_0(((dscm_call_data_t*)data)->proc);
+}
+
+static inline void*
+dscm_call_arrange(void *data)
+{
+        dscm_call_data_t *proc_data = (dscm_call_data_t*)data;
+        SCM mon = scm_from_pointer(proc_data->args, NULL);
+        return scm_call_1(proc_data->proc, mon);
+}
+
+static inline void
+dscm_safe_call(unsigned int type, scm_t_bits *proc_ptr, void *data)
+{
+        if (proc_ptr == NULL) {
+                fprintf(stderr, "dscm: could not call proc that is NULL");
+                return;
+        }
+        SCM proc = SCM_PACK_POINTER(proc_ptr);
+        dscm_call_data_t proc_data = {.proc = proc, .args = data};
+        void *(*func)(void*) = NULL;
+        switch (type) {
+            case DSCM_CALL_ARRANGE:
+                func = &dscm_call_arrange;
+                break;
+            case DSCM_CALL_ACTION:
+            default:
+                func = &dscm_call_action;
+        }
+        scm_c_with_continuation_barrier(func, &proc_data);
+}
diff --git a/dwl.c b/dwl.c
index 0deae84..e7d3dea 100644
--- a/dwl.c
+++ b/dwl.c
@@ -26,27 +26,34 @@
 #include <wlr/types/wlr_keyboard.h>
 #include <wlr/types/wlr_matrix.h>
 #include <wlr/types/wlr_output.h>
+#include <wlr/types/wlr_output_damage.h>
 #include <wlr/types/wlr_output_layout.h>
 #include <wlr/types/wlr_output_management_v1.h>
 #include <wlr/types/wlr_pointer.h>
+#include <wlr/types/wlr_presentation_time.h>
 #include <wlr/types/wlr_primary_selection.h>
 #include <wlr/types/wlr_primary_selection_v1.h>
 #include <wlr/types/wlr_screencopy_v1.h>
+#include <wlr/types/wlr_server_decoration.h>
 #include <wlr/types/wlr_seat.h>
 #include <wlr/types/wlr_viewporter.h>
 #include <wlr/types/wlr_virtual_keyboard_v1.h>
 #include <wlr/types/wlr_xcursor_manager.h>
+#include <wlr/types/wlr_xdg_activation_v1.h>
 #include <wlr/types/wlr_xdg_decoration_v1.h>
 #include <wlr/types/wlr_xdg_output_v1.h>
 #include <wlr/types/wlr_xdg_shell.h>
 #include <wlr/backend/libinput.h>
 #include <wlr/util/log.h>
 #include <xkbcommon/xkbcommon.h>
+#include <libguile.h>
+#include "dscm-unstable-v1-protocol.h"
 #ifdef XWAYLAND
 #include <X11/Xlib.h>
 #include <wlr/xwayland.h>
 #endif
 
+
 /* macros */
 #define BARF(fmt, ...)		do { fprintf(stderr, fmt "\n", ##__VA_ARGS__); exit(EXIT_FAILURE); } while (0)
 #define EBARF(fmt, ...)		BARF(fmt ": %s", ##__VA_ARGS__, strerror(errno))
@@ -55,11 +62,12 @@
 #define CLEANMASK(mask)         (mask & ~WLR_MODIFIER_CAPS)
 #define VISIBLEON(C, M)         ((C)->mon == (M) && ((C)->tags & (M)->tagset[(M)->seltags]))
 #define LENGTH(X)               (sizeof X / sizeof X[0])
-#define END(A)                  ((A) + LENGTH(A))
-#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
 #define ROUND(X)                ((int)((X)+0.5))
 #define LISTEN(E, L, H)         wl_signal_add((E), ((L)->notify = (H), (L)))
 
+/* constants */
+#define HEXLENGTH                9
+
 /* enums */
 enum { CurNormal, CurMove, CurResize }; /* cursor */
 #ifdef XWAYLAND
@@ -72,14 +80,13 @@ typedef union {
 	int i;
 	unsigned int ui;
 	float f;
-	const void *v;
+	void *v;
 } Arg;
 
 typedef struct {
 	unsigned int mod;
 	unsigned int button;
-	void (*func)(const Arg *);
-	const Arg arg;
+        scm_t_bits *func;
 } Button;
 
 typedef struct Monitor Monitor;
@@ -92,9 +99,11 @@ typedef struct {
 		struct wlr_xwayland_surface *xwayland;
 	} surface;
 	struct wl_listener commit;
+	struct wl_listener new_sub;
 	struct wl_listener map;
 	struct wl_listener unmap;
 	struct wl_listener destroy;
+	struct wl_listener set_title;
 	struct wl_listener fullscreen;
 	struct wlr_box geom;  /* layout-relative, includes border */
 	Monitor *mon;
@@ -105,7 +114,9 @@ typedef struct {
 #endif
 	int bw;
 	unsigned int tags;
-	int isfloating;
+	int isfloating, isurgent;
+	double alpha;
+	double prevalpha;
 	uint32_t resize; /* configure serial of a pending resize */
 	int prevx;
 	int prevy;
@@ -114,6 +125,16 @@ typedef struct {
 	int isfullscreen;
 } Client;
 
+typedef struct {
+	struct wl_list link;
+	struct wl_listener commit;
+	struct wl_listener map;
+	struct wl_listener unmap;
+	struct wl_listener destroy;
+	struct wlr_subsurface *subsurface;
+	Client *c;
+} Subsurface;
+
 typedef struct {
 	struct wl_listener request_mode;
 	struct wl_listener destroy;
@@ -121,9 +142,8 @@ typedef struct {
 
 typedef struct {
 	uint32_t mod;
-	xkb_keysym_t keysym;
-	void (*func)(const Arg *);
-	const Arg arg;
+	xkb_keycode_t keycode;
+        scm_t_bits *func;
 } Key;
 
 typedef struct {
@@ -146,6 +166,7 @@ typedef struct {
 
 	struct wlr_box geo;
 	enum zwlr_layer_shell_v1_layer layer;
+	Monitor *mon;
 } LayerSurface;
 
 typedef struct {
@@ -157,10 +178,22 @@ typedef struct {
 } Edge;
 
 typedef struct {
-	const char *symbol;
-	void (*arrange)(Monitor *);
+	char *symbol;
+        scm_t_bits *arrange;
+        char *id;
 } Layout;
 
+typedef struct {
+	struct wl_list link;
+	struct wl_resource *resource;
+} DscmClient;
+
+typedef struct {
+	struct wl_list link;
+	struct wl_resource *resource;
+	struct Monitor *monitor;
+} DscmMonitor;
+
 struct Monitor {
 	struct wl_list link;
 	struct wlr_output *wlr_output;
@@ -169,16 +202,23 @@ struct Monitor {
 	struct wlr_box m;      /* monitor area, layout-relative */
 	struct wlr_box w;      /* window area, layout-relative */
 	struct wl_list layers[4]; // LayerSurface::link
+	struct wl_list dscm;
 	const Layout *lt[2];
+	int gappih;           /* horizontal gap between windows */
+	int gappiv;           /* vertical gap between windows */
+	int gappoh;           /* horizontal outer gaps */
+	int gappov;           /* vertical outer gaps */
 	unsigned int seltags;
 	unsigned int sellt;
 	unsigned int tagset[2];
+        unsigned int prevtagset;
 	double mfact;
 	int nmaster;
+	struct wlr_output_damage *damage;
 };
 
 typedef struct {
-	const char *name;
+	char *name;
 	float mfact;
 	int nmaster;
 	float scale;
@@ -189,10 +229,11 @@ typedef struct {
 } MonitorRule;
 
 typedef struct {
-	const char *id;
-	const char *title;
+	char *id;
+	char *title;
 	unsigned int tags;
 	int isfloating;
+	double alpha;
 	int monitor;
 } Rule;
 
@@ -202,8 +243,25 @@ struct render_data {
 	struct wlr_output *output;
 	struct timespec *when;
 	int x, y; /* layout-relative */
+	double alpha;
 };
 
+/* dscm protocol */
+static void dscm_sendevents(void);
+static void dscm_sendeventsclient(DscmClient *c);
+static void dscm_rgbatostr(char *buf, float *color);
+static void dscm_closemon(struct wl_client *client, struct wl_resource *resource);
+static void dscm_destroymon(struct wl_resource *resource);
+static void dscm_printstatusmon(Monitor *m, const DscmMonitor *mon);
+static void dscm_printstatus(Monitor *m);
+static void dscm_settags(struct wl_client *client, struct wl_resource *resource, uint32_t t, uint32_t toggle_tagset);
+static void dscm_setlayout(struct wl_client *client, struct wl_resource *resource, uint32_t layout);
+static void dscm_setclient(struct wl_client *client, struct wl_resource *resource, uint32_t and, uint32_t xor);
+static void dscm_release(struct wl_client *client, struct wl_resource *resource);
+static void dscm_getmon(struct wl_client *client, struct wl_resource *resource, uint32_t id, struct wl_resource *output);
+static void dscm_destroy(struct wl_resource *resource);
+static void dscm_bind(struct wl_client *client, void *data, uint32_t version, uint32_t id);
+
 /* function declarations */
 static void applybounds(Client *c, struct wlr_box *bbox);
 static void applyexclusive(struct wlr_box *usable_area, uint32_t anchor,
@@ -216,6 +274,7 @@ static void arrangelayer(Monitor *m, struct wl_list *list,
 static void arrangelayers(Monitor *m);
 static void axisnotify(struct wl_listener *listener, void *data);
 static void buttonpress(struct wl_listener *listener, void *data);
+static void changealpha(const Arg *arg);
 static void chvt(const Arg *arg);
 static void cleanup(void);
 static void cleanupkeyboard(struct wl_listener *listener, void *data);
@@ -223,36 +282,38 @@ static void cleanupmon(struct wl_listener *listener, void *data);
 static void closemon(Monitor *m);
 static void commitlayersurfacenotify(struct wl_listener *listener, void *data);
 static void commitnotify(struct wl_listener *listener, void *data);
+static void commitnotify_sub(struct wl_listener *listener, void *data);
 static void createkeyboard(struct wlr_input_device *device);
 static void createmon(struct wl_listener *listener, void *data);
 static void createnotify(struct wl_listener *listener, void *data);
 static void createlayersurface(struct wl_listener *listener, void *data);
 static void createpointer(struct wlr_input_device *device);
-static void createxdeco(struct wl_listener *listener, void *data);
 static void cursorframe(struct wl_listener *listener, void *data);
+static void cyclelayout(const Arg *arg);
 static void destroylayersurfacenotify(struct wl_listener *listener, void *data);
 static void destroynotify(struct wl_listener *listener, void *data);
-static void destroyxdeco(struct wl_listener *listener, void *data);
+static void destroynotify_sub(struct wl_listener *listener, void *data);
 static Monitor *dirtomon(enum wlr_direction dir);
 static void focusclient(Client *c, int lift);
 static void focusmon(const Arg *arg);
 static void focusstack(const Arg *arg);
 static void fullscreennotify(struct wl_listener *listener, void *data);
 static Client *focustop(Monitor *m);
-static void getxdecomode(struct wl_listener *listener, void *data);
 static void incnmaster(const Arg *arg);
 static void inputdevice(struct wl_listener *listener, void *data);
-static int keybinding(uint32_t mods, xkb_keysym_t sym);
+static int keybinding(uint32_t mods, xkb_keycode_t keycode);
 static void keypress(struct wl_listener *listener, void *data);
 static void keypressmod(struct wl_listener *listener, void *data);
 static void killclient(const Arg *arg);
 static void maplayersurfacenotify(struct wl_listener *listener, void *data);
 static void mapnotify(struct wl_listener *listener, void *data);
+static void mapnotify_sub(struct wl_listener *listener, void *data);
 static void monocle(Monitor *m);
 static void motionabsolute(struct wl_listener *listener, void *data);
 static void motionnotify(uint32_t time);
 static void motionrelative(struct wl_listener *listener, void *data);
 static void moveresize(const Arg *arg);
+static void new_subnotify(struct wl_listener *listener, void *data);
 static void outputmgrapply(struct wl_listener *listener, void *data);
 static void outputmgrapplyortest(struct wlr_output_configuration_v1 *config, int test);
 static void outputmgrtest(struct wl_listener *listener, void *data);
@@ -260,6 +321,7 @@ static void pointerfocus(Client *c, struct wlr_surface *surface,
 		double sx, double sy, uint32_t time);
 static void printstatus(void);
 static void quit(const Arg *arg);
+static void quitsignal(int signo);
 static void render(struct wlr_surface *surface, int sx, int sy, void *data);
 static void renderclients(Monitor *m, struct timespec *now);
 static void renderlayer(struct wl_list *layer_surfaces, struct timespec *now);
@@ -276,7 +338,7 @@ static void setfullscreen(Client *c, int fullscreen);
 static void setlayout(const Arg *arg);
 static void setmfact(const Arg *arg);
 static void setmon(Client *c, Monitor *m, unsigned int newtags);
-static void setup(void);
+static void setup(char* config_file);
 static void sigchld(int unused);
 static void spawn(const Arg *arg);
 static void tag(const Arg *arg);
@@ -289,14 +351,31 @@ static void toggleview(const Arg *arg);
 static void unmaplayersurface(LayerSurface *layersurface);
 static void unmaplayersurfacenotify(struct wl_listener *listener, void *data);
 static void unmapnotify(struct wl_listener *listener, void *data);
+static void unmapnotify_sub(struct wl_listener *listener, void *data);
 static void updatemons(struct wl_listener *listener, void *data);
+static void updatetitle(struct wl_listener *listener, void *data);
+static void urgent(struct wl_listener *listener, void *data);
 static void view(const Arg *arg);
+static void viewprev(const Arg *arg);
 static void virtualkeyboard(struct wl_listener *listener, void *data);
 static Client *xytoclient(double x, double y);
 static struct wlr_surface *xytolayersurface(struct wl_list *layer_surfaces,
 		double x, double y, double *sx, double *sy);
 static Monitor *xytomon(double x, double y);
 static void zoom(const Arg *arg);
+static void setgaps(int oh, int ov, int ih, int iv);
+static void incrgaps(const Arg *arg);
+static void incrigaps(const Arg *arg);
+static void incrogaps(const Arg *arg);
+static void incrohgaps(const Arg *arg);
+static void incrovgaps(const Arg *arg);
+static void incrihgaps(const Arg *arg);
+static void incrivgaps(const Arg *arg);
+static void togglegaps(const Arg *arg);
+static void defaultgaps(const Arg *arg);
+
+/* signal actions */
+static int reloadconfig(int signal, void *data);
 
 /* variables */
 static const char broken[] = "broken";
@@ -306,22 +385,21 @@ static struct wlr_renderer *drw;
 static struct wlr_compositor *compositor;
 
 static struct wlr_xdg_shell *xdg_shell;
+static struct wlr_xdg_activation_v1 *activation;
 static struct wl_list clients; /* tiling order */
 static struct wl_list fstack;  /* focus order */
 static struct wl_list stack;   /* stacking z-order */
 static struct wl_list independents;
+static struct wl_list subsurfaces;
+static struct wl_list dscm_clients;
 static struct wlr_idle *idle;
 static struct wlr_layer_shell_v1 *layer_shell;
-static struct wlr_xdg_decoration_manager_v1 *xdeco_mgr;
 static struct wlr_output_manager_v1 *output_mgr;
+static struct wlr_presentation *presentation;
 static struct wlr_virtual_keyboard_manager_v1 *virtual_keyboard_mgr;
 
 static struct wlr_cursor *cursor;
 static struct wlr_xcursor_manager *cursor_mgr;
-#ifdef XWAYLAND
-static struct wlr_xcursor *xcursor;
-static struct wlr_xcursor_manager *xcursor_mgr;
-#endif
 
 static struct wlr_seat *seat;
 static struct wl_list keyboards;
@@ -334,6 +412,8 @@ static struct wlr_box sgeom;
 static struct wl_list mons;
 static Monitor *selmon;
 
+static int enablegaps = 1;   /* enables gaps, used by togglegaps */
+
 /* global event handlers */
 static struct wl_listener cursor_axis = {.notify = axisnotify};
 static struct wl_listener cursor_button = {.notify = buttonpress};
@@ -344,20 +424,34 @@ static struct wl_listener layout_change = {.notify = updatemons};
 static struct wl_listener new_input = {.notify = inputdevice};
 static struct wl_listener new_virtual_keyboard = {.notify = virtualkeyboard};
 static struct wl_listener new_output = {.notify = createmon};
-static struct wl_listener new_xdeco = {.notify = createxdeco};
 static struct wl_listener new_xdg_surface = {.notify = createnotify};
 static struct wl_listener new_layer_shell_surface = {.notify = createlayersurface};
 static struct wl_listener output_mgr_apply = {.notify = outputmgrapply};
 static struct wl_listener output_mgr_test = {.notify = outputmgrtest};
+static struct wl_listener request_activate = {.notify = urgent};
 static struct wl_listener request_cursor = {.notify = setcursor};
 static struct wl_listener request_set_psel = {.notify = setpsel};
 static struct wl_listener request_set_sel = {.notify = setsel};
 
+/* dscm event handlers */
+static struct dscm_monitor_v1_interface dscm_monitor_implementation = {
+	.release = dscm_closemon,
+	.set_tags = dscm_settags,
+	.set_layout = dscm_setlayout,
+	.set_client_tags = dscm_setclient,
+};
+static struct dscm_v1_interface dscm_implementation = {
+	.release = dscm_release,
+	.get_monitor = dscm_getmon,
+};
+
 #ifdef XWAYLAND
 static void activatex11(struct wl_listener *listener, void *data);
 static void configurex11(struct wl_listener *listener, void *data);
 static void createnotifyx11(struct wl_listener *listener, void *data);
+void commitnotifyx11(struct wl_listener *listener, void *data);
 static Atom getatom(xcb_connection_t *xc, const char *name);
+static void mapnotify_unmanaged(struct wl_listener *listener, void *data);
 static void renderindependents(struct wlr_output *output, struct timespec *now);
 static void xwaylandready(struct wl_listener *listener, void *data);
 static Client *xytoindependent(double x, double y);
@@ -367,14 +461,13 @@ static struct wlr_xwayland *xwayland;
 static Atom netatom[NetLast];
 #endif
 
-/* configuration, allows nested code to access above variables */
-#include "config.h"
-
 /* attempt to encapsulate suck into one file */
 #include "client.h"
 
-/* compile-time check if all tags fit into an unsigned int bit array. */
-struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
+/* include guile config and bindings */
+#include "dscm-utils.h"
+#include "dscm-config.h"
+#include "dscm-bindings.h"
 
 /* function implementations */
 void
@@ -398,7 +491,8 @@ void
 applyexclusive(struct wlr_box *usable_area,
 		uint32_t anchor, int32_t exclusive,
 		int32_t margin_top, int32_t margin_right,
-		int32_t margin_bottom, int32_t margin_left) {
+		int32_t margin_bottom, int32_t margin_left)
+{
 	Edge edges[] = {
 		{ // Top
 			.singular_anchor = ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP,
@@ -454,8 +548,8 @@ applyrules(Client *c)
 {
 	/* rule matching */
 	const char *appid, *title;
-	unsigned int i, newtags = 0;
-	const Rule *r;
+	unsigned int j, newtags = 0;
+	Rule r;
 	Monitor *mon = selmon, *m;
 
 	c->isfloating = client_is_float_type(c);
@@ -464,32 +558,36 @@ applyrules(Client *c)
 	if (!(title = client_get_title(c)))
 		title = broken;
 
-	for (r = rules; r < END(rules); r++) {
-		if ((!r->title || strstr(title, r->title))
-				&& (!r->id || strstr(appid, r->id))) {
-			c->isfloating = r->isfloating;
-			newtags |= r->tags;
-			i = 0;
+        for (int i = 0; i < numrules; i++) {
+                r = rules[i];
+		if ((!r.title || strstr(title, r.title))
+				&& (!r.id || strstr(appid, r.id))) {
+			c->isfloating = r.isfloating;
+                        c->alpha = r.alpha;
+			newtags |= r.tags;
+			j = 0;
 			wl_list_for_each(m, &mons, link)
-				if (r->monitor == i++)
+				if (r.monitor == j++)
 					mon = m;
 		}
 	}
+	wl_list_insert(c->isfloating ? &stack : stack.prev, &c->slink);
 	setmon(c, mon, newtags);
 }
 
 void
 arrange(Monitor *m)
 {
-	if (m->lt[m->sellt]->arrange)
-		m->lt[m->sellt]->arrange(m);
+        if (m->lt[m->sellt]->arrange)
+                dscm_safe_call(DSCM_CALL_ARRANGE, m->lt[m->sellt]->arrange, m);
 	/* TODO recheck pointer focus here... or in resize()? */
+	wlr_output_damage_add_whole(m->damage);
 }
 
 void
 arrangelayer(Monitor *m, struct wl_list *list, struct wlr_box *usable_area, int exclusive)
 {
-	LayerSurface *layersurface;
+        LayerSurface *layersurface;
 	struct wlr_box full_area = m->m;
 
 	wl_list_for_each(layersurface, list, link) {
@@ -635,7 +733,7 @@ buttonpress(struct wl_listener *listener, void *data)
 	struct wlr_keyboard *keyboard;
 	uint32_t mods;
 	Client *c;
-	const Button *b;
+	Button b;
 
 	wlr_idle_notify_activity(idle, seat);
 
@@ -647,10 +745,11 @@ buttonpress(struct wl_listener *listener, void *data)
 
 		keyboard = wlr_seat_get_keyboard(seat);
 		mods = wlr_keyboard_get_modifiers(keyboard);
-		for (b = buttons; b < END(buttons); b++) {
-			if (CLEANMASK(mods) == CLEANMASK(b->mod) &&
-					event->button == b->button && b->func) {
-				b->func(&b->arg);
+                for (int i = 0; i < numbuttons; i++) {
+                        b = buttons[i];
+			if (CLEANMASK(mods) == CLEANMASK(b.mod) &&
+					event->button == b.button && b.func) {
+                                dscm_safe_call(DSCM_CALL_ACTION, b.func, NULL);
 				return;
 			}
 		}
@@ -675,6 +774,21 @@ buttonpress(struct wl_listener *listener, void *data)
 			event->time_msec, event->button, event->state);
 }
 
+void
+changealpha(const Arg *arg)
+{
+	Client *sel = selclient();
+
+	if (sel) {
+		sel->alpha += arg->f;
+		if (sel->alpha > 1.0)
+			sel->alpha = 1.0;
+
+		if (sel->alpha < 0.1)
+			sel->alpha = 0.1;
+	}
+}
+
 void
 chvt(const Arg *arg)
 {
@@ -714,6 +828,7 @@ void
 cleanupmon(struct wl_listener *listener, void *data)
 {
 	struct wlr_output *wlr_output = data;
+	DscmMonitor *mon, *montmp;
 	Monitor *m = wlr_output->data;
 	int nmons, i = 0;
 
@@ -721,11 +836,18 @@ cleanupmon(struct wl_listener *listener, void *data)
 	wl_list_remove(&m->frame.link);
 	wl_list_remove(&m->link);
 	wlr_output_layout_remove(output_layout, m->wlr_output);
+	wl_list_for_each_safe(mon, montmp, &m->dscm, link) {
+		wl_resource_set_user_data(mon->resource, NULL);
+		free(mon);
+	}
+
+        // Fix crash when disconnecting the last monitor
+        if ((nmons = wl_list_length(&mons))) {
+                do // don't switch to disabled mons
+                        selmon = wl_container_of(mons.prev, selmon, link);
+                while (!selmon->wlr_output->enabled && i++ < nmons);
+        }
 
-	nmons = wl_list_length(&mons);
-	do // don't switch to disabled mons
-		selmon = wl_container_of(mons.prev, selmon, link);
-	while (!selmon->wlr_output->enabled && i++ < nmons);
 	focusclient(focustop(selmon), 1);
 	closemon(m);
 	free(m);
@@ -766,6 +888,9 @@ commitlayersurfacenotify(struct wl_listener *listener, void *data)
 			&layersurface->link);
 		layersurface->layer = wlr_layer_surface->current.layer;
 	}
+
+	// Damage the whole screen
+	wlr_output_damage_add_whole(m->damage);
 }
 
 void
@@ -776,6 +901,18 @@ commitnotify(struct wl_listener *listener, void *data)
 	/* mark a pending resize as completed */
 	if (c->resize && c->resize <= c->surface.xdg->configure_serial)
 		c->resize = 0;
+
+	// Damage the whole screen
+	if (c->mon)
+		wlr_output_damage_add_whole(c->mon->damage);
+}
+
+void
+commitnotify_sub(struct wl_listener *listener, void *data)
+{
+	Subsurface *s = wl_container_of(listener, s, commit);
+	if (s->c->mon)
+		wlr_output_damage_add_whole(s->c->mon->damage);
 }
 
 void
@@ -788,7 +925,7 @@ createkeyboard(struct wlr_input_device *device)
 
 	/* Prepare an XKB keymap and assign it to the keyboard. */
 	context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
-	keymap = xkb_map_new_from_names(context, &xkb_rules,
+	keymap = xkb_keymap_new_from_names(context, xkb_rules,
 		XKB_KEYMAP_COMPILE_NO_FLAGS);
 
 	wlr_keyboard_set_keymap(device->keyboard, keymap);
@@ -813,22 +950,29 @@ createmon(struct wl_listener *listener, void *data)
 	/* This event is raised by the backend when a new output (aka a display or
 	 * monitor) becomes available. */
 	struct wlr_output *wlr_output = data;
-	const MonitorRule *r;
+	MonitorRule r;
 	Monitor *m = wlr_output->data = calloc(1, sizeof(*m));
+	wl_list_init(&m->dscm);
 	m->wlr_output = wlr_output;
+	m->gappih = gappih;
+	m->gappiv = gappiv;
+	m->gappoh = gappoh;
+	m->gappov = gappov;
 
 	/* Initialize monitor state using configured rules */
 	for (size_t i = 0; i < LENGTH(m->layers); i++)
 		wl_list_init(&m->layers[i]);
+	m->damage = wlr_output_damage_create(wlr_output);
 	m->tagset[0] = m->tagset[1] = 1;
-	for (r = monrules; r < END(monrules); r++) {
-		if (!r->name || strstr(wlr_output->name, r->name)) {
-			m->mfact = r->mfact;
-			m->nmaster = r->nmaster;
-			wlr_output_set_scale(wlr_output, r->scale);
-			wlr_xcursor_manager_load(cursor_mgr, r->scale);
-			m->lt[0] = m->lt[1] = r->lt;
-			wlr_output_set_transform(wlr_output, r->rr);
+        for (int i = 0; i < nummonrules; i++) {
+                r = monrules[i];
+		if (!r.name || strstr(wlr_output->name, r.name)) {
+			m->mfact = r.mfact;
+			m->nmaster = r.nmaster;
+			wlr_output_set_scale(wlr_output, r.scale);
+			wlr_xcursor_manager_load(cursor_mgr, r.scale);
+			m->lt[0] = m->lt[1] = r.lt;
+			wlr_output_set_transform(wlr_output, r.rr);
 			break;
 		}
 	}
@@ -844,18 +988,20 @@ createmon(struct wl_listener *listener, void *data)
 	LISTEN(&wlr_output->events.frame, &m->frame, rendermon);
 	LISTEN(&wlr_output->events.destroy, &m->destroy, cleanupmon);
 
-	wl_list_insert(&mons, &m->link);
 	wlr_output_enable(wlr_output, 1);
 	if (!wlr_output_commit(wlr_output))
 		return;
 
+	wl_list_insert(&mons, &m->link);
+	printstatus();
+
 	/* Adds this to the output layout in the order it was configured in.
 	 *
 	 * The output layout utility automatically adds a wl_output global to the
 	 * display, which Wayland clients can see to find out information about the
 	 * output (such as DPI, scale factor, manufacturer, etc).
 	 */
-	wlr_output_layout_add(output_layout, wlr_output, r->x, r->y);
+	wlr_output_layout_add(output_layout, wlr_output, r.x, r.y);
 	sgeom = *wlr_output_layout_get_box(output_layout, NULL);
 
 	/* When adding monitors, the geometries of all monitors must be updated */
@@ -879,22 +1025,32 @@ createnotify(struct wl_listener *listener, void *data)
 	struct wlr_xdg_surface *xdg_surface = data;
 	Client *c;
 
-	if (xdg_surface->role != WLR_XDG_SURFACE_ROLE_TOPLEVEL)
+	if (xdg_surface->role != WLR_XDG_SURFACE_ROLE_TOPLEVEL) {
+                c = selclient();
+                if (c) {
+                        struct wlr_box constraint = {
+                                .x = 0,
+                                .y = 0,
+                                .width = c->geom.width,
+                                .height = c->geom.height,
+                        };
+                        wlr_xdg_popup_unconstrain_from_box(xdg_surface->popup, &constraint);
+                }
 		return;
+        }
 
 	/* Allocate a Client for this surface */
 	c = xdg_surface->data = calloc(1, sizeof(*c));
 	c->surface.xdg = xdg_surface;
 	c->bw = borderpx;
+	c->alpha = default_alpha;
 
-	/* Tell the client not to try anything fancy */
-	wlr_xdg_toplevel_set_tiled(c->surface.xdg, WLR_EDGE_TOP |
-			WLR_EDGE_BOTTOM | WLR_EDGE_LEFT | WLR_EDGE_RIGHT);
-
-	LISTEN(&xdg_surface->surface->events.commit, &c->commit, commitnotify);
+	/* LISTEN(&xdg_surface->surface->events.commit, &c->commit, commitnotify); */
+	LISTEN(&xdg_surface->surface->events.new_subsurface, &c->new_sub, new_subnotify);
 	LISTEN(&xdg_surface->events.map, &c->map, mapnotify);
 	LISTEN(&xdg_surface->events.unmap, &c->unmap, unmapnotify);
 	LISTEN(&xdg_surface->events.destroy, &c->destroy, destroynotify);
+	LISTEN(&xdg_surface->toplevel->events.set_title, &c->set_title, updatetitle);
 	LISTEN(&xdg_surface->toplevel->events.request_fullscreen, &c->fullscreen,
 			fullscreennotify);
 	c->isfullscreen = 0;
@@ -958,18 +1114,6 @@ createpointer(struct wlr_input_device *device)
 	wlr_cursor_attach_input_device(cursor, device);
 }
 
-void
-createxdeco(struct wl_listener *listener, void *data)
-{
-	struct wlr_xdg_toplevel_decoration_v1 *wlr_deco = data;
-	Decoration *d = wlr_deco->data = calloc(1, sizeof(*d));
-
-	LISTEN(&wlr_deco->events.request_mode, &d->request_mode, getxdecomode);
-	LISTEN(&wlr_deco->events.destroy, &d->destroy, destroyxdeco);
-
-	getxdecomode(&d->request_mode, wlr_deco);
-}
-
 void
 cursorframe(struct wl_listener *listener, void *data)
 {
@@ -981,6 +1125,25 @@ cursorframe(struct wl_listener *listener, void *data)
 	wlr_seat_pointer_notify_frame(seat);
 }
 
+void
+cyclelayout(const Arg *arg)
+{
+	Layout *l;
+        unsigned int index = 0;
+	for (l = (Layout *)layouts; l != selmon->lt[selmon->sellt]; l++, index++);
+        if (arg->i > 0) {
+            if (index < (numlayouts - 1))
+                    setlayout(&((Arg) {.v = (l + 1)}));
+            else
+                    setlayout(&((Arg) {.v = layouts}));
+        } else {
+            if (index > 0)
+                    setlayout(&((Arg) {.v = (l - 1)}));
+            else
+                    setlayout(&((Arg) {.v = &layouts[numlayouts - 1]}));
+        }
+}
+
 void
 destroylayersurfacenotify(struct wl_listener *listener, void *data)
 {
@@ -995,8 +1158,10 @@ destroylayersurfacenotify(struct wl_listener *listener, void *data)
 	wl_list_remove(&layersurface->surface_commit.link);
 	if (layersurface->layer_surface->output) {
 		Monitor *m = layersurface->layer_surface->output->data;
-		if (m)
+		if (m) {
 			arrangelayers(m);
+			wlr_output_damage_add_whole(m->damage);
+		}
 		layersurface->layer_surface->output = NULL;
 	}
 	free(layersurface);
@@ -1007,28 +1172,40 @@ destroynotify(struct wl_listener *listener, void *data)
 {
 	/* Called when the surface is destroyed and should never be shown again. */
 	Client *c = wl_container_of(listener, c, destroy);
+
+	// Damage the whole screen
+	if (c->mon)
+		wlr_output_damage_add_whole(c->mon->damage);
+
 	wl_list_remove(&c->map.link);
 	wl_list_remove(&c->unmap.link);
 	wl_list_remove(&c->destroy.link);
-	wl_list_remove(&c->fullscreen.link);
+	if (client_is_unmanaged(c)) {
 #ifdef XWAYLAND
-	if (c->type == X11Managed)
+		wl_list_remove(&c->configure.link);
+		free(c);
+		return;
+	} else if (c->type == X11Managed) {
 		wl_list_remove(&c->activate.link);
-	else if (c->type == XDGShell)
+		wl_list_remove(&c->configure.link);
 #endif
+	} else {
 		wl_list_remove(&c->commit.link);
+	}
+	wl_list_remove(&c->set_title.link);
+	wl_list_remove(&c->fullscreen.link);
 	free(c);
 }
 
 void
-destroyxdeco(struct wl_listener *listener, void *data)
+destroynotify_sub(struct wl_listener *listener, void *data)
 {
-	struct wlr_xdg_toplevel_decoration_v1 *wlr_deco = data;
-	Decoration *d = wlr_deco->data;
-
-	wl_list_remove(&d->destroy.link);
-	wl_list_remove(&d->request_mode.link);
-	free(d);
+	Subsurface *s = wl_container_of(listener, s, destroy);
+	wl_list_remove(&s->commit.link);
+	wl_list_remove(&s->map.link);
+	wl_list_remove(&s->unmap.link);
+	wl_list_remove(&s->destroy.link);
+	free(s);
 }
 
 void
@@ -1051,11 +1228,21 @@ setfullscreen(Client *c, int fullscreen)
 		c->prevy = c->geom.y;
 		c->prevheight = c->geom.height;
 		c->prevwidth = c->geom.width;
+                c->prevalpha = c->alpha;
+                c->alpha = 1;
 		resize(c, c->mon->m.x, c->mon->m.y, c->mon->m.width, c->mon->m.height, 0);
+		wl_list_remove(&c->slink);
+		wl_list_insert(&stack, &c->slink);
+		motionnotify(0);
 	} else {
 		/* restore previous size instead of arrange for floating windows since
 		 * client positions are set by the user and cannot be recalculated */
+                c->alpha = c->prevalpha;
 		resize(c, c->prevx, c->prevy, c->prevwidth, c->prevheight, 0);
+		if (!c->isfloating) {
+			wl_list_remove(&c->slink);
+			wl_list_insert(stack.prev, &c->slink);
+		}
 		arrange(c->mon);
 	}
 }
@@ -1064,7 +1251,13 @@ void
 fullscreennotify(struct wl_listener *listener, void *data)
 {
 	Client *c = wl_container_of(listener, c, fullscreen);
-	setfullscreen(c, !c->isfullscreen);
+        struct wlr_xdg_toplevel_set_fullscreen_event *event = data;
+	if (!c->mon) {
+		/* if the client is not mapped yet, let mapnotify() call setfullscreen() */
+		c->isfullscreen = event->fullscreen;
+		return;
+	}
+	setfullscreen(c, event->fullscreen);
 }
 
 Monitor *
@@ -1088,7 +1281,7 @@ focusclient(Client *c, int lift)
 	struct wlr_keyboard *kb;
 
 	/* Raise client in stacking order if requested */
-	if (c && lift) {
+        if (c && lift && (c->isfloating || c->isfullscreen)) {
 		wl_list_remove(&c->slink);
 		wl_list_insert(&stack, &c->slink);
 	}
@@ -1101,8 +1294,8 @@ focusclient(Client *c, int lift)
 		wl_list_remove(&c->flink);
 		wl_list_insert(&fstack, &c->flink);
 		selmon = c->mon;
+		c->isurgent = 0;
 	}
-	printstatus();
 
 	/* Deactivate old client if focus is changing */
 	if (old && (!c || client_surface(c) != old)) {
@@ -1125,6 +1318,8 @@ focusclient(Client *c, int lift)
 		}
 	}
 
+	printstatus();
+
 	if (!c) {
 		/* With no client, all we have left is to clear focus */
 		wlr_seat_keyboard_notify_clear_focus(seat);
@@ -1154,7 +1349,7 @@ focusstack(const Arg *arg)
 {
 	/* Focus the next or previous client (in tiling order) on selmon */
 	Client *c, *sel = selclient();
-	if (!sel)
+	if (!sel || sel->isfullscreen)
 		return;
 	if (arg->i > 0) {
 		wl_list_for_each(c, &sel->link, link) {
@@ -1185,14 +1380,6 @@ focustop(Monitor *m)
 	return NULL;
 }
 
-void
-getxdecomode(struct wl_listener *listener, void *data)
-{
-	struct wlr_xdg_toplevel_decoration_v1 *wlr_deco = data;
-	wlr_xdg_toplevel_decoration_v1_set_mode(wlr_deco,
-			WLR_XDG_TOPLEVEL_DECORATION_V1_MODE_SERVER_SIDE);
-}
-
 void
 incnmaster(const Arg *arg)
 {
@@ -1231,7 +1418,7 @@ inputdevice(struct wl_listener *listener, void *data)
 }
 
 int
-keybinding(uint32_t mods, xkb_keysym_t sym)
+keybinding(uint32_t mods, xkb_keycode_t keycode)
 {
 	/*
 	 * Here we handle compositor keybindings. This is when the compositor is
@@ -1239,32 +1426,27 @@ keybinding(uint32_t mods, xkb_keysym_t sym)
 	 * processing.
 	 */
 	int handled = 0;
-	const Key *k;
-	for (k = keys; k < END(keys); k++) {
-		if (CLEANMASK(mods) == CLEANMASK(k->mod) &&
-				sym == k->keysym && k->func) {
-			k->func(&k->arg);
+	Key k;
+        for (int i = 0; i < numkeys; i++) {
+                k = keys[i];
+		if (CLEANMASK(mods) == CLEANMASK(k.mod) &&
+                                keycode == k.keycode && k.func) {
+			dscm_safe_call(DSCM_CALL_ACTION, k.func, NULL);
 			handled = 1;
 		}
-	}
+        }
 	return handled;
 }
 
 void
 keypress(struct wl_listener *listener, void *data)
 {
-	int i;
 	/* This event is raised when a key is pressed or released. */
 	Keyboard *kb = wl_container_of(listener, kb, key);
 	struct wlr_event_keyboard_key *event = data;
 
 	/* Translate libinput keycode -> xkbcommon */
 	uint32_t keycode = event->keycode + 8;
-	/* Get a list of keysyms based on the keymap for this keyboard */
-	const xkb_keysym_t *syms;
-	int nsyms = xkb_state_key_get_syms(
-			kb->device->keyboard->xkb_state, keycode, &syms);
-
 	int handled = 0;
 	uint32_t mods = wlr_keyboard_get_modifiers(kb->device->keyboard);
 
@@ -1272,8 +1454,7 @@ keypress(struct wl_listener *listener, void *data)
 
 	/* On _press_, attempt to process a compositor keybinding. */
 	if (event->state == WL_KEYBOARD_KEY_STATE_PRESSED)
-		for (i = 0; i < nsyms; i++)
-			handled = keybinding(mods, syms[i]) || handled;
+                handled = keybinding(mods, keycode) || handled;
 
 	if (!handled) {
 		/* Pass unhandled keycodes along to the client. */
@@ -1322,27 +1503,50 @@ void
 mapnotify(struct wl_listener *listener, void *data)
 {
 	/* Called when the surface is mapped, or ready to display on-screen. */
-	Client *c = wl_container_of(listener, c, map);
-
-	if (client_is_unmanaged(c)) {
-		/* Insert this independent into independents lists. */
-		wl_list_insert(&independents, &c->link);
-		return;
-	}
+	Client *c = wl_container_of(listener, c, map), *sel = selclient();
 
 	/* Insert this client into client lists. */
 	wl_list_insert(&clients, &c->link);
 	wl_list_insert(&fstack, &c->flink);
-	wl_list_insert(&stack, &c->slink);
 
 	client_get_geometry(c, &c->geom);
 	c->geom.width += 2 * c->bw;
 	c->geom.height += 2 * c->bw;
 
+	/* Tell the client not to try anything fancy */
+	client_set_tiled(c, WLR_EDGE_TOP | WLR_EDGE_BOTTOM | WLR_EDGE_LEFT | WLR_EDGE_RIGHT);
+
 	/* Set initial monitor, tags, floating status, and focus */
 	applyrules(c);
+
+        if (c->isfullscreen)
+                setfullscreen(c, 1);
+        /* Prevent new clients from stealing focus from fullscreen client
+         * on same monitor. */
+        else if (sel && sel->isfullscreen && VISIBLEON(sel, c->mon))
+                focusclient(sel, 1);
+
+	// Damage the whole screen
+	wlr_output_damage_add_whole(c->mon->damage);
+
+#ifdef XWAYLAND
+	if (c->type != XDGShell)
+		LISTEN(&c->surface.xwayland->surface->events.commit, &c->commit, commitnotifyx11);
+	else
+#endif
+		LISTEN(&c->surface.xdg->surface->events.commit, &c->commit, commitnotify);
 }
 
+void
+mapnotify_sub(struct wl_listener *listener, void *data)
+{
+	Subsurface *s = wl_container_of(listener, s, map);
+	wl_list_insert(&subsurfaces, &s->link);
+	wlr_output_damage_add_whole(s->c->mon->damage);
+	LISTEN(&s->subsurface->surface->events.commit, &s->commit, commitnotify_sub);
+}
+
+
 void
 monocle(Monitor *m)
 {
@@ -1353,6 +1557,13 @@ monocle(Monitor *m)
 			continue;
 		resize(c, m->w.x, m->w.y, m->w.width, m->w.height, 0);
 	}
+
+        /* Lift selected client */
+        c = selclient();
+        if (c) {
+                wl_list_remove(&c->slink);
+                wl_list_insert(&stack, &c->slink);
+        }
 }
 
 void
@@ -1477,6 +1688,19 @@ moveresize(const Arg *arg)
 	}
 }
 
+void
+new_subnotify(struct wl_listener *listener, void *data) {
+	struct wlr_subsurface *subsurface = data;
+	Subsurface *s = subsurface->data = calloc(1, sizeof(*s));
+	s->subsurface = subsurface;
+	s->c = wl_container_of(listener, s->c, new_sub);
+
+	LISTEN(&s->subsurface->events.map, &s->map, mapnotify_sub);
+	LISTEN(&s->subsurface->events.unmap, &s->unmap, unmapnotify_sub);
+	LISTEN(&s->subsurface->events.destroy, &s->destroy, destroynotify_sub);
+}
+
+
 void
 outputmgrapply(struct wl_listener *listener, void *data)
 {
@@ -1581,23 +1805,31 @@ void
 printstatus(void)
 {
 	Monitor *m = NULL;
-	Client *c = NULL;
-	unsigned int activetags;
+	Client *c;
+	unsigned int occ, urg, sel;
 
 	wl_list_for_each(m, &mons, link) {
-		activetags=0;
+		occ = urg = 0;
 		wl_list_for_each(c, &clients, link) {
-			if (c->mon == m)
-				activetags |= c->tags;
+			if (c->mon != m)
+				continue;
+			occ |= c->tags;
+			if (c->isurgent)
+				urg |= c->tags;
 		}
-		if (focustop(m))
+		if ((c = focustop(m))) {
 			printf("%s title %s\n", m->wlr_output->name, client_get_title(focustop(m)));
-		else
+			sel = c->tags;
+		} else {
 			printf("%s title \n", m->wlr_output->name);
+			sel = 0;
+		}
 
 		printf("%s selmon %u\n", m->wlr_output->name, m == selmon);
-		printf("%s tags %u %u\n", m->wlr_output->name, activetags, m->tagset[m->seltags]);
+		printf("%s tags %u %u %u %u\n", m->wlr_output->name, occ, m->tagset[m->seltags],
+				sel, urg);
 		printf("%s layout %s\n", m->wlr_output->name, m->lt[m->sellt]->symbol);
+		dscm_printstatus(m);
 	}
 	fflush(stdout);
 }
@@ -1608,6 +1840,12 @@ quit(const Arg *arg)
 	wl_display_terminate(dpy);
 }
 
+void
+quitsignal(int signo)
+{
+	quit(NULL);
+}
+
 void
 render(struct wlr_surface *surface, int sx, int sy, void *data)
 {
@@ -1659,11 +1897,13 @@ render(struct wlr_surface *surface, int sx, int sy, void *data)
 
 	/* This takes our matrix, the texture, and an alpha, and performs the actual
 	 * rendering on the GPU. */
-	wlr_render_texture_with_matrix(drw, texture, matrix, 1);
+	wlr_render_texture_with_matrix(drw, texture, matrix, rdata->alpha);
 
 	/* This lets the client know that we've displayed that frame and it can
 	 * prepare another one now if it likes. */
 	wlr_surface_send_frame_done(surface, rdata->when);
+
+	wlr_presentation_surface_sampled_on_output(presentation, surface, output);
 }
 
 void
@@ -1714,6 +1954,7 @@ renderclients(Monitor *m, struct timespec *now)
 		rdata.when = now;
 		rdata.x = c->geom.x + c->bw;
 		rdata.y = c->geom.y + c->bw;
+		rdata.alpha = c->alpha;
 		client_for_each_surface(c, render, &rdata);
 	}
 }
@@ -1728,6 +1969,7 @@ renderlayer(struct wl_list *layer_surfaces, struct timespec *now)
 			.when = now,
 			.x = layersurface->geo.x,
 			.y = layersurface->geo.y,
+			.alpha = 1,
 		};
 
 		wlr_surface_for_each_surface(layersurface->layer_surface->surface,
@@ -1739,7 +1981,9 @@ void
 rendermon(struct wl_listener *listener, void *data)
 {
 	Client *c;
-	int render = 1;
+	int render;
+	bool needs_frame;
+	pixman_region32_t damage;
 
 	/* This function is called every time an output is ready to display a frame,
 	 * generally at the output's refresh rate (e.g. 60Hz). */
@@ -1748,45 +1992,51 @@ rendermon(struct wl_listener *listener, void *data)
 	struct timespec now;
 	clock_gettime(CLOCK_MONOTONIC, &now);
 
-	/* Do not render if any XDG clients have an outstanding resize. */
+	/* If there is any XDG client which is awaiting resize, request a new
+	 * frame from that client, and do not render anything new until there
+	 * are no pending resizes remaining. */
 	wl_list_for_each(c, &stack, slink) {
 		if (c->resize) {
 			wlr_surface_send_frame_done(client_surface(c), &now);
-			render = 0;
+			return;
 		}
 	}
 
-	/* wlr_output_attach_render makes the OpenGL context current. */
-	if (!wlr_output_attach_render(m->wlr_output, NULL))
+	/* Do not render if no new frame is needed */
+	pixman_region32_init(&damage);
+	render = wlr_output_damage_attach_render(m->damage, &needs_frame, &damage);
+	pixman_region32_fini(&damage);
+	if (!render || !needs_frame) {
+		/* Rollback is needed because attach_render is double-buffered */
+		wlr_output_rollback(m->wlr_output);
 		return;
+	}
 
-	if (render) {
-		/* Begin the renderer (calls glViewport and some other GL sanity checks) */
-		wlr_renderer_begin(drw, m->wlr_output->width, m->wlr_output->height);
-		wlr_renderer_clear(drw, rootcolor);
+	/* Begin the renderer (calls glViewport and some other GL sanity checks) */
+	wlr_renderer_begin(drw, m->wlr_output->width, m->wlr_output->height);
+	wlr_renderer_clear(drw, rootcolor);
 
-		renderlayer(&m->layers[ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND], &now);
-		renderlayer(&m->layers[ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM], &now);
-		renderclients(m, &now);
+	renderlayer(&m->layers[ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND], &now);
+	renderlayer(&m->layers[ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM], &now);
+	renderclients(m, &now);
 #ifdef XWAYLAND
-		renderindependents(m->wlr_output, &now);
+	renderindependents(m->wlr_output, &now);
 #endif
-		renderlayer(&m->layers[ZWLR_LAYER_SHELL_V1_LAYER_TOP], &now);
-		renderlayer(&m->layers[ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY], &now);
-
-		/* Hardware cursors are rendered by the GPU on a separate plane, and can be
-		 * moved around without re-rendering what's beneath them - which is more
-		 * efficient. However, not all hardware supports hardware cursors. For this
-		 * reason, wlroots provides a software fallback, which we ask it to render
-		 * here. wlr_cursor handles configuring hardware vs software cursors for you,
-		 * and this function is a no-op when hardware cursors are in use. */
-		wlr_output_render_software_cursors(m->wlr_output, NULL);
-
-		/* Conclude rendering and swap the buffers, showing the final frame
-		 * on-screen. */
-		wlr_renderer_end(drw);
-	}
-
+	renderlayer(&m->layers[ZWLR_LAYER_SHELL_V1_LAYER_TOP], &now);
+	renderlayer(&m->layers[ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY], &now);
+
+	/* Hardware cursors are rendered by the GPU on a separate plane, and can be
+	 * moved around without re-rendering what's beneath them - which is more
+	 * efficient. However, not all hardware supports hardware cursors. For this
+	 * reason, wlroots provides a software fallback, which we ask it to render
+	 * here. wlr_cursor handles configuring hardware vs software cursors for you,
+	 * and this function is a no-op when hardware cursors are in use. */
+	wlr_output_render_software_cursors(m->wlr_output, NULL);
+
+	/* Conclude rendering and swap the buffers, showing the final frame
+	 * on-screen. */
+	wlr_renderer_end(drw);
+	wlr_output_set_damage(m->wlr_output, &m->damage->current);
 	wlr_output_commit(m->wlr_output);
 }
 
@@ -1809,6 +2059,16 @@ resize(Client *c, int x, int y, int w, int h, int interact)
 			c->geom.height - 2 * c->bw);
 }
 
+void
+setupsignals() {
+        /* Block real-time signals so that they can be
+         * used as custom user signals. */
+        struct sigaction sa;
+        sa.sa_handler = SIG_IGN;
+        for (int i = SIGRTMIN; i <= SIGRTMAX; i++)
+                sigaction(i, &sa, NULL);
+}
+
 void
 run(char *startup_cmd)
 {
@@ -1818,6 +2078,28 @@ run(char *startup_cmd)
 	const char *socket = wl_display_add_socket_auto(dpy);
 	if (!socket)
 		BARF("startup: display_add_socket_auto");
+	setenv("WAYLAND_DISPLAY", socket, 1);
+
+	/* Now that the socket exists, run the startup command */
+	if (startup_cmd) {
+		int piperw[2];
+		pipe(piperw);
+		startup_pid = fork();
+		if (startup_pid < 0)
+			EBARF("startup: fork");
+		if (startup_pid == 0) {
+			dup2(piperw[0], STDIN_FILENO);
+			close(piperw[1]);
+			execl("/bin/sh", "/bin/sh", "-c", startup_cmd, NULL);
+			EBARF("startup: execl");
+		}
+		dup2(piperw[1], STDOUT_FILENO);
+		close(piperw[0]);
+	}
+
+	/* If nobody is reading the status output, don't terminate */
+	signal(SIGPIPE, SIG_IGN);
+	printstatus();
 
 	/* Start the backend. This will enumerate outputs and inputs, become the DRM
 	 * master, etc */
@@ -1835,21 +2117,6 @@ run(char *startup_cmd)
 	wlr_cursor_warp_closest(cursor, NULL, cursor->x, cursor->y);
 	wlr_xcursor_manager_set_cursor_image(cursor_mgr, "left_ptr", cursor);
 
-	/* Set the WAYLAND_DISPLAY environment variable to our socket and run the
-	 * startup command if requested. */
-	setenv("WAYLAND_DISPLAY", socket, 1);
-
-	if (startup_cmd) {
-		startup_pid = fork();
-		if (startup_pid < 0)
-			EBARF("startup: fork");
-		if (startup_pid == 0) {
-			dup2(STDERR_FILENO, STDOUT_FILENO);
-			execl("/bin/sh", "/bin/sh", "-c", startup_cmd, NULL);
-			EBARF("startup: execl");
-		}
-	}
-
 	/* Run the Wayland event loop. This does not return until you exit the
 	 * compositor. Starting the backend rigged up all of the necessary event
 	 * loop configuration to listen to libinput events, DRM events, generate
@@ -1902,10 +2169,119 @@ setcursor(struct wl_listener *listener, void *data)
 void
 setfloating(Client *c, int floating)
 {
+	if (c->isfloating != floating) {
+		wl_list_remove(&c->slink);
+		wl_list_insert(floating ? &stack : stack.prev, &c->slink);
+	}
 	c->isfloating = floating;
 	arrange(c->mon);
 }
 
+void
+setgaps(int oh, int ov, int ih, int iv)
+{
+	if (oh < 0) oh = 0;
+	if (ov < 0) ov = 0;
+	if (ih < 0) ih = 0;
+	if (iv < 0) iv = 0;
+
+	selmon->gappoh = oh;
+	selmon->gappov = ov;
+	selmon->gappih = ih;
+	selmon->gappiv = iv;
+	arrange(selmon);
+}
+
+void
+togglegaps(const Arg *arg)
+{
+	enablegaps = !enablegaps;
+	arrange(selmon);
+}
+
+void
+defaultgaps(const Arg *arg)
+{
+	setgaps(gappoh, gappov, gappih, gappiv);
+}
+
+void
+incrgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov + arg->i,
+		selmon->gappih + arg->i,
+		selmon->gappiv + arg->i
+	);
+}
+
+void
+incrigaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih + arg->i,
+		selmon->gappiv + arg->i
+	);
+}
+
+void
+incrogaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov + arg->i,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrohgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrovgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov + arg->i,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrihgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih + arg->i,
+		selmon->gappiv
+	);
+}
+
+void
+incrivgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih,
+		selmon->gappiv + arg->i
+	);
+}
+
 void
 setlayout(const Arg *arg)
 {
@@ -1979,15 +2355,45 @@ setsel(struct wl_listener *listener, void *data)
 	wlr_seat_set_selection(seat, event->source, event->serial);
 }
 
+int
+reloadconfig(int signal, void *data) {
+        Client *c;
+        Monitor *m;
+        char *config_file = (char*)data;
+
+        dscm_config_parse(config_file);
+
+        /* Redraw clients */
+        wl_list_for_each(c, &clients, link) {
+                if (c->bw > 0)
+                        c->bw = borderpx;
+                resize(c, c->geom.x, c->geom.y, c->geom.width, c->geom.height, 0);
+        }
+
+        /* Rearrange clients on all monitors */
+        wl_list_for_each(m, &mons, link)
+                arrange(m);
+
+        /* Send events to observing clients, notifying of possible changes */
+        dscm_sendevents();
+
+        return 0;
+}
+
 void
-setup(void)
+setup(char *config_file)
 {
 	/* The Wayland display is managed by libwayland. It handles accepting
 	 * clients from the Unix socket, manging Wayland globals, and so on. */
 	dpy = wl_display_create();
 
-	/* clean up child processes immediately */
+	/* Set up signal handlers */
 	sigchld(0);
+	signal(SIGINT, quitsignal);
+	signal(SIGTERM, quitsignal);
+
+        /* Block user signals so that they can be handled */
+        setupsignals();
 
 	/* The backend is a wlroots feature which abstracts the underlying input and
 	 * output hardware. The autocreate option will choose the most suitable
@@ -2021,6 +2427,10 @@ setup(void)
 	wlr_primary_selection_v1_device_manager_create(dpy);
 	wlr_viewporter_create(dpy);
 
+	/* Initializes the interface used to implement urgency hints */
+	activation = wlr_xdg_activation_v1_create(dpy);
+	wl_signal_add(&activation->events.request_activate, &request_activate);
+
 	/* Creates an output layout, which a wlroots utility for working with an
 	 * arrangement of screens in a physical layout. */
 	output_layout = wlr_output_layout_create();
@@ -2042,6 +2452,8 @@ setup(void)
 	wl_list_init(&fstack);
 	wl_list_init(&stack);
 	wl_list_init(&independents);
+	wl_list_init(&subsurfaces);
+        wl_list_init(&dscm_clients);
 
 	idle = wlr_idle_create(dpy);
 
@@ -2051,9 +2463,11 @@ setup(void)
 	xdg_shell = wlr_xdg_shell_create(dpy);
 	wl_signal_add(&xdg_shell->events.new_surface, &new_xdg_surface);
 
-	/* Use xdg_decoration protocol to negotiate server-side decorations */
-	xdeco_mgr = wlr_xdg_decoration_manager_v1_create(dpy);
-	wl_signal_add(&xdeco_mgr->events.new_toplevel_decoration, &new_xdeco);
+	/* Use decoration protocols to negotiate server-side decorations */
+	wlr_server_decoration_manager_set_default_mode(
+			wlr_server_decoration_manager_create(dpy),
+			WLR_SERVER_DECORATION_MANAGER_MODE_SERVER);
+	wlr_xdg_decoration_manager_v1_create(dpy);
 
 	/*
 	 * Creates a cursor, which is a wlroots utility for tracking the cursor
@@ -2109,6 +2523,15 @@ setup(void)
 	wl_signal_add(&output_mgr->events.apply, &output_mgr_apply);
 	wl_signal_add(&output_mgr->events.test, &output_mgr_test);
 
+        struct wl_event_loop *loop = wl_display_get_event_loop(dpy);
+
+        /* Add handlers for user signals */
+        /* TODO: Add config option for adding custom handlers to signal. */
+        wl_event_loop_add_signal(loop, SIGRTMIN, &reloadconfig, config_file);
+
+	presentation = wlr_presentation_create(dpy, backend);
+	wl_global_create(dpy, &dscm_v1_interface, 1, NULL, dscm_bind);
+
 #ifdef XWAYLAND
 	/*
 	 * Initialise the XWayland X server.
@@ -2119,18 +2542,6 @@ setup(void)
 		wl_signal_add(&xwayland->events.ready, &xwayland_ready);
 		wl_signal_add(&xwayland->events.new_surface, &new_xwayland_surface);
 
-		/*
-		 * Create the XWayland cursor manager at scale 1, setting its default
-		 * pointer to match the rest of dwl.
-		 */
-		xcursor_mgr = wlr_xcursor_manager_create(NULL, 24);
-		wlr_xcursor_manager_load(xcursor_mgr, 1);
-		if ((xcursor = wlr_xcursor_manager_get_xcursor(xcursor_mgr, "left_ptr", 1)))
-			wlr_xwayland_set_cursor(xwayland,
-					xcursor->images[0]->buffer, xcursor->images[0]->width * 4,
-					xcursor->images[0]->width, xcursor->images[0]->height,
-					xcursor->images[0]->hotspot_x, xcursor->images[0]->hotspot_y);
-
 		setenv("DISPLAY", xwayland->display_name, 1);
 	} else {
 		fprintf(stderr, "failed to setup XWayland X server, continuing without it\n");
@@ -2187,7 +2598,7 @@ tagmon(const Arg *arg)
 void
 tile(Monitor *m)
 {
-	unsigned int i, n = 0, h, mw, my, ty;
+	unsigned int i, n = 0, h, r, oe = enablegaps, ie = enablegaps, mw, my, ty;
 	Client *c;
 
 	wl_list_for_each(c, &clients, link)
@@ -2196,22 +2607,29 @@ tile(Monitor *m)
 	if (n == 0)
 		return;
 
+	if (smartgaps == n) {
+		oe = 0; // outer gaps disabled
+	}
+
 	if (n > m->nmaster)
-		mw = m->nmaster ? m->w.width * m->mfact : 0;
+		mw = m->nmaster ? (m->w.width + m->gappiv*ie) * m->mfact : 0;
 	else
-		mw = m->w.width;
-	i = my = ty = 0;
+		mw = m->w.width - 2*m->gappov*oe + m->gappiv*ie;
+	i = 0;
+	my = ty = m->gappoh*oe;
 	wl_list_for_each(c, &clients, link) {
 		if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
 			continue;
 		if (i < m->nmaster) {
-			h = (m->w.height - my) / (MIN(n, m->nmaster) - i);
-			resize(c, m->w.x, m->w.y + my, mw, h, 0);
-			my += c->geom.height;
+			r = MIN(n, m->nmaster) - i;
+			h = (m->w.height - my - m->gappoh*oe - m->gappih*ie * (r - 1)) / r;
+			resize(c, m->w.x + m->gappov*oe, m->w.y + my, mw - m->gappiv*ie, h, 0);
+			my += c->geom.height + m->gappih*ie;
 		} else {
-			h = (m->w.height - ty) / (n - i);
-			resize(c, m->w.x + mw, m->w.y + ty, m->w.width - mw, h, 0);
-			ty += c->geom.height;
+			r = n - i;
+			h = (m->w.height - ty - m->gappoh*oe - m->gappih*ie * (r - 1)) / r;
+			resize(c, m->w.x + mw + m->gappov*oe, m->w.y + ty, m->w.width - mw - 2*m->gappov*oe, h, 0);
+			ty += c->geom.height + m->gappih*ie;
 		}
 		i++;
 	}
@@ -2278,6 +2696,11 @@ unmapnotify(struct wl_listener *listener, void *data)
 {
 	/* Called when the surface is unmapped, and should no longer be shown. */
 	Client *c = wl_container_of(listener, c, unmap);
+
+	// Damage the whole screen
+	if (c->mon)
+		wlr_output_damage_add_whole(c->mon->damage);
+
 	wl_list_remove(&c->link);
 	if (client_is_unmanaged(c))
 		return;
@@ -2287,6 +2710,13 @@ unmapnotify(struct wl_listener *listener, void *data)
 	wl_list_remove(&c->slink);
 }
 
+void
+unmapnotify_sub(struct wl_listener *listener, void *data)
+{
+	Subsurface *s = wl_container_of(listener, s, unmap);
+	wl_list_remove(&s->link);
+}
+
 void
 updatemons(struct wl_listener *listener, void *data)
 {
@@ -2324,11 +2754,37 @@ updatemons(struct wl_listener *listener, void *data)
 	wlr_output_manager_v1_set_configuration(output_mgr, config);
 }
 
+void
+updatetitle(struct wl_listener *listener, void *data)
+{
+	Client *c = wl_container_of(listener, c, set_title);
+	if (c == focustop(c->mon))
+		printstatus();
+}
+
+void
+urgent(struct wl_listener *listener, void *data)
+{
+	struct wlr_xdg_activation_v1_request_activate_event *event = data;
+	Client *c;
+
+	if (!wlr_surface_is_xdg_surface(event->surface))
+		return;
+	c = wlr_xdg_surface_from_wlr_surface(event->surface)->data;
+	if (c != selclient()) {
+		c->isurgent = 1;
+		printstatus();
+	}
+}
+
+
 void
 view(const Arg *arg)
 {
-	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
+        unsigned int currtagset = selmon->tagset[selmon->seltags];
+	if ((arg->ui & TAGMASK) == currtagset)
 		return;
+        selmon->prevtagset = currtagset;
 	selmon->seltags ^= 1; /* toggle sel tagset */
 	if (arg->ui & TAGMASK)
 		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
@@ -2337,6 +2793,17 @@ view(const Arg *arg)
 	printstatus();
 }
 
+void
+viewprev(const Arg *arg)
+{
+        unsigned int tagset = selmon->tagset[selmon->seltags];
+        selmon->tagset[selmon->seltags] = selmon->prevtagset;
+        selmon->prevtagset = tagset;
+        focusclient(focustop(selmon), 1);
+        arrange(selmon);
+        printstatus();
+}
+
 void
 virtualkeyboard(struct wl_listener *listener, void *data)
 {
@@ -2348,12 +2815,19 @@ virtualkeyboard(struct wl_listener *listener, void *data)
 Client *
 xytoclient(double x, double y)
 {
-	/* Find the topmost visible client (if any) at point (x, y), including
+	/* Find the topmost visible client (if any) at point (x, y), excluding
 	 * borders. This relies on stack being ordered from top to bottom. */
 	Client *c;
-	wl_list_for_each(c, &stack, slink)
-		if (VISIBLEON(c, c->mon) && wlr_box_contains_point(&c->geom, x, y))
+        wl_list_for_each(c, &stack, slink) {
+		struct wlr_box p = {
+			.y = c->geom.y + borderpx,
+			.x = c->geom.x + borderpx,
+			.height = c->geom.height - 2 * borderpx,
+			.width = c->geom.width - 2 * borderpx,
+		};
+		if (VISIBLEON(c, c->mon) && wlr_box_contains_point(&p, x, y))
 			return c;
+	}
 	return NULL;
 }
 
@@ -2452,17 +2926,34 @@ createnotifyx11(struct wl_listener *listener, void *data)
 	c->type = xwayland_surface->override_redirect ? X11Unmanaged : X11Managed;
 	c->bw = borderpx;
 	c->isfullscreen = 0;
+	c->alpha = default_alpha;
 
 	/* Listen to the various events it can emit */
-	LISTEN(&xwayland_surface->events.map, &c->map, mapnotify);
+	if (c->type == X11Managed) {
+		LISTEN(&xwayland_surface->events.map, &c->map, mapnotify);
+		LISTEN(&xwayland_surface->events.request_activate, &c->activate,
+				activatex11);
+		LISTEN(&xwayland_surface->events.set_title, &c->set_title, updatetitle);
+		LISTEN(&xwayland_surface->events.request_fullscreen, &c->fullscreen,
+				fullscreennotify);
+	}
+	else {
+		LISTEN(&xwayland_surface->events.map, &c->map, mapnotify_unmanaged);
+	}
 	LISTEN(&xwayland_surface->events.unmap, &c->unmap, unmapnotify);
-	LISTEN(&xwayland_surface->events.request_activate, &c->activate,
-			activatex11);
 	LISTEN(&xwayland_surface->events.request_configure, &c->configure,
 			configurex11);
+	LISTEN(&xwayland_surface->events.set_title, &c->set_title, updatetitle);
 	LISTEN(&xwayland_surface->events.destroy, &c->destroy, destroynotify);
-	LISTEN(&xwayland_surface->events.request_fullscreen, &c->fullscreen,
-			fullscreennotify);
+}
+
+void
+commitnotifyx11(struct wl_listener *listener, void *data)
+{
+	Client *c = wl_container_of(listener, c, commit);
+
+	// Damage the whole screen
+	wlr_output_damage_add_whole(c->mon->damage);
 }
 
 Atom
@@ -2478,6 +2969,18 @@ getatom(xcb_connection_t *xc, const char *name)
 	return atom;
 }
 
+void
+mapnotify_unmanaged(struct wl_listener *listener, void *data)
+{
+	Client *c = wl_container_of(listener, c, map);
+	wl_list_insert(&independents, &c->link);
+	client_get_geometry(c, &c->geom);
+	c->mon = xytomon(c->geom.x, c->geom.y);
+	LISTEN(&c->surface.xwayland->surface->events.commit, &c->commit, commitnotifyx11);
+	wlr_output_damage_add_whole(c->mon->damage);
+}
+
+
 void
 renderindependents(struct wlr_output *output, struct timespec *now)
 {
@@ -2499,6 +3002,8 @@ renderindependents(struct wlr_output *output, struct timespec *now)
 		rdata.when = now;
 		rdata.x = c->surface.xwayland->x;
 		rdata.y = c->surface.xwayland->y;
+		rdata.alpha = c->alpha;
+
 		wlr_surface_for_each_surface(c->surface.xwayland->surface, render, &rdata);
 	}
 }
@@ -2557,15 +3062,233 @@ xytoindependent(double x, double y)
 }
 #endif
 
+void
+dscm_sendeventsclient(DscmClient *c)
+{
+        char root[HEXLENGTH], border[HEXLENGTH],
+             focus[HEXLENGTH], text[HEXLENGTH];
+
+        for (int i = 0; i < numtags; i++)
+                dscm_v1_send_tag(c->resource, tags[i]);
+        for (int i = 0; i < numlayouts; i++)
+                dscm_v1_send_layout(c->resource, layouts[i].symbol);
+
+        dscm_rgbatostr(root, rootcolor);
+        dscm_rgbatostr(border, bordercolor);
+        dscm_rgbatostr(focus, focuscolor);
+        dscm_rgbatostr(text, textcolor);
+        dscm_v1_send_colorscheme(c->resource, root, border, focus, text);
+}
+
+void
+dscm_sendevents(void)
+{
+	DscmClient *c;
+	wl_list_for_each(c, &dscm_clients, link)
+                dscm_sendeventsclient(c);
+}
+
+void
+dscm_rgbatostr(char *buf, float *color)
+{
+        if (!color)
+                return;
+
+        unsigned int r, g, b, a;
+        r = MAX(0, MIN(255, (int)ROUND(color[0] * 256.0)));
+        g = MAX(0, MIN(255, (int)ROUND(color[1] * 256.0)));
+        b = MAX(0, MIN(255, (int)ROUND(color[2] * 256.0)));
+        a = MAX(0, MIN(255, (int)ROUND(color[3] * 256.0)));
+        snprintf(buf, HEXLENGTH, "%02X%02X%02X%02X", r, g, b, a);
+}
+
+void
+dscm_closemon(struct wl_client *client, struct wl_resource *resource)
+{
+	wl_resource_destroy(resource);
+}
+
+void
+dscm_destroymon(struct wl_resource *resource) {
+	DscmMonitor *mon = wl_resource_get_user_data(resource);
+	if (mon) {
+		wl_list_remove(&mon->link);
+		free(mon);
+	}
+}
+
+void
+dscm_printstatusmon(Monitor *m, const DscmMonitor *mon)
+{
+	Client *c, *focused;
+	int tagmask, state, numclients, focusedclient;
+	focused = focustop(m);
+	dscm_monitor_v1_send_selected(mon->resource, m == selmon);
+
+	for (int tag = 0; tag < numtags; tag++) {
+		numclients = state = 0;
+		focusedclient = -1;
+		tagmask = 1 << tag;
+		if ((tagmask & m->tagset[m->seltags]) != 0)
+			state = state | DSCM_MONITOR_V1_TAG_STATE_ACTIVE;
+		wl_list_for_each(c, &clients, link) {
+			if (c->mon != m)
+				continue;
+			if (!(c->tags & tagmask))
+				continue;
+			if (c == focused)
+				focusedclient = numclients;
+			numclients++;
+			if (c->isurgent)
+				state = state | DSCM_MONITOR_V1_TAG_STATE_URGENT;
+		}
+		dscm_monitor_v1_send_tag(mon->resource, tag, state, numclients, focusedclient);
+	}
+	dscm_monitor_v1_send_layout(mon->resource, m->lt[m->sellt] - layouts);
+	dscm_monitor_v1_send_title(mon->resource, focused ? client_get_title(focused) : "");
+	dscm_monitor_v1_send_frame(mon->resource);
+}
+
+void
+dscm_printstatus(Monitor *m)
+{
+	DscmMonitor *mon;
+	wl_list_for_each(mon, &m->dscm, link)
+		dscm_printstatusmon(m, mon);
+}
+
+void
+dscm_settags(struct wl_client *client, struct wl_resource *resource,
+	uint32_t t, uint32_t toggletagset)
+{
+	DscmMonitor *mon;
+	Monitor *m;
+	mon = wl_resource_get_user_data(resource);
+	if (!mon)
+		return;
+	m = mon->monitor;
+	if ((t & TAGMASK) == m->tagset[m->seltags])
+		return;
+	if (toggletagset)
+		m->seltags ^= 1;
+	if (t & TAGMASK)
+		m->tagset[m->seltags] = t & TAGMASK;
+
+	focusclient(focustop(m), 1);
+	arrange(m);
+	printstatus();
+}
+
+void
+dscm_setlayout(struct wl_client *client, struct wl_resource *resource,
+	uint32_t layout)
+{
+	DscmMonitor *mon;
+	Monitor *m;
+	mon = wl_resource_get_user_data(resource);
+	if (!mon)
+		return;
+	m = mon->monitor;
+	if (layout >= numlayouts)
+		return;
+	if (layout != m->lt[m->sellt] - layouts)
+		m->sellt ^= 1;
+
+	m->lt[m->sellt] = &layouts[layout];
+	arrange(m);
+	printstatus();
+}
+
+void
+dscm_setclient(struct wl_client *client, struct wl_resource *resource,
+	uint32_t and, uint32_t xor)
+{
+	DscmMonitor *mon;
+	Client *sel;
+	unsigned int newtags;
+	mon = wl_resource_get_user_data(resource);
+	if (!mon)
+		return;
+	sel = focustop(mon->monitor);
+	if (!sel)
+		return;
+	newtags = (sel->tags & and) ^ xor;
+	if (newtags) {
+		sel->tags = newtags;
+		focusclient(focustop(selmon), 1);
+		arrange(selmon);
+		printstatus();
+	}
+}
+
+void
+dscm_release(struct wl_client *client, struct wl_resource *resource)
+{
+	wl_resource_destroy(resource);
+}
+
+void
+dscm_getmon(struct wl_client *client, struct wl_resource *resource,
+	uint32_t id, struct wl_resource *output)
+{
+	DscmMonitor *mon;
+	struct wlr_output *wlr_output = wlr_output_from_resource(output);
+	struct Monitor *m = wlr_output->data;
+	struct wl_resource *dscm_monitor_resource = wl_resource_create(client,
+		&dscm_monitor_v1_interface, wl_resource_get_version(resource), id);
+	if (!resource) {
+		wl_client_post_no_memory(client);
+		return;
+	}
+	mon = calloc(1, sizeof(DscmMonitor));
+	mon->resource = dscm_monitor_resource;
+	mon->monitor = m;
+	wl_resource_set_implementation(dscm_monitor_resource, &dscm_monitor_implementation,
+                mon, dscm_destroymon);
+	wl_list_insert(&m->dscm, &mon->link);
+	dscm_printstatusmon(m, mon);
+}
+
+void
+dscm_destroy(struct wl_resource *resource)
+{
+	DscmClient *c = wl_resource_get_user_data(resource);
+	if (c) {
+		wl_list_remove(&c->link);
+		free(c);
+	}
+}
+
+void
+dscm_bind(struct wl_client *client, void *data, uint32_t version, uint32_t id)
+{
+        DscmClient *c;
+        struct wl_resource *resource = wl_resource_create(client,
+                &dscm_v1_interface, version, id);
+	if (!resource) {
+		wl_client_post_no_memory(client);
+		return;
+	}
+
+        c = calloc(1, sizeof(DscmClient));
+        c->resource = resource;
+	wl_resource_set_implementation(resource, &dscm_implementation, c, dscm_destroy);
+        wl_list_insert(&dscm_clients, &c->link);
+        dscm_sendevents();
+}
+
 int
 main(int argc, char *argv[])
 {
 	char *startup_cmd = NULL;
+	char *config_file = NULL;
 	int c;
 
-	while ((c = getopt(argc, argv, "s:h")) != -1) {
+	while ((c = getopt(argc, argv, "s:c:h")) != -1) {
 		if (c == 's')
 			startup_cmd = optarg;
+                else if (c == 'c')
+                        config_file = optarg;
 		else
 			goto usage;
 	}
@@ -2576,11 +3299,16 @@ main(int argc, char *argv[])
 	// socket
 	if (!getenv("XDG_RUNTIME_DIR"))
 		BARF("XDG_RUNTIME_DIR must be set");
-	setup();
+        if (!config_file)
+                BARF("error: config path must be set using '-c'");
+        scm_init_guile();
+        dscm_register();
+        dscm_config_parse(config_file);
+	setup(config_file);
 	run(startup_cmd);
+        dscm_config_cleanup();
 	cleanup();
 	return EXIT_SUCCESS;
-
 usage:
-	BARF("Usage: %s [-s startup command]", argv[0]);
+	BARF("Usage: %s [-c path to config.scm] [-s startup command]", argv[0]);
 }
diff --git a/guix.scm b/guix.scm
new file mode 100644
index 0000000..cc679c5
--- /dev/null
+++ b/guix.scm
@@ -0,0 +1,38 @@
+(use-modules (dwl-guile packages)
+             (guix gexp)
+             (guix utils)
+             (guix packages)
+             (guix git-download)
+             (gnu packages wm)
+             (gnu packages guile))
+
+(define this-directory
+  (dirname (current-filename)))
+
+(define source
+  (local-file this-directory
+              #:recursive? #t
+              #:select? (git-predicate this-directory)))
+
+(package
+  (inherit dwl)
+  (source source)
+  (name "dwl-guile-devel")
+  (inputs
+    `(("guile-3.0" ,guile-3.0)
+      ("wlroots-0.14.0" ,wlroots-0.14.0)))
+  (arguments
+    (substitute-keyword-arguments
+      (package-arguments dwl)
+      ((#:phases phases)
+       `(modify-phases
+          ,phases
+            (replace
+              'install
+              (lambda*
+                (#:key inputs outputs #:allow-other-keys)
+                (let ((bin (string-append (assoc-ref outputs "out") "/bin")))
+                  (install-file "dwl" bin)
+                  (rename-file (string-append bin "/dwl")
+                               (string-append bin "/dwl-guile-devel"))
+                  #t))))))))
diff --git a/protocols/dscm-unstable-v1.xml b/protocols/dscm-unstable-v1.xml
new file mode 100644
index 0000000..c8fd797
--- /dev/null
+++ b/protocols/dscm-unstable-v1.xml
@@ -0,0 +1,177 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="dscm_unstable_v1">
+    <copyright>
+        Copyright (c) 2021 Raphael Robatsch
+        Copyright (c) 2021 Fredrik Engstrand
+
+        Permission is hereby granted, free of charge, to any person obtaining a
+        copy of this software and associated documentation files (the
+        "Software"), to deal in the Software without restriction, including
+        without limitation the rights to use, copy, modify, merge, publish,
+        distribute, sublicense, and/or sell copies of the Software, and to
+        permit persons to whom the Software is furnished to do so, subject to
+        the following conditions:
+
+        The above copyright notice and this permission notice (including the
+        next paragraph) shall be included in all copies or substantial portions
+        of the Software.
+
+        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+    </copyright>
+
+    <interface name="dscm_v1" version="1">
+        <description summary="control the dwl state">
+            This interface is exposed as a global in the wl_registry.
+
+            Clients can use this protocol to receive updates of the window manager
+            state (active tags, active layout, and focused window).
+            Clients can also control this state.
+
+            After binding, the client will receive the available tags and layouts
+            with the 'tag' and 'layout' events. These can be used in subsequent
+            dscm_monitor_v1.set_tags/set_layout requests, and to interpret the
+            dscm_monitor_v1.layout/tag events.
+        </description>
+
+        <request name="release" type="destructor">
+            <description summary="release dscm">
+                This request indicates that the client will not use the dscm
+                object any more. Objects that have been created through this instance
+                are not affected.
+            </description>
+        </request>
+
+        <request name="get_monitor">
+            <description summary="gets a dwl monitor from an output">
+                Gets a dscm monitor for the specified output. The window manager
+                state on the output can be controlled using the monitor.
+            </description>
+            <arg name="id" type="new_id" interface="dscm_monitor_v1" />
+            <arg name="output" type="object" interface="wl_output" />
+        </request>
+
+        <event name="tag">
+            <description summary="announces the presence of a tag">
+                This event is sent immediately after binding.
+                A roundtrip after binding guarantees that the client has received all tags.
+            </description>
+            <arg name="name" type="string"/>
+        </event>
+
+        <event name="layout">
+            <description summary="announces the presence of a layout">
+                This event is sent immediately after binding.
+                A roundtrip after binding guarantees that the client has received all layouts.
+            </description>
+            <arg name="name" type="string"/>
+        </event>
+
+        <event name="colorscheme">
+            <description summary="announces the current colorscheme">
+                This event is sent immediately after binding and will be resent
+                everytime the colorscheme changes. A roundtrip after binding
+                guarantees that the client has received the colorscheme.
+            </description>
+            <arg name="root" type="string" />
+            <arg name="border" type="string" />
+            <arg name="focus" type="string" />
+            <arg name="text" type="string" />
+        </event>
+    </interface>
+
+    <interface name="dscm_monitor_v1" version="1">
+        <description summary="control one monitor">
+            Observes and controls one monitor.
+
+            Events are double-buffered: Clients should cache all events and only
+            redraw themselves once the 'frame' event is sent.
+
+            Requests are not double-buffered: The compositor will update itself
+            immediately.
+        </description>
+
+        <enum name="tag_state">
+            <entry name="none" value="0" summary="no state"/>
+            <entry name="active" value="1" summary="tag is active"/>
+            <entry name="urgent" value="2" summary="tag has at least one urgent client"/>
+        </enum>
+
+        <request name="release" type="destructor">
+            <description summary="release dscm_monitor">
+                This request indicates that the client is done with this dscm_monitor.
+                All further requests are ignored.
+            </description>
+        </request>
+
+        <event name="selected">
+            <description summary="updates the selected state of the monitor">
+                If 'selected' is nonzero, this monitor is the currently selected one.
+            </description>
+            <arg name="selected" type="uint"/>
+        </event>
+
+        <event name="tag">
+            <description summary="updates the state of one tag">
+                Announces the update of a tag. num_clients and focused_client can be
+                used to draw client indicators.
+            </description>
+            <arg name="tag" type="uint" summary="index of a tag received by the dscm_v1.tag event." />
+            <arg name="state" type="uint" enum="tag_state"/>
+            <arg name="num_clients" type="uint" summary="number of clients on this tag"/>
+            <arg name="focused_client" type="int" summary="out of num_clients. -1 if there is no focused client"/>
+        </event>
+
+        <event name="layout">
+            <description summary="updates the selected layout">
+                Announces the update of the selected layout.
+            </description>
+            <arg name="layout" type="uint" summary="index of a layout received by the dscm_v1.layout event."/>
+        </event>
+
+        <event name="title">
+            <description summary="updates the focused client">
+                Announces the update of the selected client.
+            </description>
+            <arg name="title" type="string"/>
+        </event>
+
+        <event name="frame">
+            <description summary="end of status update sequence">
+                Sent after all other events belonging to the status update has been sent.
+                Clients should redraw themselves now.
+            </description>
+        </event>
+
+        <request name="set_tags">
+            <description summary="sets the active tags on this monitor.">
+                Changes are applied immediately.
+            </description>
+            <arg name="tagmask" type="uint" summary="bitmask of the tags that should be set."/>
+            <arg name="toggle_tagset" type="uint"/>
+        </request>
+
+        <request name="set_client_tags">
+            <description summary="updates the tags of the focused client.">
+                tags are updated as follows:
+                new_tags = (current_tags AND and_tags) XOR xor_tags
+
+                Changes are applied immediately.
+            </description>
+            <arg name="and_tags" type="uint"/>
+            <arg name="xor_tags" type="uint"/>
+        </request>
+
+        <request name="set_layout">
+            <description summary="sets the active layout on this monitor.">
+                Changes are applied immediately.
+            </description>
+            <arg name="layout" type="uint" summary="index of a layout received by the dscm_v1.layout event."/>
+        </request>
+    </interface>
+</protocol>
diff --git a/scripts/create-patches.sh b/scripts/create-patches.sh
new file mode 100755
index 0000000..fa50f95
--- /dev/null
+++ b/scripts/create-patches.sh
@@ -0,0 +1,25 @@
+#!/bin/sh
+# $1 = dwl-guile patch tag to diff patches to
+
+git fetch --all
+rm -rf patches
+mkdir -p patches
+
+# Make sure we always have a branch/tag to diff against,
+# otherwise, the patch output will be inverted.
+DIFF_ORIGIN=$1
+[ -z $DIFF_ORIGIN ] && DIFF_ORIGIN="main"
+
+for patch in xwayland smartborders attachabove \
+    monitor-config focusmonpointer swallow movestack
+do
+    git fetch origin patch/$patch
+    git diff $DIFF_ORIGIN patch/$patch \
+        ':(exclude)README.md' \
+        ':(exclude)patches' \
+        ':(exclude)scripts/create-patches.sh' \
+        ':(exclude).gitignore' > patches/$patch.patch
+done
+
+# Create dwl-guile patch based on dwl v0.2.1
+git diff v0.2.1 > patches/dwl-guile.patch
