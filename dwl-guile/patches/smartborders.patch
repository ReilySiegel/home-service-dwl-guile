diff --git a/dwl.c b/dwl.c
index e7d3dea..505f217 100644
--- a/dwl.c
+++ b/dwl.c
@@ -326,7 +326,7 @@ static void render(struct wlr_surface *surface, int sx, int sy, void *data);
 static void renderclients(Monitor *m, struct timespec *now);
 static void renderlayer(struct wl_list *layer_surfaces, struct timespec *now);
 static void rendermon(struct wl_listener *listener, void *data);
-static void resize(Client *c, int x, int y, int w, int h, int interact);
+static void resize(Client *c, int x, int y, int w, int h, int interact, int draw_borders);
 static void run(char *startup_cmd);
 static void scalebox(struct wlr_box *box, float scale);
 static Client *selclient(void);
@@ -468,6 +468,7 @@ static Atom netatom[NetLast];
 #include "dscm-utils.h"
 #include "dscm-config.h"
 #include "dscm-bindings.h"
+#include "patch-smartborders.h"
 
 /* function implementations */
 void
@@ -862,7 +863,7 @@ closemon(Monitor *m)
 	wl_list_for_each(c, &clients, link) {
 		if (c->isfloating && c->geom.x > m->m.width)
 			resize(c, c->geom.x - m->w.width, c->geom.y,
-				c->geom.width, c->geom.height, 0);
+				c->geom.width, c->geom.height, 0, 1);
 		if (c->mon == m)
 			setmon(c, selmon, c->tags);
 	}
@@ -1011,7 +1012,7 @@ createmon(struct wl_listener *listener, void *data)
 		wl_list_for_each(c, &clients, link) {
 			if (c->isfloating)
 				resize(c, c->geom.x + m->w.width, c->geom.y,
-						c->geom.width, c->geom.height, 0);
+						c->geom.width, c->geom.height, 0, 1);
 		}
 		return;
 	}
@@ -1230,7 +1231,8 @@ setfullscreen(Client *c, int fullscreen)
 		c->prevwidth = c->geom.width;
                 c->prevalpha = c->alpha;
                 c->alpha = 1;
-		resize(c, c->mon->m.x, c->mon->m.y, c->mon->m.width, c->mon->m.height, 0);
+		resize(c, c->mon->m.x, c->mon->m.y, c->mon->m.width, c->mon->m.height,
+                        0, !smartborders);
 		wl_list_remove(&c->slink);
 		wl_list_insert(&stack, &c->slink);
 		motionnotify(0);
@@ -1238,7 +1240,7 @@ setfullscreen(Client *c, int fullscreen)
 		/* restore previous size instead of arrange for floating windows since
 		 * client positions are set by the user and cannot be recalculated */
                 c->alpha = c->prevalpha;
-		resize(c, c->prevx, c->prevy, c->prevwidth, c->prevheight, 0);
+		resize(c, c->prevx, c->prevy, c->prevwidth, c->prevheight, 0, 1);
 		if (!c->isfloating) {
 			wl_list_remove(&c->slink);
 			wl_list_insert(stack.prev, &c->slink);
@@ -1555,7 +1557,10 @@ monocle(Monitor *m)
 	wl_list_for_each(c, &clients, link) {
 		if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
 			continue;
-		resize(c, m->w.x, m->w.y, m->w.width, m->w.height, 0);
+		if (c->isfullscreen)
+			setfullscreen(c, 1);
+		else
+			resize(c, m->w.x, m->w.y, m->w.width, m->w.height, 0, !smartborders);
 	}
 
         /* Lift selected client */
@@ -1600,12 +1605,12 @@ motionnotify(uint32_t time)
 	if (cursor_mode == CurMove) {
 		/* Move the grabbed client to the new position. */
 		resize(grabc, cursor->x - grabcx, cursor->y - grabcy,
-				grabc->geom.width, grabc->geom.height, 1);
+				grabc->geom.width, grabc->geom.height, 1, 1);
 		return;
 	} else if (cursor_mode == CurResize) {
 		resize(grabc, grabc->geom.x, grabc->geom.y,
 				cursor->x - grabc->geom.x,
-				cursor->y - grabc->geom.y, 1);
+				cursor->y - grabc->geom.y, 1, 1);
 		return;
 	}
 
@@ -2041,7 +2046,7 @@ rendermon(struct wl_listener *listener, void *data)
 }
 
 void
-resize(Client *c, int x, int y, int w, int h, int interact)
+resize(Client *c, int x, int y, int w, int h, int interact, int draw_borders)
 {
 	/*
 	 * Note that I took some shortcuts here. In a more fleshed-out
@@ -2053,6 +2058,7 @@ resize(Client *c, int x, int y, int w, int h, int interact)
 	c->geom.y = y;
 	c->geom.width = w;
 	c->geom.height = h;
+	c->bw = (1 - !draw_borders) * borderpx;
 	applybounds(c, bbox);
 	/* wlroots makes this a no-op if size hasn't changed */
 	c->resize = client_set_size(c, c->geom.width - 2 * c->bw,
@@ -2289,6 +2295,15 @@ setlayout(const Arg *arg)
 		selmon->sellt ^= 1;
 	if (arg && arg->v)
 		selmon->lt[selmon->sellt] = (Layout *)arg->v;
+	if (!selmon->lt[selmon->sellt]->arrange) {
+		/* floating layout, draw borders around all clients */
+		Client *c;
+		wl_list_for_each(c, &clients, link) {
+			if (c->bw)
+				continue;
+			resize(c, c->geom.x, c->geom.y, c->geom.width, c->geom.height, 0, 1);
+		}
+	}
 	/* TODO change layout symbol? */
 	arrange(selmon);
 	printstatus();
@@ -2367,7 +2382,8 @@ reloadconfig(int signal, void *data) {
         wl_list_for_each(c, &clients, link) {
                 if (c->bw > 0)
                         c->bw = borderpx;
-                resize(c, c->geom.x, c->geom.y, c->geom.width, c->geom.height, 0);
+                /* TODO: This will also apply borders to clients that did not previously have borders */
+                resize(c, c->geom.x, c->geom.y, c->geom.width, c->geom.height, 0, 1);
         }
 
         /* Rearrange clients on all monitors */
@@ -2598,7 +2614,8 @@ tagmon(const Arg *arg)
 void
 tile(Monitor *m)
 {
-	unsigned int i, n = 0, h, r, oe = enablegaps, ie = enablegaps, mw, my, ty;
+	unsigned int i, n = 0, h, r, oe = enablegaps, ie = enablegaps,
+                     mw, my, ty, draw_borders = 1;
 	Client *c;
 
 	wl_list_for_each(c, &clients, link)
@@ -2607,9 +2624,10 @@ tile(Monitor *m)
 	if (n == 0)
 		return;
 
-	if (smartgaps == n) {
+	if (smartgaps == n)
 		oe = 0; // outer gaps disabled
-	}
+	if (n == smartborders)
+		draw_borders = 0;
 
 	if (n > m->nmaster)
 		mw = m->nmaster ? (m->w.width + m->gappiv*ie) * m->mfact : 0;
@@ -2623,12 +2641,14 @@ tile(Monitor *m)
 		if (i < m->nmaster) {
 			r = MIN(n, m->nmaster) - i;
 			h = (m->w.height - my - m->gappoh*oe - m->gappih*ie * (r - 1)) / r;
-			resize(c, m->w.x + m->gappov*oe, m->w.y + my, mw - m->gappiv*ie, h, 0);
+			resize(c, m->w.x + m->gappov*oe, m->w.y + my, mw - m->gappiv*ie, h,
+                                0, draw_borders);
 			my += c->geom.height + m->gappih*ie;
 		} else {
 			r = n - i;
 			h = (m->w.height - ty - m->gappoh*oe - m->gappih*ie * (r - 1)) / r;
-			resize(c, m->w.x + mw + m->gappov*oe, m->w.y + ty, m->w.width - mw - 2*m->gappov*oe, h, 0);
+			resize(c, m->w.x + mw + m->gappov*oe, m->w.y + ty,
+                                m->w.width - mw - 2*m->gappov*oe, h, 0, draw_borders);
 			ty += c->geom.height + m->gappih*ie;
 		}
 		i++;
@@ -3304,6 +3324,7 @@ main(int argc, char *argv[])
         scm_init_guile();
         dscm_register();
         dscm_config_parse(config_file);
+        patch_smartborders_config_parse();
 	setup(config_file);
 	run(startup_cmd);
         dscm_config_cleanup();
diff --git a/patch-smartborders.h b/patch-smartborders.h
new file mode 100644
index 0000000..c803d1f
--- /dev/null
+++ b/patch-smartborders.h
@@ -0,0 +1,7 @@
+static int smartborders = 0;
+
+static inline void
+patch_smartborders_config_parse()
+{
+        smartborders = dscm_alist_get_int(config, "smart-borders");
+}
