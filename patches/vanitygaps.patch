diff --git a/dscm-bindings.h b/dscm-bindings.h
index 7f6ab85..2f0c7c7 100644
--- a/dscm-bindings.h
+++ b/dscm-bindings.h
@@ -205,6 +205,75 @@ dscm_binding_quit()
         return SCM_BOOL_T;
 }
 
+static inline SCM
+dscm_binding_incrgaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrgaps(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incrigaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrigaps(&a);
+        return SCM_BOOL_T;
+}
+static inline SCM
+dscm_binding_incrogaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrogaps(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incrohgaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrohgaps(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incrovgaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrovgaps(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incrihgaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrihgaps(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_incrivgaps(SCM value)
+{
+        Arg a = {.i = scm_to_int(value)};
+        incrivgaps(&a);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_togglegaps()
+{
+        togglegaps(NULL);
+        return SCM_BOOL_T;
+}
+
+static inline SCM
+dscm_binding_defaultgaps()
+{
+        defaultgaps(NULL);
+        return SCM_BOOL_T;
+}
+
 static inline void
 dscm_register_constants()
 {
@@ -280,4 +349,13 @@ dscm_register_procedures()
         scm_c_define_gsubr("dwl:shcmd", 1, 0, 0, &dscm_binding_shcmd);
         scm_c_define_gsubr("dwl:spawn-menu", 0, 0, 0, &dscm_binding_spawn_menu);
         scm_c_define_gsubr("dwl:spawn-terminal", 0, 0, 0, &dscm_binding_spawn_terminal);
+        scm_c_define_gsubr("dwl:toggle-gaps", 0, 0, 0, &dscm_binding_togglegaps);
+        scm_c_define_gsubr("dwl:default-gaps", 0, 0, 0, &dscm_binding_defaultgaps);
+        scm_c_define_gsubr("dwl:gaps", 1, 0, 0, &dscm_binding_incrgaps);
+        scm_c_define_gsubr("dwl:gaps-inner", 1, 0, 0, &dscm_binding_incrigaps);
+        scm_c_define_gsubr("dwl:gaps-outer", 1, 0, 0, &dscm_binding_incrogaps);
+        scm_c_define_gsubr("dwl:gaps-inner-horizontal", 1, 0, 0, &dscm_binding_incrihgaps);
+        scm_c_define_gsubr("dwl:gaps-inner-vertical", 1, 0, 0, &dscm_binding_incrivgaps);
+        scm_c_define_gsubr("dwl:gaps-outer-horizontal", 1, 0, 0, &dscm_binding_incrohgaps);
+        scm_c_define_gsubr("dwl:gaps-outer-vertical", 1, 0, 0, &dscm_binding_incrovgaps);
 }
diff --git a/dscm-config.h b/dscm-config.h
index c32af96..483e430 100644
--- a/dscm-config.h
+++ b/dscm-config.h
@@ -28,6 +28,11 @@ static unsigned int numlayouts  = 0;
 static unsigned int nummonrules = 0;
 static unsigned int numbuttons  = 0;
 static unsigned int TAGMASK     = 0;
+static unsigned int gappih      = 0;
+static unsigned int gappiv      = 0;
+static unsigned int gappoh      = 0;
+static unsigned int gappov      = 0;
+static int smartgaps            = 0;
 
 static inline void
 dscm_parse_color(unsigned int index, SCM value, void *data)
@@ -134,6 +139,11 @@ dscm_parse_config(char *config_file)
         borderpx = dscm_alist_get_unsigned_int(config, "border-px", 25);
         repeat_rate = dscm_alist_get_unsigned_int(config, "repeat-rate", 5000);
         repeat_delay = dscm_alist_get_unsigned_int(config, "repeat-delay", 5000);
+        gappih = dscm_alist_get_unsigned_int(config, "gaps-horizontal-inner", -1);
+        gappiv = dscm_alist_get_unsigned_int(config, "gaps-vertical-inner", -1);
+        gappoh = dscm_alist_get_unsigned_int(config, "gaps-horizontal-outer", -1);
+        gappov = dscm_alist_get_unsigned_int(config, "gaps-vertical-outer", -1);
+        smartgaps = dscm_alist_get_int(config, "smart-gaps");
 
         SCM colors = dscm_alist_get(config, "colors");
         rootcolor = dscm_iterate_list(dscm_alist_get(colors, "root"),
diff --git a/dwl.c b/dwl.c
index c018cdb..c2a2689 100644
--- a/dwl.c
+++ b/dwl.c
@@ -168,6 +168,10 @@ struct Monitor {
 	struct wlr_box w;      /* window area, layout-relative */
 	struct wl_list layers[4]; // LayerSurface::link
 	const Layout *lt[2];
+	int gappih;           /* horizontal gap between windows */
+	int gappiv;           /* vertical gap between windows */
+	int gappoh;           /* horizontal outer gaps */
+	int gappov;           /* vertical outer gaps */
 	unsigned int seltags;
 	unsigned int sellt;
 	unsigned int tagset[2];
@@ -296,6 +300,16 @@ static struct wlr_surface *xytolayersurface(struct wl_list *layer_surfaces,
 		double x, double y, double *sx, double *sy);
 static Monitor *xytomon(double x, double y);
 static void zoom(const Arg *arg);
+static void setgaps(int oh, int ov, int ih, int iv);
+static void incrgaps(const Arg *arg);
+static void incrigaps(const Arg *arg);
+static void incrogaps(const Arg *arg);
+static void incrohgaps(const Arg *arg);
+static void incrovgaps(const Arg *arg);
+static void incrihgaps(const Arg *arg);
+static void incrivgaps(const Arg *arg);
+static void togglegaps(const Arg *arg);
+static void defaultgaps(const Arg *arg);
 
 /* variables */
 static const char broken[] = "broken";
@@ -333,6 +347,8 @@ static struct wlr_box sgeom;
 static struct wl_list mons;
 static Monitor *selmon;
 
+static int enablegaps = 1;   /* enables gaps, used by togglegaps */
+
 /* global event handlers */
 static struct wl_listener cursor_axis = {.notify = axisnotify};
 static struct wl_listener cursor_button = {.notify = buttonpress};
@@ -821,6 +837,10 @@ createmon(struct wl_listener *listener, void *data)
 	MonitorRule r;
 	Monitor *m = wlr_output->data = calloc(1, sizeof(*m));
 	m->wlr_output = wlr_output;
+	m->gappih = gappih;
+	m->gappiv = gappiv;
+	m->gappoh = gappoh;
+	m->gappov = gappov;
 
 	/* Initialize monitor state using configured rules */
 	for (size_t i = 0; i < LENGTH(m->layers); i++)
@@ -1902,6 +1922,111 @@ setfloating(Client *c, int floating)
 	arrange(c->mon);
 }
 
+void
+setgaps(int oh, int ov, int ih, int iv)
+{
+	if (oh < 0) oh = 0;
+	if (ov < 0) ov = 0;
+	if (ih < 0) ih = 0;
+	if (iv < 0) iv = 0;
+
+	selmon->gappoh = oh;
+	selmon->gappov = ov;
+	selmon->gappih = ih;
+	selmon->gappiv = iv;
+	arrange(selmon);
+}
+
+void
+togglegaps(const Arg *arg)
+{
+	enablegaps = !enablegaps;
+	arrange(selmon);
+}
+
+void
+defaultgaps(const Arg *arg)
+{
+	setgaps(gappoh, gappov, gappih, gappiv);
+}
+
+void
+incrgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov + arg->i,
+		selmon->gappih + arg->i,
+		selmon->gappiv + arg->i
+	);
+}
+
+void
+incrigaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih + arg->i,
+		selmon->gappiv + arg->i
+	);
+}
+
+void
+incrogaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov + arg->i,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrohgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh + arg->i,
+		selmon->gappov,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrovgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov + arg->i,
+		selmon->gappih,
+		selmon->gappiv
+	);
+}
+
+void
+incrihgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih + arg->i,
+		selmon->gappiv
+	);
+}
+
+void
+incrivgaps(const Arg *arg)
+{
+	setgaps(
+		selmon->gappoh,
+		selmon->gappov,
+		selmon->gappih,
+		selmon->gappiv + arg->i
+	);
+}
+
 void
 setlayout(const Arg *arg)
 {
@@ -2175,7 +2300,7 @@ tagmon(const Arg *arg)
 void
 tile(Monitor *m)
 {
-	unsigned int i, n = 0, h, mw, my, ty;
+	unsigned int i, n = 0, h, r, oe = enablegaps, ie = enablegaps, mw, my, ty;
 	Client *c;
 
 	wl_list_for_each(c, &clients, link)
@@ -2184,24 +2309,31 @@ tile(Monitor *m)
 	if (n == 0)
 		return;
 
+	if (smartgaps == n) {
+		oe = 0; // outer gaps disabled
+	}
+
 	if (n > m->nmaster)
-		mw = m->nmaster ? m->w.width * m->mfact : 0;
+		mw = m->nmaster ? (m->w.width + m->gappiv*ie) * m->mfact : 0;
 	else
-		mw = m->w.width;
-	i = my = ty = 0;
+		mw = m->w.width - 2*m->gappov*oe + m->gappiv*ie;
+	i = 0;
+	my = ty = m->gappoh*oe;
 	wl_list_for_each(c, &clients, link) {
 		if (!VISIBLEON(c, m) || c->isfloating)
 			continue;
 		if (c->isfullscreen)
 			maximizeclient(c);
 		else if (i < m->nmaster) {
-			h = (m->w.height - my) / (MIN(n, m->nmaster) - i);
-			resize(c, m->w.x, m->w.y + my, mw, h, 0);
-			my += c->geom.height;
+			r = MIN(n, m->nmaster) - i;
+			h = (m->w.height - my - m->gappoh*oe - m->gappih*ie * (r - 1)) / r;
+			resize(c, m->w.x + m->gappov*oe, m->w.y + my, mw - m->gappiv*ie, h, 0);
+			my += c->geom.height + m->gappih*ie;
 		} else {
-			h = (m->w.height - ty) / (n - i);
-			resize(c, m->w.x + mw, m->w.y + ty, m->w.width - mw, h, 0);
-			ty += c->geom.height;
+			r = n - i;
+			h = (m->w.height - ty - m->gappoh*oe - m->gappih*ie * (r - 1)) / r;
+			resize(c, m->w.x + mw + m->gappov*oe, m->w.y + ty, m->w.width - mw - 2*m->gappov*oe, h, 0);
+			ty += c->geom.height + m->gappih*ie;
 		}
 		i++;
 	}
